   1               		.file	"ff.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	ld_dword:
  12               	.LFB1:
  13               		.file 1 "ff.c"
   1:ff.c          **** /*----------------------------------------------------------------------------/
   2:ff.c          **** /  FatFs - Generic FAT Filesystem Module  R0.14a                              /
   3:ff.c          **** /-----------------------------------------------------------------------------/
   4:ff.c          **** /
   5:ff.c          **** / Copyright (C) 2020, ChaN, all right reserved.
   6:ff.c          **** /
   7:ff.c          **** / FatFs module is an open source software. Redistribution and use of FatFs in
   8:ff.c          **** / source and binary forms, with or without modification, are permitted provided
   9:ff.c          **** / that the following condition is met:
  10:ff.c          **** /
  11:ff.c          **** / 1. Redistributions of source code must retain the above copyright notice,
  12:ff.c          **** /    this condition and the following disclaimer.
  13:ff.c          **** /
  14:ff.c          **** / This software is provided by the copyright holder and contributors "AS IS"
  15:ff.c          **** / and any warranties related to this software are DISCLAIMED.
  16:ff.c          **** / The copyright owner or contributors be NOT LIABLE for any damages caused
  17:ff.c          **** / by use of this software.
  18:ff.c          **** /
  19:ff.c          **** /----------------------------------------------------------------------------*/
  20:ff.c          **** 
  21:ff.c          **** 
  22:ff.c          **** #include "ff.h"			/* Declarations of FatFs API */
  23:ff.c          **** #include "diskio.h"		/* Declarations of device I/O functions */
  24:ff.c          **** 
  25:ff.c          **** 
  26:ff.c          **** /*--------------------------------------------------------------------------
  27:ff.c          **** 
  28:ff.c          ****    Module Private Definitions
  29:ff.c          **** 
  30:ff.c          **** ---------------------------------------------------------------------------*/
  31:ff.c          **** 
  32:ff.c          **** #if FF_DEFINED != 80196	/* Revision ID */
  33:ff.c          **** #error Wrong include file (ff.h).
  34:ff.c          **** #endif
  35:ff.c          **** 
  36:ff.c          **** 
  37:ff.c          **** /* Limits and boundaries */
  38:ff.c          **** #define MAX_DIR		0x200000		/* Max size of FAT directory */
  39:ff.c          **** #define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
  40:ff.c          **** #define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows
  41:ff.c          **** #define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Window
  42:ff.c          **** #define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
  43:ff.c          **** #define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
  44:ff.c          **** 
  45:ff.c          **** 
  46:ff.c          **** /* Character code support macros */
  47:ff.c          **** #define IsUpper(c)		((c) >= 'A' && (c) <= 'Z')
  48:ff.c          **** #define IsLower(c)		((c) >= 'a' && (c) <= 'z')
  49:ff.c          **** #define IsDigit(c)		((c) >= '0' && (c) <= '9')
  50:ff.c          **** #define IsSurrogate(c)	((c) >= 0xD800 && (c) <= 0xDFFF)
  51:ff.c          **** #define IsSurrogateH(c)	((c) >= 0xD800 && (c) <= 0xDBFF)
  52:ff.c          **** #define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <= 0xDFFF)
  53:ff.c          **** 
  54:ff.c          **** 
  55:ff.c          **** /* Additional file access control and file status flags for internal use */
  56:ff.c          **** #define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
  57:ff.c          **** #define FA_MODIFIED	0x40	/* File has been modified */
  58:ff.c          **** #define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
  59:ff.c          **** 
  60:ff.c          **** 
  61:ff.c          **** /* Additional file attribute bits for internal use */
  62:ff.c          **** #define AM_VOL		0x08	/* Volume label */
  63:ff.c          **** #define AM_LFN		0x0F	/* LFN entry */
  64:ff.c          **** #define AM_MASK		0x3F	/* Mask of defined bits */
  65:ff.c          **** 
  66:ff.c          **** 
  67:ff.c          **** /* Name status flags in fn[11] */
  68:ff.c          **** #define NSFLAG		11		/* Index of the name status byte */
  69:ff.c          **** #define NS_LOSS		0x01	/* Out of 8.3 format */
  70:ff.c          **** #define NS_LFN		0x02	/* Force to create LFN entry */
  71:ff.c          **** #define NS_LAST		0x04	/* Last segment */
  72:ff.c          **** #define NS_BODY		0x08	/* Lower case flag (body) */
  73:ff.c          **** #define NS_EXT		0x10	/* Lower case flag (ext) */
  74:ff.c          **** #define NS_DOT		0x20	/* Dot entry */
  75:ff.c          **** #define NS_NOLFN	0x40	/* Do not find LFN */
  76:ff.c          **** #define NS_NONAME	0x80	/* Not followed */
  77:ff.c          **** 
  78:ff.c          **** 
  79:ff.c          **** /* exFAT directory entry types */
  80:ff.c          **** #define	ET_BITMAP	0x81	/* Allocation bitmap */
  81:ff.c          **** #define	ET_UPCASE	0x82	/* Up-case table */
  82:ff.c          **** #define	ET_VLABEL	0x83	/* Volume label */
  83:ff.c          **** #define	ET_FILEDIR	0x85	/* File and directory */
  84:ff.c          **** #define	ET_STREAM	0xC0	/* Stream extension */
  85:ff.c          **** #define	ET_FILENAME	0xC1	/* Name extension */
  86:ff.c          **** 
  87:ff.c          **** 
  88:ff.c          **** /* FatFs refers the FAT structure as simple byte array instead of structure member
  89:ff.c          **** / because the C structure is not binary compatible between different platforms */
  90:ff.c          **** 
  91:ff.c          **** #define BS_JmpBoot			0		/* x86 jump instruction (3-byte) */
  92:ff.c          **** #define BS_OEMName			3		/* OEM name (8-byte) */
  93:ff.c          **** #define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
  94:ff.c          **** #define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
  95:ff.c          **** #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
  96:ff.c          **** #define BPB_NumFATs			16		/* Number of FATs (BYTE) */
  97:ff.c          **** #define BPB_RootEntCnt		17		/* Size of root directory area for FAT [entry] (WORD) */
  98:ff.c          **** #define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
  99:ff.c          **** #define BPB_Media			21		/* Media descriptor byte (BYTE) */
 100:ff.c          **** #define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
 101:ff.c          **** #define BPB_SecPerTrk		24		/* Number of sectors per track for int13h [sector] (WORD) */
 102:ff.c          **** #define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
 103:ff.c          **** #define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
 104:ff.c          **** #define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
 105:ff.c          **** #define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
 106:ff.c          **** #define BS_NTres			37		/* WindowsNT error flag (BYTE) */
 107:ff.c          **** #define BS_BootSig			38		/* Extended boot signature (BYTE) */
 108:ff.c          **** #define BS_VolID			39		/* Volume serial number (DWORD) */
 109:ff.c          **** #define BS_VolLab			43		/* Volume label string (8-byte) */
 110:ff.c          **** #define BS_FilSysType		54		/* Filesystem type string (8-byte) */
 111:ff.c          **** #define BS_BootCode			62		/* Boot code (448-byte) */
 112:ff.c          **** #define BS_55AA				510		/* Signature word (WORD) */
 113:ff.c          **** 
 114:ff.c          **** #define BPB_FATSz32			36		/* FAT32: FAT size [sector] (DWORD) */
 115:ff.c          **** #define BPB_ExtFlags32		40		/* FAT32: Extended flags (WORD) */
 116:ff.c          **** #define BPB_FSVer32			42		/* FAT32: Filesystem version (WORD) */
 117:ff.c          **** #define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
 118:ff.c          **** #define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
 119:ff.c          **** #define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
 120:ff.c          **** #define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
 121:ff.c          **** #define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
 122:ff.c          **** #define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
 123:ff.c          **** #define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
 124:ff.c          **** #define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
 125:ff.c          **** #define BS_FilSysType32		82		/* FAT32: Filesystem type string (8-byte) */
 126:ff.c          **** #define BS_BootCode32		90		/* FAT32: Boot code (420-byte) */
 127:ff.c          **** 
 128:ff.c          **** #define BPB_ZeroedEx		11		/* exFAT: MBZ field (53-byte) */
 129:ff.c          **** #define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
 130:ff.c          **** #define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
 131:ff.c          **** #define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
 132:ff.c          **** #define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
 133:ff.c          **** #define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
 134:ff.c          **** #define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
 135:ff.c          **** #define BPB_RootClusEx		96		/* exFAT: Root directory start cluster (DWORD) */
 136:ff.c          **** #define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
 137:ff.c          **** #define BPB_FSVerEx			104		/* exFAT: Filesystem version (WORD) */
 138:ff.c          **** #define BPB_VolFlagEx		106		/* exFAT: Volume flags (WORD) */
 139:ff.c          **** #define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in unit of byte (BYTE) */
 140:ff.c          **** #define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in unit of sector (BYTE) */
 141:ff.c          **** #define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
 142:ff.c          **** #define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
 143:ff.c          **** #define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
 144:ff.c          **** #define BPB_RsvdEx			113		/* exFAT: Reserved (7-byte) */
 145:ff.c          **** #define BS_BootCodeEx		120		/* exFAT: Boot code (390-byte) */
 146:ff.c          **** 
 147:ff.c          **** #define DIR_Name			0		/* Short file name (11-byte) */
 148:ff.c          **** #define DIR_Attr			11		/* Attribute (BYTE) */
 149:ff.c          **** #define DIR_NTres			12		/* Lower case flag (BYTE) */
 150:ff.c          **** #define DIR_CrtTime10		13		/* Created time sub-second (BYTE) */
 151:ff.c          **** #define DIR_CrtTime			14		/* Created time (DWORD) */
 152:ff.c          **** #define DIR_LstAccDate		18		/* Last accessed date (WORD) */
 153:ff.c          **** #define DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
 154:ff.c          **** #define DIR_ModTime			22		/* Modified time (DWORD) */
 155:ff.c          **** #define DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
 156:ff.c          **** #define DIR_FileSize		28		/* File size (DWORD) */
 157:ff.c          **** #define LDIR_Ord			0		/* LFN: LFN order and LLE flag (BYTE) */
 158:ff.c          **** #define LDIR_Attr			11		/* LFN: LFN attribute (BYTE) */
 159:ff.c          **** #define LDIR_Type			12		/* LFN: Entry type (BYTE) */
 160:ff.c          **** #define LDIR_Chksum			13		/* LFN: Checksum of the SFN (BYTE) */
 161:ff.c          **** #define LDIR_FstClusLO		26		/* LFN: MBZ field (WORD) */
 162:ff.c          **** #define XDIR_Type			0		/* exFAT: Type of exFAT directory entry (BYTE) */
 163:ff.c          **** #define XDIR_NumLabel		1		/* exFAT: Number of volume label characters (BYTE) */
 164:ff.c          **** #define XDIR_Label			2		/* exFAT: Volume label (11-WORD) */
 165:ff.c          **** #define XDIR_CaseSum		4		/* exFAT: Sum of case conversion table (DWORD) */
 166:ff.c          **** #define XDIR_NumSec			1		/* exFAT: Number of secondary entries (BYTE) */
 167:ff.c          **** #define XDIR_SetSum			2		/* exFAT: Sum of the set of directory entries (WORD) */
 168:ff.c          **** #define XDIR_Attr			4		/* exFAT: File attribute (WORD) */
 169:ff.c          **** #define XDIR_CrtTime		8		/* exFAT: Created time (DWORD) */
 170:ff.c          **** #define XDIR_ModTime		12		/* exFAT: Modified time (DWORD) */
 171:ff.c          **** #define XDIR_AccTime		16		/* exFAT: Last accessed time (DWORD) */
 172:ff.c          **** #define XDIR_CrtTime10		20		/* exFAT: Created time subsecond (BYTE) */
 173:ff.c          **** #define XDIR_ModTime10		21		/* exFAT: Modified time subsecond (BYTE) */
 174:ff.c          **** #define XDIR_CrtTZ			22		/* exFAT: Created timezone (BYTE) */
 175:ff.c          **** #define XDIR_ModTZ			23		/* exFAT: Modified timezone (BYTE) */
 176:ff.c          **** #define XDIR_AccTZ			24		/* exFAT: Last accessed timezone (BYTE) */
 177:ff.c          **** #define XDIR_GenFlags		33		/* exFAT: General secondary flags (BYTE) */
 178:ff.c          **** #define XDIR_NumName		35		/* exFAT: Number of file name characters (BYTE) */
 179:ff.c          **** #define XDIR_NameHash		36		/* exFAT: Hash of file name (WORD) */
 180:ff.c          **** #define XDIR_ValidFileSize	40		/* exFAT: Valid file size (QWORD) */
 181:ff.c          **** #define XDIR_FstClus		52		/* exFAT: First cluster of the file data (DWORD) */
 182:ff.c          **** #define XDIR_FileSize		56		/* exFAT: File/Directory size (QWORD) */
 183:ff.c          **** 
 184:ff.c          **** #define SZDIRE				32		/* Size of a directory entry */
 185:ff.c          **** #define DDEM				0xE5	/* Deleted directory entry mark set to DIR_Name[0] */
 186:ff.c          **** #define RDDEM				0x05	/* Replacement of the character collides with DDEM */
 187:ff.c          **** #define LLEF				0x40	/* Last long entry flag in LDIR_Ord */
 188:ff.c          **** 
 189:ff.c          **** #define FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
 190:ff.c          **** #define FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
 191:ff.c          **** #define FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
 192:ff.c          **** #define FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
 193:ff.c          **** 
 194:ff.c          **** #define MBR_Table			446		/* MBR: Offset of partition table in the MBR */
 195:ff.c          **** #define SZ_PTE				16		/* MBR: Size of a partition table entry */
 196:ff.c          **** #define PTE_Boot			0		/* MBR PTE: Boot indicator */
 197:ff.c          **** #define PTE_StHead			1		/* MBR PTE: Start head */
 198:ff.c          **** #define PTE_StSec			2		/* MBR PTE: Start sector */
 199:ff.c          **** #define PTE_StCyl			3		/* MBR PTE: Start cylinder */
 200:ff.c          **** #define PTE_System			4		/* MBR PTE: System ID */
 201:ff.c          **** #define PTE_EdHead			5		/* MBR PTE: End head */
 202:ff.c          **** #define PTE_EdSec			6		/* MBR PTE: End sector */
 203:ff.c          **** #define PTE_EdCyl			7		/* MBR PTE: End cylinder */
 204:ff.c          **** #define PTE_StLba			8		/* MBR PTE: Start in LBA */
 205:ff.c          **** #define PTE_SizLba			12		/* MBR PTE: Size in LBA */
 206:ff.c          **** 
 207:ff.c          **** #define GPTH_Sign			0		/* GPT: Header signature (8-byte) */
 208:ff.c          **** #define GPTH_Rev			8		/* GPT: Revision (DWORD) */
 209:ff.c          **** #define GPTH_Size			12		/* GPT: Header size (DWORD) */
 210:ff.c          **** #define GPTH_Bcc			16		/* GPT: Header BCC (DWORD) */
 211:ff.c          **** #define GPTH_CurLba			24		/* GPT: Main header LBA (QWORD) */
 212:ff.c          **** #define GPTH_BakLba			32		/* GPT: Backup header LBA (QWORD) */
 213:ff.c          **** #define GPTH_FstLba			40		/* GPT: First LBA for partitions (QWORD) */
 214:ff.c          **** #define GPTH_LstLba			48		/* GPT: Last LBA for partitions (QWORD) */
 215:ff.c          **** #define GPTH_DskGuid		56		/* GPT: Disk GUID (16-byte) */
 216:ff.c          **** #define GPTH_PtOfs			72		/* GPT: Partation table LBA (QWORD) */
 217:ff.c          **** #define GPTH_PtNum			80		/* GPT: Number of table entries (DWORD) */
 218:ff.c          **** #define GPTH_PteSize		84		/* GPT: Size of table entry (DWORD) */
 219:ff.c          **** #define GPTH_PtBcc			88		/* GPT: Partation table BCC (DWORD) */
 220:ff.c          **** #define SZ_GPTE				128		/* GPT: Size of partition table entry */
 221:ff.c          **** #define GPTE_PtGuid			0		/* GPT PTE: Partition type GUID (16-byte) */
 222:ff.c          **** #define GPTE_UpGuid			16		/* GPT PTE: Partition unique GUID (16-byte) */
 223:ff.c          **** #define GPTE_FstLba			32		/* GPT PTE: First LBA (QWORD) */
 224:ff.c          **** #define GPTE_LstLba			40		/* GPT PTE: Last LBA inclusive (QWORD) */
 225:ff.c          **** #define GPTE_Flags			48		/* GPT PTE: Flags (QWORD) */
 226:ff.c          **** #define GPTE_Name			56		/* GPT PTE: Name */
 227:ff.c          **** 
 228:ff.c          **** 
 229:ff.c          **** /* Post process on fatal error in the file operations */
 230:ff.c          **** #define ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
 231:ff.c          **** 
 232:ff.c          **** 
 233:ff.c          **** /* Re-entrancy related */
 234:ff.c          **** #if FF_FS_REENTRANT
 235:ff.c          **** #if FF_USE_LFN == 1
 236:ff.c          **** #error Static LFN work area cannot be used at thread-safe configuration
 237:ff.c          **** #endif
 238:ff.c          **** #define LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
 239:ff.c          **** #else
 240:ff.c          **** #define LEAVE_FF(fs, res)	return res
 241:ff.c          **** #endif
 242:ff.c          **** 
 243:ff.c          **** 
 244:ff.c          **** /* Definitions of logical drive - physical location conversion */
 245:ff.c          **** #if FF_MULTI_PARTITION
 246:ff.c          **** #define LD2PD(vol) VolToPart[vol].pd	/* Get physical drive number */
 247:ff.c          **** #define LD2PT(vol) VolToPart[vol].pt	/* Get partition index */
 248:ff.c          **** #else
 249:ff.c          **** #define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is associated with the same physical drive num
 250:ff.c          **** #define LD2PT(vol) 0			/* Find first valid partition or in SFD */
 251:ff.c          **** #endif
 252:ff.c          **** 
 253:ff.c          **** 
 254:ff.c          **** /* Definitions of sector size */
 255:ff.c          **** #if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MA
 256:ff.c          **** #error Wrong sector size configuration
 257:ff.c          **** #endif
 258:ff.c          **** #if FF_MAX_SS == FF_MIN_SS
 259:ff.c          **** #define SS(fs)	((UINT)FF_MAX_SS)	/* Fixed sector size */
 260:ff.c          **** #else
 261:ff.c          **** #define SS(fs)	((fs)->ssize)	/* Variable sector size */
 262:ff.c          **** #endif
 263:ff.c          **** 
 264:ff.c          **** 
 265:ff.c          **** /* Timestamp */
 266:ff.c          **** #if FF_FS_NORTC == 1
 267:ff.c          **** #if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NOR
 268:ff.c          **** #error Invalid FF_FS_NORTC settings
 269:ff.c          **** #endif
 270:ff.c          **** #define GET_FATTIME()	((DWORD)(FF_NORTC_YEAR - 1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_
 271:ff.c          **** #else
 272:ff.c          **** #define GET_FATTIME()	get_fattime()
 273:ff.c          **** #endif
 274:ff.c          **** 
 275:ff.c          **** 
 276:ff.c          **** /* File lock controls */
 277:ff.c          **** #if FF_FS_LOCK != 0
 278:ff.c          **** #if FF_FS_READONLY
 279:ff.c          **** #error FF_FS_LOCK must be 0 at read-only configuration
 280:ff.c          **** #endif
 281:ff.c          **** typedef struct {
 282:ff.c          **** 	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
 283:ff.c          **** 	DWORD clu;		/* Object ID 2, containing directory (0:root) */
 284:ff.c          **** 	DWORD ofs;		/* Object ID 3, offset in the directory */
 285:ff.c          **** 	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
 286:ff.c          **** } FILESEM;
 287:ff.c          **** #endif
 288:ff.c          **** 
 289:ff.c          **** 
 290:ff.c          **** /* SBCS up-case tables (\x80-\xFF) */
 291:ff.c          **** #define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F
 292:ff.c          **** 					0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 293:ff.c          **** 					0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 294:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 295:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 296:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 297:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 298:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 299:ff.c          **** #define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 300:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 301:ff.c          **** 					0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 302:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 303:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 304:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 305:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 306:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 307:ff.c          **** #define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 308:ff.c          **** 					0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
 309:ff.c          **** 					0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
 310:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 311:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 312:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 313:ff.c          **** 					0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 314:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 315:ff.c          **** #define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 316:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 317:ff.c          **** 					0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
 318:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 319:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 320:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
 321:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 322:ff.c          **** 					0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
 323:ff.c          **** #define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F
 324:ff.c          **** 					0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
 325:ff.c          **** 					0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 326:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 327:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 328:ff.c          **** 					0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 329:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
 330:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 331:ff.c          **** #define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41
 332:ff.c          **** 					0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
 333:ff.c          **** 					0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 334:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 335:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 336:ff.c          **** 					0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
 337:ff.c          **** 					0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
 338:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 339:ff.c          **** #define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F
 340:ff.c          **** 					0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
 341:ff.c          **** 					0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
 342:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
 343:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 344:ff.c          **** 					0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 345:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
 346:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
 347:ff.c          **** #define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F
 348:ff.c          **** 					0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
 349:ff.c          **** 					0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
 350:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
 351:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 352:ff.c          **** 					0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
 353:ff.c          **** 					0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
 354:ff.c          **** 					0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
 355:ff.c          **** #define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F
 356:ff.c          **** 					0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
 357:ff.c          **** 					0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 358:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 359:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 360:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 361:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
 362:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 363:ff.c          **** #define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F
 364:ff.c          **** 					0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 365:ff.c          **** 					0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 366:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 367:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 368:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 369:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 370:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 371:ff.c          **** #define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F
 372:ff.c          **** 					0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
 373:ff.c          **** 					0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 374:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 375:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 376:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 377:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 378:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 379:ff.c          **** #define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 380:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 381:ff.c          **** 					0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 382:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 383:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 384:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 385:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 386:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 387:ff.c          **** #define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F
 388:ff.c          **** 					0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
 389:ff.c          **** 					0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 390:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 391:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 392:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 393:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 394:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 395:ff.c          **** #define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F
 396:ff.c          **** 					0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 397:ff.c          **** 					0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 398:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 399:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 400:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 401:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 402:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 403:ff.c          **** #define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F
 404:ff.c          **** 					0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 405:ff.c          **** 					0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 406:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 407:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 408:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 409:ff.c          **** 					0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
 410:ff.c          **** 					0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 411:ff.c          **** #define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 412:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 413:ff.c          **** 					0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
 414:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 415:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 416:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
 417:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
 418:ff.c          **** 					0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
 419:ff.c          **** #define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F
 420:ff.c          **** 					0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
 421:ff.c          **** 					0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
 422:ff.c          **** 					0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
 423:ff.c          **** 					0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
 424:ff.c          **** 					0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
 425:ff.c          **** 					0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
 426:ff.c          **** 					0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
 427:ff.c          **** 
 428:ff.c          **** 
 429:ff.c          **** /* DBCS code range |----- 1st byte -----|  |----------- 2nd byte -----------| */
 430:ff.c          **** /*                  <------>    <------>    <------>    <------>    <------>  */
 431:ff.c          **** #define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 0x7E, 0x80, 0xFC, 0x00, 0x00}
 432:ff.c          **** #define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00}
 433:ff.c          **** #define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 0x5A, 0x61, 0x7A, 0x81, 0xFE}
 434:ff.c          **** #define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0xA1, 0xFE, 0x00, 0x00}
 435:ff.c          **** 
 436:ff.c          **** 
 437:ff.c          **** /* Macros for table definitions */
 438:ff.c          **** #define MERGE_2STR(a, b) a ## b
 439:ff.c          **** #define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)
 440:ff.c          **** 
 441:ff.c          **** 
 442:ff.c          **** 
 443:ff.c          **** 
 444:ff.c          **** /*--------------------------------------------------------------------------
 445:ff.c          **** 
 446:ff.c          ****    Module Private Work Area
 447:ff.c          **** 
 448:ff.c          **** ---------------------------------------------------------------------------*/
 449:ff.c          **** /* Remark: Variables defined here without initial value shall be guaranteed
 450:ff.c          **** /  zero/null at start-up. If not, the linker option or start-up routine is
 451:ff.c          **** /  not compliance with C standard. */
 452:ff.c          **** 
 453:ff.c          **** /*--------------------------------*/
 454:ff.c          **** /* File/Volume controls           */
 455:ff.c          **** /*--------------------------------*/
 456:ff.c          **** 
 457:ff.c          **** #if FF_VOLUMES < 1 || FF_VOLUMES > 10
 458:ff.c          **** #error Wrong FF_VOLUMES setting
 459:ff.c          **** #endif
 460:ff.c          **** static FATFS* FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
 461:ff.c          **** static WORD Fsid;					/* Filesystem mount ID */
 462:ff.c          **** 
 463:ff.c          **** #if FF_FS_RPATH != 0
 464:ff.c          **** static BYTE CurrVol;				/* Current drive */
 465:ff.c          **** #endif
 466:ff.c          **** 
 467:ff.c          **** #if FF_FS_LOCK != 0
 468:ff.c          **** static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
 469:ff.c          **** #endif
 470:ff.c          **** 
 471:ff.c          **** #if FF_STR_VOLUME_ID
 472:ff.c          **** #ifdef FF_VOLUME_STRS
 473:ff.c          **** static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};	/* Pre-defined volume ID */
 474:ff.c          **** #endif
 475:ff.c          **** #endif
 476:ff.c          **** 
 477:ff.c          **** #if FF_LBA64
 478:ff.c          **** #if FF_MIN_GPT > 0x100000000
 479:ff.c          **** #error Wrong FF_MIN_GPT setting
 480:ff.c          **** #endif
 481:ff.c          **** static const BYTE GUID_MS_Basic[16] = {0xA2,0xA0,0xD0,0xEB,0xE5,0xB9,0x33,0x44,0x87,0xC0,0x68,0xB6,
 482:ff.c          **** #endif
 483:ff.c          **** 
 484:ff.c          **** 
 485:ff.c          **** 
 486:ff.c          **** /*--------------------------------*/
 487:ff.c          **** /* LFN/Directory working buffer   */
 488:ff.c          **** /*--------------------------------*/
 489:ff.c          **** 
 490:ff.c          **** #if FF_USE_LFN == 0		/* Non-LFN configuration */
 491:ff.c          **** #if FF_FS_EXFAT
 492:ff.c          **** #error LFN must be enabled when enable exFAT
 493:ff.c          **** #endif
 494:ff.c          **** #define DEF_NAMBUF
 495:ff.c          **** #define INIT_NAMBUF(fs)
 496:ff.c          **** #define FREE_NAMBUF()
 497:ff.c          **** #define LEAVE_MKFS(res)	return res
 498:ff.c          **** 
 499:ff.c          **** #else					/* LFN configurations */
 500:ff.c          **** #if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
 501:ff.c          **** #error Wrong setting of FF_MAX_LFN
 502:ff.c          **** #endif
 503:ff.c          **** #if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
 504:ff.c          **** #error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
 505:ff.c          **** #endif
 506:ff.c          **** #if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
 507:ff.c          **** #error Wrong setting of FF_LFN_UNICODE
 508:ff.c          **** #endif
 509:ff.c          **** static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* FAT: Offset of LFN characters 
 510:ff.c          **** #define MAXDIRB(nc)	((nc + 44U) / 15 * SZDIRE)	/* exFAT: Size of directory entry block scratchpad b
 511:ff.c          **** 
 512:ff.c          **** #if FF_USE_LFN == 1		/* LFN enabled with static working buffer */
 513:ff.c          **** #if FF_FS_EXFAT
 514:ff.c          **** static BYTE	DirBuf[MAXDIRB(FF_MAX_LFN)];	/* Directory entry block scratchpad buffer */
 515:ff.c          **** #endif
 516:ff.c          **** static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
 517:ff.c          **** #define DEF_NAMBUF
 518:ff.c          **** #define INIT_NAMBUF(fs)
 519:ff.c          **** #define FREE_NAMBUF()
 520:ff.c          **** #define LEAVE_MKFS(res)	return res
 521:ff.c          **** 
 522:ff.c          **** #elif FF_USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
 523:ff.c          **** #if FF_FS_EXFAT
 524:ff.c          **** #define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];	/* LFN working buffer
 525:ff.c          **** #define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }
 526:ff.c          **** #define FREE_NAMBUF()
 527:ff.c          **** #else
 528:ff.c          **** #define DEF_NAMBUF		WCHAR lbuf[FF_MAX_LFN+1];	/* LFN working buffer */
 529:ff.c          **** #define INIT_NAMBUF(fs)	{ (fs)->lfnbuf = lbuf; }
 530:ff.c          **** #define FREE_NAMBUF()
 531:ff.c          **** #endif
 532:ff.c          **** #define LEAVE_MKFS(res)	return res
 533:ff.c          **** 
 534:ff.c          **** #elif FF_USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
 535:ff.c          **** #if FF_FS_EXFAT
 536:ff.c          **** #define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer and directory entry block scratchp
 537:ff.c          **** #define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAV
 538:ff.c          **** #define FREE_NAMBUF()	ff_memfree(lfn)
 539:ff.c          **** #else
 540:ff.c          **** #define DEF_NAMBUF		WCHAR *lfn;	/* Pointer to LFN working buffer */
 541:ff.c          **** #define INIT_NAMBUF(fs)	{ lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH
 542:ff.c          **** #define FREE_NAMBUF()	ff_memfree(lfn)
 543:ff.c          **** #endif
 544:ff.c          **** #define LEAVE_MKFS(res)	{ if (!work) ff_memfree(buf); return res; }
 545:ff.c          **** #define MAX_MALLOC	0x8000	/* Must be >=FF_MAX_SS */
 546:ff.c          **** 
 547:ff.c          **** #else
 548:ff.c          **** #error Wrong setting of FF_USE_LFN
 549:ff.c          **** 
 550:ff.c          **** #endif	/* FF_USE_LFN == 1 */
 551:ff.c          **** #endif	/* FF_USE_LFN == 0 */
 552:ff.c          **** 
 553:ff.c          **** 
 554:ff.c          **** 
 555:ff.c          **** /*--------------------------------*/
 556:ff.c          **** /* Code conversion tables         */
 557:ff.c          **** /*--------------------------------*/
 558:ff.c          **** 
 559:ff.c          **** #if FF_CODE_PAGE == 0		/* Run-time code page configuration */
 560:ff.c          **** #define CODEPAGE CodePage
 561:ff.c          **** static WORD CodePage;	/* Current code page */
 562:ff.c          **** static const BYTE *ExCvt, *DbcTbl;	/* Pointer to current SBCS up-case table and DBCS code range tab
 563:ff.c          **** 
 564:ff.c          **** static const BYTE Ct437[] = TBL_CT437;
 565:ff.c          **** static const BYTE Ct720[] = TBL_CT720;
 566:ff.c          **** static const BYTE Ct737[] = TBL_CT737;
 567:ff.c          **** static const BYTE Ct771[] = TBL_CT771;
 568:ff.c          **** static const BYTE Ct775[] = TBL_CT775;
 569:ff.c          **** static const BYTE Ct850[] = TBL_CT850;
 570:ff.c          **** static const BYTE Ct852[] = TBL_CT852;
 571:ff.c          **** static const BYTE Ct855[] = TBL_CT855;
 572:ff.c          **** static const BYTE Ct857[] = TBL_CT857;
 573:ff.c          **** static const BYTE Ct860[] = TBL_CT860;
 574:ff.c          **** static const BYTE Ct861[] = TBL_CT861;
 575:ff.c          **** static const BYTE Ct862[] = TBL_CT862;
 576:ff.c          **** static const BYTE Ct863[] = TBL_CT863;
 577:ff.c          **** static const BYTE Ct864[] = TBL_CT864;
 578:ff.c          **** static const BYTE Ct865[] = TBL_CT865;
 579:ff.c          **** static const BYTE Ct866[] = TBL_CT866;
 580:ff.c          **** static const BYTE Ct869[] = TBL_CT869;
 581:ff.c          **** static const BYTE Dc932[] = TBL_DC932;
 582:ff.c          **** static const BYTE Dc936[] = TBL_DC936;
 583:ff.c          **** static const BYTE Dc949[] = TBL_DC949;
 584:ff.c          **** static const BYTE Dc950[] = TBL_DC950;
 585:ff.c          **** 
 586:ff.c          **** #elif FF_CODE_PAGE < 900	/* Static code page configuration (SBCS) */
 587:ff.c          **** #define CODEPAGE FF_CODE_PAGE
 588:ff.c          **** static const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CODE_PAGE);
 589:ff.c          **** 
 590:ff.c          **** #else					/* Static code page configuration (DBCS) */
 591:ff.c          **** #define CODEPAGE FF_CODE_PAGE
 592:ff.c          **** static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);
 593:ff.c          **** 
 594:ff.c          **** #endif
 595:ff.c          **** 
 596:ff.c          **** 
 597:ff.c          **** 
 598:ff.c          **** 
 599:ff.c          **** /*--------------------------------------------------------------------------
 600:ff.c          **** 
 601:ff.c          ****    Module Private Functions
 602:ff.c          **** 
 603:ff.c          **** ---------------------------------------------------------------------------*/
 604:ff.c          **** 
 605:ff.c          **** 
 606:ff.c          **** /*-----------------------------------------------------------------------*/
 607:ff.c          **** /* Load/Store multi-byte word in the FAT structure                       */
 608:ff.c          **** /*-----------------------------------------------------------------------*/
 609:ff.c          **** 
 610:ff.c          **** static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
 611:ff.c          **** {
 612:ff.c          **** 	WORD rv;
 613:ff.c          **** 
 614:ff.c          **** 	rv = ptr[1];
 615:ff.c          **** 	rv = rv << 8 | ptr[0];
 616:ff.c          **** 	return rv;
 617:ff.c          **** }
 618:ff.c          **** 
 619:ff.c          **** static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
 620:ff.c          **** {
  14               		.loc 1 620 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21 0000 FC01      		movw r30,r24
  22               	.LVL1:
 621:ff.c          **** 	DWORD rv;
 622:ff.c          **** 
 623:ff.c          **** 	rv = ptr[3];
 624:ff.c          **** 	rv = rv << 8 | ptr[2];
 625:ff.c          **** 	rv = rv << 8 | ptr[1];
  23               		.loc 1 625 0
  24 0002 6281      		ldd r22,Z+2
  25 0004 7381      		ldd r23,Z+3
  26 0006 CB01      		movw r24,r22
  27               	.LVL2:
  28 0008 A0E0      		ldi r26,0
  29 000a B0E0      		ldi r27,0
  30 000c BA2F      		mov r27,r26
  31 000e A92F      		mov r26,r25
  32 0010 982F      		mov r25,r24
  33 0012 8827      		clr r24
  34               	.LVL3:
 626:ff.c          **** 	rv = rv << 8 | ptr[0];
  35               		.loc 1 626 0
  36 0014 2181      		ldd r18,Z+1
  37 0016 822B      		or r24,r18
  38               	.LVL4:
  39 0018 BA2F      		mov r27,r26
  40 001a A92F      		mov r26,r25
  41 001c 982F      		mov r25,r24
  42 001e 8827      		clr r24
  43               	.LVL5:
 627:ff.c          **** 	return rv;
  44               		.loc 1 627 0
  45 0020 2081      		ld r18,Z
  46 0022 BC01      		movw r22,r24
  47 0024 CD01      		movw r24,r26
  48 0026 622B      		or r22,r18
 628:ff.c          **** }
  49               		.loc 1 628 0
  50 0028 0895      		ret
  51               		.cfi_endproc
  52               	.LFE1:
  55               	clst2sect:
  56               	.LFB13:
 629:ff.c          **** 
 630:ff.c          **** #if FF_FS_EXFAT
 631:ff.c          **** static QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
 632:ff.c          **** {
 633:ff.c          **** 	QWORD rv;
 634:ff.c          **** 
 635:ff.c          **** 	rv = ptr[7];
 636:ff.c          **** 	rv = rv << 8 | ptr[6];
 637:ff.c          **** 	rv = rv << 8 | ptr[5];
 638:ff.c          **** 	rv = rv << 8 | ptr[4];
 639:ff.c          **** 	rv = rv << 8 | ptr[3];
 640:ff.c          **** 	rv = rv << 8 | ptr[2];
 641:ff.c          **** 	rv = rv << 8 | ptr[1];
 642:ff.c          **** 	rv = rv << 8 | ptr[0];
 643:ff.c          **** 	return rv;
 644:ff.c          **** }
 645:ff.c          **** #endif
 646:ff.c          **** 
 647:ff.c          **** #if !FF_FS_READONLY
 648:ff.c          **** static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
 649:ff.c          **** {
 650:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 651:ff.c          **** 	*ptr++ = (BYTE)val;
 652:ff.c          **** }
 653:ff.c          **** 
 654:ff.c          **** static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
 655:ff.c          **** {
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 658:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 659:ff.c          **** 	*ptr++ = (BYTE)val;
 660:ff.c          **** }
 661:ff.c          **** 
 662:ff.c          **** #if FF_FS_EXFAT
 663:ff.c          **** static void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
 664:ff.c          **** {
 665:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 666:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 667:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 668:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 669:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 670:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 671:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 672:ff.c          **** 	*ptr++ = (BYTE)val;
 673:ff.c          **** }
 674:ff.c          **** #endif
 675:ff.c          **** #endif	/* !FF_FS_READONLY */
 676:ff.c          **** 
 677:ff.c          **** 
 678:ff.c          **** 
 679:ff.c          **** /*-----------------------------------------------------------------------*/
 680:ff.c          **** /* String functions                                                      */
 681:ff.c          **** /*-----------------------------------------------------------------------*/
 682:ff.c          **** 
 683:ff.c          **** /* Copy memory to memory */
 684:ff.c          **** static void mem_cpy (void* dst, const void* src, UINT cnt)
 685:ff.c          **** {
 686:ff.c          **** 	BYTE *d = (BYTE*)dst;
 687:ff.c          **** 	const BYTE *s = (const BYTE*)src;
 688:ff.c          **** 
 689:ff.c          **** 	if (cnt != 0) {
 690:ff.c          **** 		do {
 691:ff.c          **** 			*d++ = *s++;
 692:ff.c          **** 		} while (--cnt);
 693:ff.c          **** 	}
 694:ff.c          **** }
 695:ff.c          **** 
 696:ff.c          **** 
 697:ff.c          **** /* Fill memory block */
 698:ff.c          **** static void mem_set (void* dst, int val, UINT cnt)
 699:ff.c          **** {
 700:ff.c          **** 	BYTE *d = (BYTE*)dst;
 701:ff.c          **** 
 702:ff.c          **** 	do {
 703:ff.c          **** 		*d++ = (BYTE)val;
 704:ff.c          **** 	} while (--cnt);
 705:ff.c          **** }
 706:ff.c          **** 
 707:ff.c          **** 
 708:ff.c          **** /* Compare memory block */
 709:ff.c          **** static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
 710:ff.c          **** {
 711:ff.c          **** 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 712:ff.c          **** 	int r = 0;
 713:ff.c          **** 
 714:ff.c          **** 	do {
 715:ff.c          **** 		r = *d++ - *s++;
 716:ff.c          **** 	} while (--cnt && r == 0);
 717:ff.c          **** 
 718:ff.c          **** 	return r;
 719:ff.c          **** }
 720:ff.c          **** 
 721:ff.c          **** 
 722:ff.c          **** /* Check if chr is contained in the string */
 723:ff.c          **** static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
 724:ff.c          **** {
 725:ff.c          **** 	while (*str && *str != chr) str++;
 726:ff.c          **** 	return *str;
 727:ff.c          **** }
 728:ff.c          **** 
 729:ff.c          **** 
 730:ff.c          **** /* Test if the byte is DBC 1st byte */
 731:ff.c          **** static int dbc_1st (BYTE c)
 732:ff.c          **** {
 733:ff.c          **** #if FF_CODE_PAGE == 0		/* Variable code page */
 734:ff.c          **** 	if (DbcTbl && c >= DbcTbl[0]) {
 735:ff.c          **** 		if (c <= DbcTbl[1]) return 1;					/* 1st byte range 1 */
 736:ff.c          **** 		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;	/* 1st byte range 2 */
 737:ff.c          **** 	}
 738:ff.c          **** #elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
 739:ff.c          **** 	if (c >= DbcTbl[0]) {
 740:ff.c          **** 		if (c <= DbcTbl[1]) return 1;
 741:ff.c          **** 		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
 742:ff.c          **** 	}
 743:ff.c          **** #else						/* SBCS fixed code page */
 744:ff.c          **** 	if (c != 0) return 0;	/* Always false */
 745:ff.c          **** #endif
 746:ff.c          **** 	return 0;
 747:ff.c          **** }
 748:ff.c          **** 
 749:ff.c          **** 
 750:ff.c          **** /* Test if the byte is DBC 2nd byte */
 751:ff.c          **** static int dbc_2nd (BYTE c)
 752:ff.c          **** {
 753:ff.c          **** #if FF_CODE_PAGE == 0		/* Variable code page */
 754:ff.c          **** 	if (DbcTbl && c >= DbcTbl[4]) {
 755:ff.c          **** 		if (c <= DbcTbl[5]) return 1;					/* 2nd byte range 1 */
 756:ff.c          **** 		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;	/* 2nd byte range 2 */
 757:ff.c          **** 		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;	/* 2nd byte range 3 */
 758:ff.c          **** 	}
 759:ff.c          **** #elif FF_CODE_PAGE >= 900	/* DBCS fixed code page */
 760:ff.c          **** 	if (c >= DbcTbl[4]) {
 761:ff.c          **** 		if (c <= DbcTbl[5]) return 1;
 762:ff.c          **** 		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
 763:ff.c          **** 		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
 764:ff.c          **** 	}
 765:ff.c          **** #else						/* SBCS fixed code page */
 766:ff.c          **** 	if (c != 0) return 0;	/* Always false */
 767:ff.c          **** #endif
 768:ff.c          **** 	return 0;
 769:ff.c          **** }
 770:ff.c          **** 
 771:ff.c          **** 
 772:ff.c          **** #if FF_USE_LFN
 773:ff.c          **** 
 774:ff.c          **** /* Get a Unicode code point from the TCHAR string in defined API encodeing */
 775:ff.c          **** static DWORD tchar2uni (	/* Returns a character in UTF-16 encoding (>=0x10000 on surrogate pair, 0x
 776:ff.c          **** 	const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
 777:ff.c          **** )
 778:ff.c          **** {
 779:ff.c          **** 	DWORD uc;
 780:ff.c          **** 	const TCHAR *p = *str;
 781:ff.c          **** 
 782:ff.c          **** #if FF_LFN_UNICODE == 1		/* UTF-16 input */
 783:ff.c          **** 	WCHAR wc;
 784:ff.c          **** 
 785:ff.c          **** 	uc = *p++;	/* Get a unit */
 786:ff.c          **** 	if (IsSurrogate(uc)) {	/* Surrogate? */
 787:ff.c          **** 		wc = *p++;		/* Get low surrogate */
 788:ff.c          **** 		if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;	/* Wrong surrogate? */
 789:ff.c          **** 		uc = uc << 16 | wc;
 790:ff.c          **** 	}
 791:ff.c          **** 
 792:ff.c          **** #elif FF_LFN_UNICODE == 2	/* UTF-8 input */
 793:ff.c          **** 	BYTE b;
 794:ff.c          **** 	int nf;
 795:ff.c          **** 
 796:ff.c          **** 	uc = (BYTE)*p++;	/* Get an encoding unit */
 797:ff.c          **** 	if (uc & 0x80) {	/* Multiple byte code? */
 798:ff.c          **** 		if ((uc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
 799:ff.c          **** 			uc &= 0x1F; nf = 1;
 800:ff.c          **** 		} else {
 801:ff.c          **** 			if ((uc & 0xF0) == 0xE0) {	/* 3-byte sequence? */
 802:ff.c          **** 				uc &= 0x0F; nf = 2;
 803:ff.c          **** 			} else {
 804:ff.c          **** 				if ((uc & 0xF8) == 0xF0) {	/* 4-byte sequence? */
 805:ff.c          **** 					uc &= 0x07; nf = 3;
 806:ff.c          **** 				} else {					/* Wrong sequence */
 807:ff.c          **** 					return 0xFFFFFFFF;
 808:ff.c          **** 				}
 809:ff.c          **** 			}
 810:ff.c          **** 		}
 811:ff.c          **** 		do {	/* Get trailing bytes */
 812:ff.c          **** 			b = (BYTE)*p++;
 813:ff.c          **** 			if ((b & 0xC0) != 0x80) return 0xFFFFFFFF;	/* Wrong sequence? */
 814:ff.c          **** 			uc = uc << 6 | (b & 0x3F);
 815:ff.c          **** 		} while (--nf != 0);
 816:ff.c          **** 		if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
 817:ff.c          **** 		if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a
 818:ff.c          **** 	}
 819:ff.c          **** 
 820:ff.c          **** #elif FF_LFN_UNICODE == 3	/* UTF-32 input */
 821:ff.c          **** 	uc = (TCHAR)*p++;	/* Get a unit */
 822:ff.c          **** 	if (uc >= 0x110000 || IsSurrogate(uc)) return 0xFFFFFFFF;	/* Wrong code? */
 823:ff.c          **** 	if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a 
 824:ff.c          **** 
 825:ff.c          **** #else		/* ANSI/OEM input */
 826:ff.c          **** 	BYTE b;
 827:ff.c          **** 	WCHAR wc;
 828:ff.c          **** 
 829:ff.c          **** 	wc = (BYTE)*p++;			/* Get a byte */
 830:ff.c          **** 	if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1st byte? */
 831:ff.c          **** 		b = (BYTE)*p++;			/* Get 2nd byte */
 832:ff.c          **** 		if (!dbc_2nd(b)) return 0xFFFFFFFF;	/* Invalid code? */
 833:ff.c          **** 		wc = (wc << 8) + b;		/* Make a DBC */
 834:ff.c          **** 	}
 835:ff.c          **** 	if (wc != 0) {
 836:ff.c          **** 		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
 837:ff.c          **** 		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 838:ff.c          **** 	}
 839:ff.c          **** 	uc = wc;
 840:ff.c          **** 
 841:ff.c          **** #endif
 842:ff.c          **** 	*str = p;	/* Next read pointer */
 843:ff.c          **** 	return uc;
 844:ff.c          **** }
 845:ff.c          **** 
 846:ff.c          **** 
 847:ff.c          **** /* Output a TCHAR string in defined API encoding */
 848:ff.c          **** static BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encod
 849:ff.c          **** 	DWORD chr,	/* UTF-16 encoded character (Surrogate pair if >=0x10000) */
 850:ff.c          **** 	TCHAR* buf,	/* Output buffer */
 851:ff.c          **** 	UINT szb	/* Size of the buffer */
 852:ff.c          **** )
 853:ff.c          **** {
 854:ff.c          **** #if FF_LFN_UNICODE == 1	/* UTF-16 output */
 855:ff.c          **** 	WCHAR hs, wc;
 856:ff.c          **** 
 857:ff.c          **** 	hs = (WCHAR)(chr >> 16);
 858:ff.c          **** 	wc = (WCHAR)chr;
 859:ff.c          **** 	if (hs == 0) {	/* Single encoding unit? */
 860:ff.c          **** 		if (szb < 1 || IsSurrogate(wc)) return 0;	/* Buffer overflow or wrong code? */
 861:ff.c          **** 		*buf = wc;
 862:ff.c          **** 		return 1;
 863:ff.c          **** 	}
 864:ff.c          **** 	if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogateL(wc)) return 0;	/* Buffer overflow or wrong surro
 865:ff.c          **** 	*buf++ = hs;
 866:ff.c          **** 	*buf++ = wc;
 867:ff.c          **** 	return 2;
 868:ff.c          **** 
 869:ff.c          **** #elif FF_LFN_UNICODE == 2	/* UTF-8 output */
 870:ff.c          **** 	DWORD hc;
 871:ff.c          **** 
 872:ff.c          **** 	if (chr < 0x80) {	/* Single byte code? */
 873:ff.c          **** 		if (szb < 1) return 0;	/* Buffer overflow? */
 874:ff.c          **** 		*buf = (TCHAR)chr;
 875:ff.c          **** 		return 1;
 876:ff.c          **** 	}
 877:ff.c          **** 	if (chr < 0x800) {	/* 2-byte sequence? */
 878:ff.c          **** 		if (szb < 2) return 0;	/* Buffer overflow? */
 879:ff.c          **** 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
 880:ff.c          **** 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
 881:ff.c          **** 		return 2;
 882:ff.c          **** 	}
 883:ff.c          **** 	if (chr < 0x10000) {	/* 3-byte sequence? */
 884:ff.c          **** 		if (szb < 3 || IsSurrogate(chr)) return 0;	/* Buffer overflow or wrong code? */
 885:ff.c          **** 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
 886:ff.c          **** 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
 887:ff.c          **** 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
 888:ff.c          **** 		return 3;
 889:ff.c          **** 	}
 890:ff.c          **** 	/* 4-byte sequence */
 891:ff.c          **** 	if (szb < 4) return 0;	/* Buffer overflow? */
 892:ff.c          **** 	hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
 893:ff.c          **** 	chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
 894:ff.c          **** 	if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
 895:ff.c          **** 	chr = (hc | chr) + 0x10000;
 896:ff.c          **** 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
 897:ff.c          **** 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
 898:ff.c          **** 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
 899:ff.c          **** 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
 900:ff.c          **** 	return 4;
 901:ff.c          **** 
 902:ff.c          **** #elif FF_LFN_UNICODE == 3	/* UTF-32 output */
 903:ff.c          **** 	DWORD hc;
 904:ff.c          **** 
 905:ff.c          **** 	if (szb < 1) return 0;	/* Buffer overflow? */
 906:ff.c          **** 	if (chr >= 0x10000) {	/* Out of BMP? */
 907:ff.c          **** 		hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
 908:ff.c          **** 		chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
 909:ff.c          **** 		if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
 910:ff.c          **** 		chr = (hc | chr) + 0x10000;
 911:ff.c          **** 	}
 912:ff.c          **** 	*buf++ = (TCHAR)chr;
 913:ff.c          **** 	return 1;
 914:ff.c          **** 
 915:ff.c          **** #else						/* ANSI/OEM output */
 916:ff.c          **** 	WCHAR wc;
 917:ff.c          **** 
 918:ff.c          **** 	wc = ff_uni2oem(chr, CODEPAGE);
 919:ff.c          **** 	if (wc >= 0x100) {	/* Is this a DBC? */
 920:ff.c          **** 		if (szb < 2) return 0;
 921:ff.c          **** 		*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
 922:ff.c          **** 		*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
 923:ff.c          **** 		return 2;
 924:ff.c          **** 	}
 925:ff.c          **** 	if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
 926:ff.c          **** 	*buf++ = (TCHAR)wc;					/* Store the character */
 927:ff.c          **** 	return 1;
 928:ff.c          **** #endif
 929:ff.c          **** }
 930:ff.c          **** #endif	/* FF_USE_LFN */
 931:ff.c          **** 
 932:ff.c          **** 
 933:ff.c          **** #if FF_FS_REENTRANT
 934:ff.c          **** /*-----------------------------------------------------------------------*/
 935:ff.c          **** /* Request/Release grant to access the volume                            */
 936:ff.c          **** /*-----------------------------------------------------------------------*/
 937:ff.c          **** static int lock_fs (		/* 1:Ok, 0:timeout */
 938:ff.c          **** 	FATFS* fs		/* Filesystem object */
 939:ff.c          **** )
 940:ff.c          **** {
 941:ff.c          **** 	return ff_req_grant(fs->sobj);
 942:ff.c          **** }
 943:ff.c          **** 
 944:ff.c          **** 
 945:ff.c          **** static void unlock_fs (
 946:ff.c          **** 	FATFS* fs,		/* Filesystem object */
 947:ff.c          **** 	FRESULT res		/* Result code to be returned */
 948:ff.c          **** )
 949:ff.c          **** {
 950:ff.c          **** 	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 951:ff.c          **** 		ff_rel_grant(fs->sobj);
 952:ff.c          **** 	}
 953:ff.c          **** }
 954:ff.c          **** 
 955:ff.c          **** #endif
 956:ff.c          **** 
 957:ff.c          **** 
 958:ff.c          **** 
 959:ff.c          **** #if FF_FS_LOCK != 0
 960:ff.c          **** /*-----------------------------------------------------------------------*/
 961:ff.c          **** /* File lock control functions                                           */
 962:ff.c          **** /*-----------------------------------------------------------------------*/
 963:ff.c          **** 
 964:ff.c          **** static FRESULT chk_lock (	/* Check if the file can be accessed */
 965:ff.c          **** 	DIR* dp,		/* Directory object pointing the file to be checked */
 966:ff.c          **** 	int acc			/* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
 967:ff.c          **** )
 968:ff.c          **** {
 969:ff.c          **** 	UINT i, be;
 970:ff.c          **** 
 971:ff.c          **** 	/* Search open object table for the object */
 972:ff.c          **** 	be = 0;
 973:ff.c          **** 	for (i = 0; i < FF_FS_LOCK; i++) {
 974:ff.c          **** 		if (Files[i].fs) {	/* Existing entry */
 975:ff.c          **** 			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matches with an open object */
 976:ff.c          **** 				Files[i].clu == dp->obj.sclust &&
 977:ff.c          **** 				Files[i].ofs == dp->dptr) break;
 978:ff.c          **** 		} else {			/* Blank entry */
 979:ff.c          **** 			be = 1;
 980:ff.c          **** 		}
 981:ff.c          **** 	}
 982:ff.c          **** 	if (i == FF_FS_LOCK) {	/* The object has not been opened */
 983:ff.c          **** 		return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;	/* Is there a blank entry for new obje
 984:ff.c          **** 	}
 985:ff.c          **** 
 986:ff.c          **** 	/* The object was opened. Reject any open against writing file and all write mode open */
 987:ff.c          **** 	return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 988:ff.c          **** }
 989:ff.c          **** 
 990:ff.c          **** 
 991:ff.c          **** static int enq_lock (void)	/* Check if an entry is available for a new object */
 992:ff.c          **** {
 993:ff.c          **** 	UINT i;
 994:ff.c          **** 
 995:ff.c          **** 	for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
 996:ff.c          **** 	return (i == FF_FS_LOCK) ? 0 : 1;
 997:ff.c          **** }
 998:ff.c          **** 
 999:ff.c          **** 
1000:ff.c          **** static UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
1001:ff.c          **** 	DIR* dp,	/* Directory object pointing the file to register or increment */
1002:ff.c          **** 	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
1003:ff.c          **** )
1004:ff.c          **** {
1005:ff.c          **** 	UINT i;
1006:ff.c          **** 
1007:ff.c          **** 
1008:ff.c          **** 	for (i = 0; i < FF_FS_LOCK; i++) {	/* Find the object */
1009:ff.c          **** 		if (Files[i].fs == dp->obj.fs
1010:ff.c          **** 		 && Files[i].clu == dp->obj.sclust
1011:ff.c          **** 		 && Files[i].ofs == dp->dptr) break;
1012:ff.c          **** 	}
1013:ff.c          **** 
1014:ff.c          **** 	if (i == FF_FS_LOCK) {				/* Not opened. Register it as new. */
1015:ff.c          **** 		for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;
1016:ff.c          **** 		if (i == FF_FS_LOCK) return 0;	/* No free entry to register (int err) */
1017:ff.c          **** 		Files[i].fs = dp->obj.fs;
1018:ff.c          **** 		Files[i].clu = dp->obj.sclust;
1019:ff.c          **** 		Files[i].ofs = dp->dptr;
1020:ff.c          **** 		Files[i].ctr = 0;
1021:ff.c          **** 	}
1022:ff.c          **** 
1023:ff.c          **** 	if (acc >= 1 && Files[i].ctr) return 0;	/* Access violation (int err) */
1024:ff.c          **** 
1025:ff.c          **** 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
1026:ff.c          **** 
1027:ff.c          **** 	return i + 1;	/* Index number origin from 1 */
1028:ff.c          **** }
1029:ff.c          **** 
1030:ff.c          **** 
1031:ff.c          **** static FRESULT dec_lock (	/* Decrement object open counter */
1032:ff.c          **** 	UINT i			/* Semaphore index (1..) */
1033:ff.c          **** )
1034:ff.c          **** {
1035:ff.c          **** 	WORD n;
1036:ff.c          **** 	FRESULT res;
1037:ff.c          **** 
1038:ff.c          **** 
1039:ff.c          **** 	if (--i < FF_FS_LOCK) {	/* Index number origin from 0 */
1040:ff.c          **** 		n = Files[i].ctr;
1041:ff.c          **** 		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
1042:ff.c          **** 		if (n > 0) n--;				/* Decrement read mode open count */
1043:ff.c          **** 		Files[i].ctr = n;
1044:ff.c          **** 		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
1045:ff.c          **** 		res = FR_OK;
1046:ff.c          **** 	} else {
1047:ff.c          **** 		res = FR_INT_ERR;			/* Invalid index nunber */
1048:ff.c          **** 	}
1049:ff.c          **** 	return res;
1050:ff.c          **** }
1051:ff.c          **** 
1052:ff.c          **** 
1053:ff.c          **** static void clear_lock (	/* Clear lock entries of the volume */
1054:ff.c          **** 	FATFS *fs
1055:ff.c          **** )
1056:ff.c          **** {
1057:ff.c          **** 	UINT i;
1058:ff.c          **** 
1059:ff.c          **** 	for (i = 0; i < FF_FS_LOCK; i++) {
1060:ff.c          **** 		if (Files[i].fs == fs) Files[i].fs = 0;
1061:ff.c          **** 	}
1062:ff.c          **** }
1063:ff.c          **** 
1064:ff.c          **** #endif	/* FF_FS_LOCK != 0 */
1065:ff.c          **** 
1066:ff.c          **** 
1067:ff.c          **** 
1068:ff.c          **** /*-----------------------------------------------------------------------*/
1069:ff.c          **** /* Move/Flush disk access window in the filesystem object                */
1070:ff.c          **** /*-----------------------------------------------------------------------*/
1071:ff.c          **** #if !FF_FS_READONLY
1072:ff.c          **** static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
1073:ff.c          **** 	FATFS* fs			/* Filesystem object */
1074:ff.c          **** )
1075:ff.c          **** {
1076:ff.c          **** 	FRESULT res = FR_OK;
1077:ff.c          **** 
1078:ff.c          **** 
1079:ff.c          **** 	if (fs->wflag) {	/* Is the disk access window dirty? */
1080:ff.c          **** 		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume *
1081:ff.c          **** 			fs->wflag = 0;	/* Clear window dirty flag */
1082:ff.c          **** 			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
1083:ff.c          **** 				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it t
1084:ff.c          **** 			}
1085:ff.c          **** 		} else {
1086:ff.c          **** 			res = FR_DISK_ERR;
1087:ff.c          **** 		}
1088:ff.c          **** 	}
1089:ff.c          **** 	return res;
1090:ff.c          **** }
1091:ff.c          **** #endif
1092:ff.c          **** 
1093:ff.c          **** 
1094:ff.c          **** static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
1095:ff.c          **** 	FATFS* fs,		/* Filesystem object */
1096:ff.c          **** 	LBA_t sect		/* Sector LBA to make appearance in the fs->win[] */
1097:ff.c          **** )
1098:ff.c          **** {
1099:ff.c          **** 	FRESULT res = FR_OK;
1100:ff.c          **** 
1101:ff.c          **** 
1102:ff.c          **** 	if (sect != fs->winsect) {	/* Window offset changed? */
1103:ff.c          **** #if !FF_FS_READONLY
1104:ff.c          **** 		res = sync_window(fs);		/* Flush the window */
1105:ff.c          **** #endif
1106:ff.c          **** 		if (res == FR_OK) {			/* Fill sector window with new data */
1107:ff.c          **** 			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
1108:ff.c          **** 				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
1109:ff.c          **** 				res = FR_DISK_ERR;
1110:ff.c          **** 			}
1111:ff.c          **** 			fs->winsect = sect;
1112:ff.c          **** 		}
1113:ff.c          **** 	}
1114:ff.c          **** 	return res;
1115:ff.c          **** }
1116:ff.c          **** 
1117:ff.c          **** 
1118:ff.c          **** 
1119:ff.c          **** 
1120:ff.c          **** #if !FF_FS_READONLY
1121:ff.c          **** /*-----------------------------------------------------------------------*/
1122:ff.c          **** /* Synchronize filesystem and data on the storage                        */
1123:ff.c          **** /*-----------------------------------------------------------------------*/
1124:ff.c          **** 
1125:ff.c          **** static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
1126:ff.c          **** 	FATFS* fs		/* Filesystem object */
1127:ff.c          **** )
1128:ff.c          **** {
1129:ff.c          **** 	FRESULT res;
1130:ff.c          **** 
1131:ff.c          **** 
1132:ff.c          **** 	res = sync_window(fs);
1133:ff.c          **** 	if (res == FR_OK) {
1134:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
1135:ff.c          **** 			/* Create FSInfo structure */
1136:ff.c          **** 			mem_set(fs->win, 0, sizeof fs->win);
1137:ff.c          **** 			st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
1138:ff.c          **** 			st_dword(fs->win + FSI_LeadSig, 0x41615252);		/* Leading signature */
1139:ff.c          **** 			st_dword(fs->win + FSI_StrucSig, 0x61417272);		/* Structure signature */
1140:ff.c          **** 			st_dword(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
1141:ff.c          **** 			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
1142:ff.c          **** 			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
1143:ff.c          **** 			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
1144:ff.c          **** 			fs->fsi_flag = 0;
1145:ff.c          **** 		}
1146:ff.c          **** 		/* Make sure that no pending write process in the lower layer */
1147:ff.c          **** 		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
1148:ff.c          **** 	}
1149:ff.c          **** 
1150:ff.c          **** 	return res;
1151:ff.c          **** }
1152:ff.c          **** 
1153:ff.c          **** #endif
1154:ff.c          **** 
1155:ff.c          **** 
1156:ff.c          **** 
1157:ff.c          **** /*-----------------------------------------------------------------------*/
1158:ff.c          **** /* Get physical sector number from cluster number                        */
1159:ff.c          **** /*-----------------------------------------------------------------------*/
1160:ff.c          **** 
1161:ff.c          **** static LBA_t clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
1162:ff.c          **** 	FATFS* fs,		/* Filesystem object */
1163:ff.c          **** 	DWORD clst		/* Cluster# to be converted */
1164:ff.c          **** )
1165:ff.c          **** {
  57               		.loc 1 1165 0
  58               		.cfi_startproc
  59               	.LVL6:
  60 002a 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 002c 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68               	/* prologue: function */
  69               	/* frame size = 0 */
  70               	/* stack size = 2 */
  71               	.L__stack_usage = 2
  72 002e FC01      		movw r30,r24
1166:ff.c          **** 	clst -= 2;		/* Cluster number is origin from 2 */
  73               		.loc 1 1166 0
  74 0030 9A01      		movw r18,r20
  75 0032 AB01      		movw r20,r22
  76 0034 2250      		subi r18,2
  77 0036 3109      		sbc r19,__zero_reg__
  78 0038 4109      		sbc r20,__zero_reg__
  79 003a 5109      		sbc r21,__zero_reg__
  80               	.LVL7:
1167:ff.c          **** 	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
  81               		.loc 1 1167 0
  82 003c 8389      		ldd r24,Z+19
  83 003e 9489      		ldd r25,Z+20
  84 0040 A589      		ldd r26,Z+21
  85 0042 B689      		ldd r27,Z+22
  86               	.LVL8:
  87 0044 0297      		sbiw r24,2
  88 0046 A109      		sbc r26,__zero_reg__
  89 0048 B109      		sbc r27,__zero_reg__
  90 004a 2817      		cp r18,r24
  91 004c 3907      		cpc r19,r25
  92 004e 4A07      		cpc r20,r26
  93 0050 5B07      		cpc r21,r27
  94 0052 00F4      		brsh .L4
1168:ff.c          **** 	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
  95               		.loc 1 1168 0
  96 0054 A185      		ldd r26,Z+9
  97 0056 B285      		ldd r27,Z+10
  98 0058 0E94 0000 		call __muluhisi3
  99 005c 07A1      		ldd r16,Z+39
 100 005e 10A5      		ldd r17,Z+40
 101 0060 21A5      		ldd r18,Z+41
 102 0062 32A5      		ldd r19,Z+42
 103 0064 600F      		add r22,r16
 104 0066 711F      		adc r23,r17
 105 0068 821F      		adc r24,r18
 106 006a 931F      		adc r25,r19
 107 006c 00C0      		rjmp .L3
 108               	.L4:
1167:ff.c          **** 	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 109               		.loc 1 1167 0
 110 006e 60E0      		ldi r22,0
 111 0070 70E0      		ldi r23,0
 112 0072 CB01      		movw r24,r22
 113               	.L3:
 114               	/* epilogue start */
1169:ff.c          **** }
 115               		.loc 1 1169 0
 116 0074 1F91      		pop r17
 117 0076 0F91      		pop r16
 118 0078 0895      		ret
 119               		.cfi_endproc
 120               	.LFE13:
 123               	get_ldnumber:
 124               	.LFB31:
1170:ff.c          **** 
1171:ff.c          **** 
1172:ff.c          **** 
1173:ff.c          **** 
1174:ff.c          **** /*-----------------------------------------------------------------------*/
1175:ff.c          **** /* FAT access - Read value of a FAT entry                                */
1176:ff.c          **** /*-----------------------------------------------------------------------*/
1177:ff.c          **** 
1178:ff.c          **** static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
1179:ff.c          **** 	FFOBJID* obj,	/* Corresponding object */
1180:ff.c          **** 	DWORD clst		/* Cluster number to get the value */
1181:ff.c          **** )
1182:ff.c          **** {
1183:ff.c          **** 	UINT wc, bc;
1184:ff.c          **** 	DWORD val;
1185:ff.c          **** 	FATFS *fs = obj->fs;
1186:ff.c          **** 
1187:ff.c          **** 
1188:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
1189:ff.c          **** 		val = 1;	/* Internal error */
1190:ff.c          **** 
1191:ff.c          **** 	} else {
1192:ff.c          **** 		val = 0xFFFFFFFF;	/* Default value falls on disk error */
1193:ff.c          **** 
1194:ff.c          **** 		switch (fs->fs_type) {
1195:ff.c          **** 		case FS_FAT12 :
1196:ff.c          **** 			bc = (UINT)clst; bc += bc / 2;
1197:ff.c          **** 			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
1198:ff.c          **** 			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
1199:ff.c          **** 			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
1200:ff.c          **** 			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
1201:ff.c          **** 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
1202:ff.c          **** 			break;
1203:ff.c          **** 
1204:ff.c          **** 		case FS_FAT16 :
1205:ff.c          **** 			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
1206:ff.c          **** 			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
1207:ff.c          **** 			break;
1208:ff.c          **** 
1209:ff.c          **** 		case FS_FAT32 :
1210:ff.c          **** 			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
1211:ff.c          **** 			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upp
1212:ff.c          **** 			break;
1213:ff.c          **** #if FF_FS_EXFAT
1214:ff.c          **** 		case FS_EXFAT :
1215:ff.c          **** 			if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must 
1216:ff.c          **** 				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
1217:ff.c          **** 				DWORD clen = (DWORD)((LBA_t)((obj->objsize - 1) / SS(fs)) / fs->csize);	/* Number of clusters -
1218:ff.c          **** 
1219:ff.c          **** 				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
1220:ff.c          **** 					val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
1221:ff.c          **** 					break;
1222:ff.c          **** 				}
1223:ff.c          **** 				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
1224:ff.c          **** 					val = clst + 1; 	/* Generate the value */
1225:ff.c          **** 					break;
1226:ff.c          **** 				}
1227:ff.c          **** 				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
1228:ff.c          **** 					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
1229:ff.c          **** 						val = 0x7FFFFFFF;	/* Generate EOC */
1230:ff.c          **** 					} else {
1231:ff.c          **** 						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
1232:ff.c          **** 						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
1233:ff.c          **** 					}
1234:ff.c          **** 					break;
1235:ff.c          **** 				}
1236:ff.c          **** 			}
1237:ff.c          **** 			val = 1;	/* Internal error */
1238:ff.c          **** 			break;
1239:ff.c          **** #endif
1240:ff.c          **** 		default:
1241:ff.c          **** 			val = 1;	/* Internal error */
1242:ff.c          **** 		}
1243:ff.c          **** 	}
1244:ff.c          **** 
1245:ff.c          **** 	return val;
1246:ff.c          **** }
1247:ff.c          **** 
1248:ff.c          **** 
1249:ff.c          **** 
1250:ff.c          **** 
1251:ff.c          **** #if !FF_FS_READONLY
1252:ff.c          **** /*-----------------------------------------------------------------------*/
1253:ff.c          **** /* FAT access - Change value of a FAT entry                              */
1254:ff.c          **** /*-----------------------------------------------------------------------*/
1255:ff.c          **** 
1256:ff.c          **** static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
1257:ff.c          **** 	FATFS* fs,		/* Corresponding filesystem object */
1258:ff.c          **** 	DWORD clst,		/* FAT index number (cluster number) to be changed */
1259:ff.c          **** 	DWORD val		/* New value to be set to the entry */
1260:ff.c          **** )
1261:ff.c          **** {
1262:ff.c          **** 	UINT bc;
1263:ff.c          **** 	BYTE *p;
1264:ff.c          **** 	FRESULT res = FR_INT_ERR;
1265:ff.c          **** 
1266:ff.c          **** 
1267:ff.c          **** 	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
1268:ff.c          **** 		switch (fs->fs_type) {
1269:ff.c          **** 		case FS_FAT12:
1270:ff.c          **** 			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
1271:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
1272:ff.c          **** 			if (res != FR_OK) break;
1273:ff.c          **** 			p = fs->win + bc++ % SS(fs);
1274:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
1275:ff.c          **** 			fs->wflag = 1;
1276:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
1277:ff.c          **** 			if (res != FR_OK) break;
1278:ff.c          **** 			p = fs->win + bc % SS(fs);
1279:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd by
1280:ff.c          **** 			fs->wflag = 1;
1281:ff.c          **** 			break;
1282:ff.c          **** 
1283:ff.c          **** 		case FS_FAT16:
1284:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
1285:ff.c          **** 			if (res != FR_OK) break;
1286:ff.c          **** 			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
1287:ff.c          **** 			fs->wflag = 1;
1288:ff.c          **** 			break;
1289:ff.c          **** 
1290:ff.c          **** 		case FS_FAT32:
1291:ff.c          **** #if FF_FS_EXFAT
1292:ff.c          **** 		case FS_EXFAT:
1293:ff.c          **** #endif
1294:ff.c          **** 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
1295:ff.c          **** 			if (res != FR_OK) break;
1296:ff.c          **** 			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
1297:ff.c          **** 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
1298:ff.c          **** 			}
1299:ff.c          **** 			st_dword(fs->win + clst * 4 % SS(fs), val);
1300:ff.c          **** 			fs->wflag = 1;
1301:ff.c          **** 			break;
1302:ff.c          **** 		}
1303:ff.c          **** 	}
1304:ff.c          **** 	return res;
1305:ff.c          **** }
1306:ff.c          **** 
1307:ff.c          **** #endif /* !FF_FS_READONLY */
1308:ff.c          **** 
1309:ff.c          **** 
1310:ff.c          **** 
1311:ff.c          **** 
1312:ff.c          **** #if FF_FS_EXFAT && !FF_FS_READONLY
1313:ff.c          **** /*-----------------------------------------------------------------------*/
1314:ff.c          **** /* exFAT: Accessing FAT and Allocation Bitmap                            */
1315:ff.c          **** /*-----------------------------------------------------------------------*/
1316:ff.c          **** 
1317:ff.c          **** /*--------------------------------------*/
1318:ff.c          **** /* Find a contiguous free cluster block */
1319:ff.c          **** /*--------------------------------------*/
1320:ff.c          **** 
1321:ff.c          **** static DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
1322:ff.c          **** 	FATFS* fs,	/* Filesystem object */
1323:ff.c          **** 	DWORD clst,	/* Cluster number to scan from */
1324:ff.c          **** 	DWORD ncl	/* Number of contiguous clusters to find (1..) */
1325:ff.c          **** )
1326:ff.c          **** {
1327:ff.c          **** 	BYTE bm, bv;
1328:ff.c          **** 	UINT i;
1329:ff.c          **** 	DWORD val, scl, ctr;
1330:ff.c          **** 
1331:ff.c          **** 
1332:ff.c          **** 	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
1333:ff.c          **** 	if (clst >= fs->n_fatent - 2) clst = 0;
1334:ff.c          **** 	scl = val = clst; ctr = 0;
1335:ff.c          **** 	for (;;) {
1336:ff.c          **** 		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
1337:ff.c          **** 		i = val / 8 % SS(fs); bm = 1 << (val % 8);
1338:ff.c          **** 		do {
1339:ff.c          **** 			do {
1340:ff.c          **** 				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
1341:ff.c          **** 				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
1342:ff.c          **** 					val = 0; bm = 0; i = SS(fs);
1343:ff.c          **** 				}
1344:ff.c          **** 				if (bv == 0) {	/* Is it a free cluster? */
1345:ff.c          **** 					if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
1346:ff.c          **** 				} else {
1347:ff.c          **** 					scl = val; ctr = 0;		/* Encountered a cluster in-use, restart to scan */
1348:ff.c          **** 				}
1349:ff.c          **** 				if (val == clst) return 0;	/* All cluster scanned? */
1350:ff.c          **** 			} while (bm != 0);
1351:ff.c          **** 			bm = 1;
1352:ff.c          **** 		} while (++i < SS(fs));
1353:ff.c          **** 	}
1354:ff.c          **** }
1355:ff.c          **** 
1356:ff.c          **** 
1357:ff.c          **** /*----------------------------------------*/
1358:ff.c          **** /* Set/Clear a block of allocation bitmap */
1359:ff.c          **** /*----------------------------------------*/
1360:ff.c          **** 
1361:ff.c          **** static FRESULT change_bitmap (
1362:ff.c          **** 	FATFS* fs,	/* Filesystem object */
1363:ff.c          **** 	DWORD clst,	/* Cluster number to change from */
1364:ff.c          **** 	DWORD ncl,	/* Number of clusters to be changed */
1365:ff.c          **** 	int bv		/* bit value to be set (0 or 1) */
1366:ff.c          **** )
1367:ff.c          **** {
1368:ff.c          **** 	BYTE bm;
1369:ff.c          **** 	UINT i;
1370:ff.c          **** 	LBA_t sect;
1371:ff.c          **** 
1372:ff.c          **** 
1373:ff.c          **** 	clst -= 2;	/* The first bit corresponds to cluster #2 */
1374:ff.c          **** 	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
1375:ff.c          **** 	i = clst / 8 % SS(fs);					/* Byte offset in the sector */
1376:ff.c          **** 	bm = 1 << (clst % 8);					/* Bit mask in the byte */
1377:ff.c          **** 	for (;;) {
1378:ff.c          **** 		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
1379:ff.c          **** 		do {
1380:ff.c          **** 			do {
1381:ff.c          **** 				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
1382:ff.c          **** 				fs->win[i] ^= bm;	/* Flip the bit */
1383:ff.c          **** 				fs->wflag = 1;
1384:ff.c          **** 				if (--ncl == 0) return FR_OK;	/* All bits processed? */
1385:ff.c          **** 			} while (bm <<= 1);		/* Next bit */
1386:ff.c          **** 			bm = 1;
1387:ff.c          **** 		} while (++i < SS(fs));		/* Next byte */
1388:ff.c          **** 		i = 0;
1389:ff.c          **** 	}
1390:ff.c          **** }
1391:ff.c          **** 
1392:ff.c          **** 
1393:ff.c          **** /*---------------------------------------------*/
1394:ff.c          **** /* Fill the first fragment of the FAT chain    */
1395:ff.c          **** /*---------------------------------------------*/
1396:ff.c          **** 
1397:ff.c          **** static FRESULT fill_first_frag (
1398:ff.c          **** 	FFOBJID* obj	/* Pointer to the corresponding object */
1399:ff.c          **** )
1400:ff.c          **** {
1401:ff.c          **** 	FRESULT res;
1402:ff.c          **** 	DWORD cl, n;
1403:ff.c          **** 
1404:ff.c          **** 
1405:ff.c          **** 	if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
1406:ff.c          **** 		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
1407:ff.c          **** 			res = put_fat(obj->fs, cl, cl + 1);
1408:ff.c          **** 			if (res != FR_OK) return res;
1409:ff.c          **** 		}
1410:ff.c          **** 		obj->stat = 0;	/* Change status 'FAT chain is valid' */
1411:ff.c          **** 	}
1412:ff.c          **** 	return FR_OK;
1413:ff.c          **** }
1414:ff.c          **** 
1415:ff.c          **** 
1416:ff.c          **** /*---------------------------------------------*/
1417:ff.c          **** /* Fill the last fragment of the FAT chain     */
1418:ff.c          **** /*---------------------------------------------*/
1419:ff.c          **** 
1420:ff.c          **** static FRESULT fill_last_frag (
1421:ff.c          **** 	FFOBJID* obj,	/* Pointer to the corresponding object */
1422:ff.c          **** 	DWORD lcl,		/* Last cluster of the fragment */
1423:ff.c          **** 	DWORD term		/* Value to set the last FAT entry */
1424:ff.c          **** )
1425:ff.c          **** {
1426:ff.c          **** 	FRESULT res;
1427:ff.c          **** 
1428:ff.c          **** 
1429:ff.c          **** 	while (obj->n_frag > 0) {	/* Create the chain of last fragment */
1430:ff.c          **** 		res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
1431:ff.c          **** 		if (res != FR_OK) return res;
1432:ff.c          **** 		obj->n_frag--;
1433:ff.c          **** 	}
1434:ff.c          **** 	return FR_OK;
1435:ff.c          **** }
1436:ff.c          **** 
1437:ff.c          **** #endif	/* FF_FS_EXFAT && !FF_FS_READONLY */
1438:ff.c          **** 
1439:ff.c          **** 
1440:ff.c          **** 
1441:ff.c          **** #if !FF_FS_READONLY
1442:ff.c          **** /*-----------------------------------------------------------------------*/
1443:ff.c          **** /* FAT handling - Remove a cluster chain                                 */
1444:ff.c          **** /*-----------------------------------------------------------------------*/
1445:ff.c          **** 
1446:ff.c          **** static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
1447:ff.c          **** 	FFOBJID* obj,		/* Corresponding object */
1448:ff.c          **** 	DWORD clst,			/* Cluster to remove a chain from */
1449:ff.c          **** 	DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
1450:ff.c          **** )
1451:ff.c          **** {
1452:ff.c          **** 	FRESULT res = FR_OK;
1453:ff.c          **** 	DWORD nxt;
1454:ff.c          **** 	FATFS *fs = obj->fs;
1455:ff.c          **** #if FF_FS_EXFAT || FF_USE_TRIM
1456:ff.c          **** 	DWORD scl = clst, ecl = clst;
1457:ff.c          **** #endif
1458:ff.c          **** #if FF_USE_TRIM
1459:ff.c          **** 	LBA_t rt[2];
1460:ff.c          **** #endif
1461:ff.c          **** 
1462:ff.c          **** 	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
1463:ff.c          **** 
1464:ff.c          **** 	/* Mark the previous cluster 'EOC' on the FAT if it exists */
1465:ff.c          **** 	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
1466:ff.c          **** 		res = put_fat(fs, pclst, 0xFFFFFFFF);
1467:ff.c          **** 		if (res != FR_OK) return res;
1468:ff.c          **** 	}
1469:ff.c          **** 
1470:ff.c          **** 	/* Remove the chain */
1471:ff.c          **** 	do {
1472:ff.c          **** 		nxt = get_fat(obj, clst);			/* Get cluster status */
1473:ff.c          **** 		if (nxt == 0) break;				/* Empty cluster? */
1474:ff.c          **** 		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
1475:ff.c          **** 		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
1476:ff.c          **** 		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
1477:ff.c          **** 			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
1478:ff.c          **** 			if (res != FR_OK) return res;
1479:ff.c          **** 		}
1480:ff.c          **** 		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
1481:ff.c          **** 			fs->free_clst++;
1482:ff.c          **** 			fs->fsi_flag |= 1;
1483:ff.c          **** 		}
1484:ff.c          **** #if FF_FS_EXFAT || FF_USE_TRIM
1485:ff.c          **** 		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
1486:ff.c          **** 			ecl = nxt;
1487:ff.c          **** 		} else {				/* End of contiguous cluster block */
1488:ff.c          **** #if FF_FS_EXFAT
1489:ff.c          **** 			if (fs->fs_type == FS_EXFAT) {
1490:ff.c          **** 				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap 
1491:ff.c          **** 				if (res != FR_OK) return res;
1492:ff.c          **** 			}
1493:ff.c          **** #endif
1494:ff.c          **** #if FF_USE_TRIM
1495:ff.c          **** 			rt[0] = clst2sect(fs, scl);					/* Start of data area to be freed */
1496:ff.c          **** 			rt[1] = clst2sect(fs, ecl) + fs->csize - 1;	/* End of data area to be freed */
1497:ff.c          **** 			disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform storage device that the data in the block may be
1498:ff.c          **** #endif
1499:ff.c          **** 			scl = ecl = nxt;
1500:ff.c          **** 		}
1501:ff.c          **** #endif
1502:ff.c          **** 		clst = nxt;					/* Next cluster */
1503:ff.c          **** 	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
1504:ff.c          **** 
1505:ff.c          **** #if FF_FS_EXFAT
1506:ff.c          **** 	/* Some post processes for chain status */
1507:ff.c          **** 	if (fs->fs_type == FS_EXFAT) {
1508:ff.c          **** 		if (pclst == 0) {	/* Has the entire chain been removed? */
1509:ff.c          **** 			obj->stat = 0;		/* Change the chain status 'initial' */
1510:ff.c          **** 		} else {
1511:ff.c          **** 			if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
1512:ff.c          **** 				clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
1513:ff.c          **** 				while (clst != pclst) {
1514:ff.c          **** 					nxt = get_fat(obj, clst);
1515:ff.c          **** 					if (nxt < 2) return FR_INT_ERR;
1516:ff.c          **** 					if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
1517:ff.c          **** 					if (nxt != clst + 1) break;	/* Not contiguous? */
1518:ff.c          **** 					clst++;
1519:ff.c          **** 				}
1520:ff.c          **** 				if (clst == pclst) {	/* Has the chain got contiguous again? */
1521:ff.c          **** 					obj->stat = 2;		/* Change the chain status 'contiguous' */
1522:ff.c          **** 				}
1523:ff.c          **** 			} else {
1524:ff.c          **** 				if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the 
1525:ff.c          **** 					obj->stat = 2;	/* Change the chain status 'contiguous' */
1526:ff.c          **** 				}
1527:ff.c          **** 			}
1528:ff.c          **** 		}
1529:ff.c          **** 	}
1530:ff.c          **** #endif
1531:ff.c          **** 	return FR_OK;
1532:ff.c          **** }
1533:ff.c          **** 
1534:ff.c          **** 
1535:ff.c          **** 
1536:ff.c          **** 
1537:ff.c          **** /*-----------------------------------------------------------------------*/
1538:ff.c          **** /* FAT handling - Stretch a chain or Create a new chain                  */
1539:ff.c          **** /*-----------------------------------------------------------------------*/
1540:ff.c          **** 
1541:ff.c          **** static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New 
1542:ff.c          **** 	FFOBJID* obj,		/* Corresponding object */
1543:ff.c          **** 	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
1544:ff.c          **** )
1545:ff.c          **** {
1546:ff.c          **** 	DWORD cs, ncl, scl;
1547:ff.c          **** 	FRESULT res;
1548:ff.c          **** 	FATFS *fs = obj->fs;
1549:ff.c          **** 
1550:ff.c          **** 
1551:ff.c          **** 	if (clst == 0) {	/* Create a new chain */
1552:ff.c          **** 		scl = fs->last_clst;				/* Suggested cluster to start to find */
1553:ff.c          **** 		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
1554:ff.c          **** 	}
1555:ff.c          **** 	else {				/* Stretch a chain */
1556:ff.c          **** 		cs = get_fat(obj, clst);			/* Check the cluster status */
1557:ff.c          **** 		if (cs < 2) return 1;				/* Test for insanity */
1558:ff.c          **** 		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
1559:ff.c          **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
1560:ff.c          **** 		scl = clst;							/* Cluster to start to find */
1561:ff.c          **** 	}
1562:ff.c          **** 	if (fs->free_clst == 0) return 0;		/* No free cluster */
1563:ff.c          **** 
1564:ff.c          **** #if FF_FS_EXFAT
1565:ff.c          **** 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
1566:ff.c          **** 		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
1567:ff.c          **** 		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
1568:ff.c          **** 		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
1569:ff.c          **** 		if (res == FR_INT_ERR) return 1;
1570:ff.c          **** 		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
1571:ff.c          **** 		if (clst == 0) {							/* Is it a new chain? */
1572:ff.c          **** 			obj->stat = 2;							/* Set status 'contiguous' */
1573:ff.c          **** 		} else {									/* It is a stretched chain */
1574:ff.c          **** 			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
1575:ff.c          **** 				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
1576:ff.c          **** 				obj->stat = 3;						/* Change status 'just fragmented' */
1577:ff.c          **** 			}
1578:ff.c          **** 		}
1579:ff.c          **** 		if (obj->stat != 2) {	/* Is the file non-contiguous? */
1580:ff.c          **** 			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
1581:ff.c          **** 				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
1582:ff.c          **** 			} else {				/* New fragment */
1583:ff.c          **** 				if (obj->n_frag == 0) obj->n_frag = 1;
1584:ff.c          **** 				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one *
1585:ff.c          **** 				if (res == FR_OK) obj->n_frag = 1;
1586:ff.c          **** 			}
1587:ff.c          **** 		}
1588:ff.c          **** 	} else
1589:ff.c          **** #endif
1590:ff.c          **** 	{	/* On the FAT/FAT32 volume */
1591:ff.c          **** 		ncl = 0;
1592:ff.c          **** 		if (scl == clst) {						/* Stretching an existing chain? */
1593:ff.c          **** 			ncl = scl + 1;						/* Test if next cluster is free */
1594:ff.c          **** 			if (ncl >= fs->n_fatent) ncl = 2;
1595:ff.c          **** 			cs = get_fat(obj, ncl);				/* Get next cluster status */
1596:ff.c          **** 			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
1597:ff.c          **** 			if (cs != 0) {						/* Not free? */
1598:ff.c          **** 				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
1599:ff.c          **** 				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
1600:ff.c          **** 				ncl = 0;
1601:ff.c          **** 			}
1602:ff.c          **** 		}
1603:ff.c          **** 		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
1604:ff.c          **** 			ncl = scl;	/* Start cluster */
1605:ff.c          **** 			for (;;) {
1606:ff.c          **** 				ncl++;							/* Next cluster */
1607:ff.c          **** 				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
1608:ff.c          **** 					ncl = 2;
1609:ff.c          **** 					if (ncl > scl) return 0;	/* No free cluster found? */
1610:ff.c          **** 				}
1611:ff.c          **** 				cs = get_fat(obj, ncl);			/* Get the cluster status */
1612:ff.c          **** 				if (cs == 0) break;				/* Found a free cluster? */
1613:ff.c          **** 				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
1614:ff.c          **** 				if (ncl == scl) return 0;		/* No free cluster found? */
1615:ff.c          **** 			}
1616:ff.c          **** 		}
1617:ff.c          **** 		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
1618:ff.c          **** 		if (res == FR_OK && clst != 0) {
1619:ff.c          **** 			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
1620:ff.c          **** 		}
1621:ff.c          **** 	}
1622:ff.c          **** 
1623:ff.c          **** 	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
1624:ff.c          **** 		fs->last_clst = ncl;
1625:ff.c          **** 		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
1626:ff.c          **** 		fs->fsi_flag |= 1;
1627:ff.c          **** 	} else {
1628:ff.c          **** 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
1629:ff.c          **** 	}
1630:ff.c          **** 
1631:ff.c          **** 	return ncl;		/* Return new cluster number or error status */
1632:ff.c          **** }
1633:ff.c          **** 
1634:ff.c          **** #endif /* !FF_FS_READONLY */
1635:ff.c          **** 
1636:ff.c          **** 
1637:ff.c          **** 
1638:ff.c          **** 
1639:ff.c          **** #if FF_USE_FASTSEEK
1640:ff.c          **** /*-----------------------------------------------------------------------*/
1641:ff.c          **** /* FAT handling - Convert offset into cluster with link map table        */
1642:ff.c          **** /*-----------------------------------------------------------------------*/
1643:ff.c          **** 
1644:ff.c          **** static DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
1645:ff.c          **** 	FIL* fp,		/* Pointer to the file object */
1646:ff.c          **** 	FSIZE_t ofs		/* File offset to be converted to cluster# */
1647:ff.c          **** )
1648:ff.c          **** {
1649:ff.c          **** 	DWORD cl, ncl, *tbl;
1650:ff.c          **** 	FATFS *fs = fp->obj.fs;
1651:ff.c          **** 
1652:ff.c          **** 
1653:ff.c          **** 	tbl = fp->cltbl + 1;	/* Top of CLMT */
1654:ff.c          **** 	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
1655:ff.c          **** 	for (;;) {
1656:ff.c          **** 		ncl = *tbl++;			/* Number of cluters in the fragment */
1657:ff.c          **** 		if (ncl == 0) return 0;	/* End of table? (error) */
1658:ff.c          **** 		if (cl < ncl) break;	/* In this fragment? */
1659:ff.c          **** 		cl -= ncl; tbl++;		/* Next fragment */
1660:ff.c          **** 	}
1661:ff.c          **** 	return cl + *tbl;	/* Return the cluster number */
1662:ff.c          **** }
1663:ff.c          **** 
1664:ff.c          **** #endif	/* FF_USE_FASTSEEK */
1665:ff.c          **** 
1666:ff.c          **** 
1667:ff.c          **** 
1668:ff.c          **** 
1669:ff.c          **** /*-----------------------------------------------------------------------*/
1670:ff.c          **** /* Directory handling - Fill a cluster with zeros                        */
1671:ff.c          **** /*-----------------------------------------------------------------------*/
1672:ff.c          **** 
1673:ff.c          **** #if !FF_FS_READONLY
1674:ff.c          **** static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
1675:ff.c          **** 	FATFS *fs,		/* Filesystem object */
1676:ff.c          **** 	DWORD clst		/* Directory table to clear */
1677:ff.c          **** )
1678:ff.c          **** {
1679:ff.c          **** 	LBA_t sect;
1680:ff.c          **** 	UINT n, szb;
1681:ff.c          **** 	BYTE *ibuf;
1682:ff.c          **** 
1683:ff.c          **** 
1684:ff.c          **** 	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
1685:ff.c          **** 	sect = clst2sect(fs, clst);		/* Top of the cluster */
1686:ff.c          **** 	fs->winsect = sect;				/* Set window to top of the cluster */
1687:ff.c          **** 	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
1688:ff.c          **** #if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
1689:ff.c          **** 	/* Allocate a temporary buffer */
1690:ff.c          **** 	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; 
1691:ff.c          **** 	if (szb > SS(fs)) {		/* Buffer allocated? */
1692:ff.c          **** 		mem_set(ibuf, 0, szb);
1693:ff.c          **** 		szb /= SS(fs);		/* Bytes -> Sectors */
1694:ff.c          **** 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* 
1695:ff.c          **** 		ff_memfree(ibuf);
1696:ff.c          **** 	} else
1697:ff.c          **** #endif
1698:ff.c          **** 	{
1699:ff.c          **** 		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
1700:ff.c          **** 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* 
1701:ff.c          **** 	}
1702:ff.c          **** 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
1703:ff.c          **** }
1704:ff.c          **** #endif	/* !FF_FS_READONLY */
1705:ff.c          **** 
1706:ff.c          **** 
1707:ff.c          **** 
1708:ff.c          **** 
1709:ff.c          **** /*-----------------------------------------------------------------------*/
1710:ff.c          **** /* Directory handling - Set directory index                              */
1711:ff.c          **** /*-----------------------------------------------------------------------*/
1712:ff.c          **** 
1713:ff.c          **** static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
1714:ff.c          **** 	DIR* dp,		/* Pointer to directory object */
1715:ff.c          **** 	DWORD ofs		/* Offset of directory table */
1716:ff.c          **** )
1717:ff.c          **** {
1718:ff.c          **** 	DWORD csz, clst;
1719:ff.c          **** 	FATFS *fs = dp->obj.fs;
1720:ff.c          **** 
1721:ff.c          **** 
1722:ff.c          **** 	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIR
1723:ff.c          **** 		return FR_INT_ERR;
1724:ff.c          **** 	}
1725:ff.c          **** 	dp->dptr = ofs;				/* Set current offset */
1726:ff.c          **** 	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
1727:ff.c          **** 	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
1728:ff.c          **** 		clst = (DWORD)fs->dirbase;
1729:ff.c          **** 		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
1730:ff.c          **** 	}
1731:ff.c          **** 
1732:ff.c          **** 	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
1733:ff.c          **** 		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
1734:ff.c          **** 		dp->sect = fs->dirbase;
1735:ff.c          **** 
1736:ff.c          **** 	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
1737:ff.c          **** 		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
1738:ff.c          **** 		while (ofs >= csz) {				/* Follow cluster chain */
1739:ff.c          **** 			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
1740:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1741:ff.c          **** 			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal 
1742:ff.c          **** 			ofs -= csz;
1743:ff.c          **** 		}
1744:ff.c          **** 		dp->sect = clst2sect(fs, clst);
1745:ff.c          **** 	}
1746:ff.c          **** 	dp->clust = clst;					/* Current cluster# */
1747:ff.c          **** 	if (dp->sect == 0) return FR_INT_ERR;
1748:ff.c          **** 	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
1749:ff.c          **** 	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
1750:ff.c          **** 
1751:ff.c          **** 	return FR_OK;
1752:ff.c          **** }
1753:ff.c          **** 
1754:ff.c          **** 
1755:ff.c          **** 
1756:ff.c          **** 
1757:ff.c          **** /*-----------------------------------------------------------------------*/
1758:ff.c          **** /* Directory handling - Move directory table index next                  */
1759:ff.c          **** /*-----------------------------------------------------------------------*/
1760:ff.c          **** 
1761:ff.c          **** static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stret
1762:ff.c          **** 	DIR* dp,				/* Pointer to the directory object */
1763:ff.c          **** 	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
1764:ff.c          **** )
1765:ff.c          **** {
1766:ff.c          **** 	DWORD ofs, clst;
1767:ff.c          **** 	FATFS *fs = dp->obj.fs;
1768:ff.c          **** 
1769:ff.c          **** 
1770:ff.c          **** 	ofs = dp->dptr + SZDIRE;	/* Next entry */
1771:ff.c          **** 	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;
1772:ff.c          **** 	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
1773:ff.c          **** 
1774:ff.c          **** 	if (ofs % SS(fs) == 0) {	/* Sector changed? */
1775:ff.c          **** 		dp->sect++;				/* Next sector */
1776:ff.c          **** 
1777:ff.c          **** 		if (dp->clust == 0) {	/* Static table */
1778:ff.c          **** 			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
1779:ff.c          **** 				dp->sect = 0; return FR_NO_FILE;
1780:ff.c          **** 			}
1781:ff.c          **** 		}
1782:ff.c          **** 		else {					/* Dynamic table */
1783:ff.c          **** 			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
1784:ff.c          **** 				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
1785:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
1786:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1787:ff.c          **** 				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
1788:ff.c          **** #if !FF_FS_READONLY
1789:ff.c          **** 					if (!stretch) {								/* If no stretch, report EOT */
1790:ff.c          **** 						dp->sect = 0; return FR_NO_FILE;
1791:ff.c          **** 					}
1792:ff.c          **** 					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
1793:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
1794:ff.c          **** 					if (clst == 1) return FR_INT_ERR;			/* Internal error */
1795:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
1796:ff.c          **** 					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
1797:ff.c          **** 					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
1798:ff.c          **** #else
1799:ff.c          **** 					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
1800:ff.c          **** 					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
1801:ff.c          **** #endif
1802:ff.c          **** 				}
1803:ff.c          **** 				dp->clust = clst;		/* Initialize data for new cluster */
1804:ff.c          **** 				dp->sect = clst2sect(fs, clst);
1805:ff.c          **** 			}
1806:ff.c          **** 		}
1807:ff.c          **** 	}
1808:ff.c          **** 	dp->dptr = ofs;						/* Current entry */
1809:ff.c          **** 	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
1810:ff.c          **** 
1811:ff.c          **** 	return FR_OK;
1812:ff.c          **** }
1813:ff.c          **** 
1814:ff.c          **** 
1815:ff.c          **** 
1816:ff.c          **** 
1817:ff.c          **** #if !FF_FS_READONLY
1818:ff.c          **** /*-----------------------------------------------------------------------*/
1819:ff.c          **** /* Directory handling - Reserve a block of directory entries             */
1820:ff.c          **** /*-----------------------------------------------------------------------*/
1821:ff.c          **** 
1822:ff.c          **** static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
1823:ff.c          **** 	DIR* dp,				/* Pointer to the directory object */
1824:ff.c          **** 	UINT n_ent				/* Number of contiguous entries to allocate */
1825:ff.c          **** )
1826:ff.c          **** {
1827:ff.c          **** 	FRESULT res;
1828:ff.c          **** 	UINT n;
1829:ff.c          **** 	FATFS *fs = dp->obj.fs;
1830:ff.c          **** 
1831:ff.c          **** 
1832:ff.c          **** 	res = dir_sdi(dp, 0);
1833:ff.c          **** 	if (res == FR_OK) {
1834:ff.c          **** 		n = 0;
1835:ff.c          **** 		do {
1836:ff.c          **** 			res = move_window(fs, dp->sect);
1837:ff.c          **** 			if (res != FR_OK) break;
1838:ff.c          **** #if FF_FS_EXFAT
1839:ff.c          **** 			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name
1840:ff.c          **** #else
1841:ff.c          **** 			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
1842:ff.c          **** #endif
1843:ff.c          **** 				if (++n == n_ent) break;	/* Is a block of contiguous free entries found? */
1844:ff.c          **** 			} else {
1845:ff.c          **** 				n = 0;				/* Not a free entry, restart to search */
1846:ff.c          **** 			}
1847:ff.c          **** 			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
1848:ff.c          **** 		} while (res == FR_OK);
1849:ff.c          **** 	}
1850:ff.c          **** 
1851:ff.c          **** 	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
1852:ff.c          **** 	return res;
1853:ff.c          **** }
1854:ff.c          **** 
1855:ff.c          **** #endif	/* !FF_FS_READONLY */
1856:ff.c          **** 
1857:ff.c          **** 
1858:ff.c          **** 
1859:ff.c          **** 
1860:ff.c          **** /*-----------------------------------------------------------------------*/
1861:ff.c          **** /* FAT: Directory handling - Load/Store start cluster number             */
1862:ff.c          **** /*-----------------------------------------------------------------------*/
1863:ff.c          **** 
1864:ff.c          **** static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
1865:ff.c          **** 	FATFS* fs,			/* Pointer to the fs object */
1866:ff.c          **** 	const BYTE* dir		/* Pointer to the key entry */
1867:ff.c          **** )
1868:ff.c          **** {
1869:ff.c          **** 	DWORD cl;
1870:ff.c          **** 
1871:ff.c          **** 	cl = ld_word(dir + DIR_FstClusLO);
1872:ff.c          **** 	if (fs->fs_type == FS_FAT32) {
1873:ff.c          **** 		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
1874:ff.c          **** 	}
1875:ff.c          **** 
1876:ff.c          **** 	return cl;
1877:ff.c          **** }
1878:ff.c          **** 
1879:ff.c          **** 
1880:ff.c          **** #if !FF_FS_READONLY
1881:ff.c          **** static void st_clust (
1882:ff.c          **** 	FATFS* fs,	/* Pointer to the fs object */
1883:ff.c          **** 	BYTE* dir,	/* Pointer to the key entry */
1884:ff.c          **** 	DWORD cl	/* Value to be set */
1885:ff.c          **** )
1886:ff.c          **** {
1887:ff.c          **** 	st_word(dir + DIR_FstClusLO, (WORD)cl);
1888:ff.c          **** 	if (fs->fs_type == FS_FAT32) {
1889:ff.c          **** 		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
1890:ff.c          **** 	}
1891:ff.c          **** }
1892:ff.c          **** #endif
1893:ff.c          **** 
1894:ff.c          **** 
1895:ff.c          **** 
1896:ff.c          **** #if FF_USE_LFN
1897:ff.c          **** /*--------------------------------------------------------*/
1898:ff.c          **** /* FAT-LFN: Compare a part of file name with an LFN entry */
1899:ff.c          **** /*--------------------------------------------------------*/
1900:ff.c          **** 
1901:ff.c          **** static int cmp_lfn (		/* 1:matched, 0:not matched */
1902:ff.c          **** 	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
1903:ff.c          **** 	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
1904:ff.c          **** )
1905:ff.c          **** {
1906:ff.c          **** 	UINT i, s;
1907:ff.c          **** 	WCHAR wc, uc;
1908:ff.c          **** 
1909:ff.c          **** 
1910:ff.c          **** 	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
1911:ff.c          **** 
1912:ff.c          **** 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
1913:ff.c          **** 
1914:ff.c          **** 	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
1915:ff.c          **** 		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
1916:ff.c          **** 		if (wc != 0) {
1917:ff.c          **** 			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
1918:ff.c          **** 				return 0;					/* Not matched */
1919:ff.c          **** 			}
1920:ff.c          **** 			wc = uc;
1921:ff.c          **** 		} else {
1922:ff.c          **** 			if (uc != 0xFFFF) return 0;		/* Check filler */
1923:ff.c          **** 		}
1924:ff.c          **** 	}
1925:ff.c          **** 
1926:ff.c          **** 	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different len
1927:ff.c          **** 
1928:ff.c          **** 	return 1;		/* The part of LFN matched */
1929:ff.c          **** }
1930:ff.c          **** 
1931:ff.c          **** 
1932:ff.c          **** #if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
1933:ff.c          **** /*-----------------------------------------------------*/
1934:ff.c          **** /* FAT-LFN: Pick a part of file name from an LFN entry */
1935:ff.c          **** /*-----------------------------------------------------*/
1936:ff.c          **** 
1937:ff.c          **** static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
1938:ff.c          **** 	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
1939:ff.c          **** 	BYTE* dir			/* Pointer to the LFN entry */
1940:ff.c          **** )
1941:ff.c          **** {
1942:ff.c          **** 	UINT i, s;
1943:ff.c          **** 	WCHAR wc, uc;
1944:ff.c          **** 
1945:ff.c          **** 
1946:ff.c          **** 	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
1947:ff.c          **** 
1948:ff.c          **** 	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
1949:ff.c          **** 
1950:ff.c          **** 	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
1951:ff.c          **** 		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
1952:ff.c          **** 		if (wc != 0) {
1953:ff.c          **** 			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
1954:ff.c          **** 			lfnbuf[i++] = wc = uc;			/* Store it */
1955:ff.c          **** 		} else {
1956:ff.c          **** 			if (uc != 0xFFFF) return 0;		/* Check filler */
1957:ff.c          **** 		}
1958:ff.c          **** 	}
1959:ff.c          **** 
1960:ff.c          **** 	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not termin
1961:ff.c          **** 		if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
1962:ff.c          **** 		lfnbuf[i] = 0;
1963:ff.c          **** 	}
1964:ff.c          **** 
1965:ff.c          **** 	return 1;		/* The part of LFN is valid */
1966:ff.c          **** }
1967:ff.c          **** #endif
1968:ff.c          **** 
1969:ff.c          **** 
1970:ff.c          **** #if !FF_FS_READONLY
1971:ff.c          **** /*-----------------------------------------*/
1972:ff.c          **** /* FAT-LFN: Create an entry of LFN entries */
1973:ff.c          **** /*-----------------------------------------*/
1974:ff.c          **** 
1975:ff.c          **** static void put_lfn (
1976:ff.c          **** 	const WCHAR* lfn,	/* Pointer to the LFN */
1977:ff.c          **** 	BYTE* dir,			/* Pointer to the LFN entry to be created */
1978:ff.c          **** 	BYTE ord,			/* LFN order (1-20) */
1979:ff.c          **** 	BYTE sum			/* Checksum of the corresponding SFN */
1980:ff.c          **** )
1981:ff.c          **** {
1982:ff.c          **** 	UINT i, s;
1983:ff.c          **** 	WCHAR wc;
1984:ff.c          **** 
1985:ff.c          **** 
1986:ff.c          **** 	dir[LDIR_Chksum] = sum;			/* Set checksum */
1987:ff.c          **** 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
1988:ff.c          **** 	dir[LDIR_Type] = 0;
1989:ff.c          **** 	st_word(dir + LDIR_FstClusLO, 0);
1990:ff.c          **** 
1991:ff.c          **** 	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
1992:ff.c          **** 	s = wc = 0;
1993:ff.c          **** 	do {
1994:ff.c          **** 		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
1995:ff.c          **** 		st_word(dir + LfnOfs[s], wc);		/* Put it */
1996:ff.c          **** 		if (wc == 0) wc = 0xFFFF;		/* Padding characters for following items */
1997:ff.c          **** 	} while (++s < 13);
1998:ff.c          **** 	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
1999:ff.c          **** 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
2000:ff.c          **** }
2001:ff.c          **** 
2002:ff.c          **** #endif	/* !FF_FS_READONLY */
2003:ff.c          **** #endif	/* FF_USE_LFN */
2004:ff.c          **** 
2005:ff.c          **** 
2006:ff.c          **** 
2007:ff.c          **** #if FF_USE_LFN && !FF_FS_READONLY
2008:ff.c          **** /*-----------------------------------------------------------------------*/
2009:ff.c          **** /* FAT-LFN: Create a Numbered SFN                                        */
2010:ff.c          **** /*-----------------------------------------------------------------------*/
2011:ff.c          **** 
2012:ff.c          **** static void gen_numname (
2013:ff.c          **** 	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
2014:ff.c          **** 	const BYTE* src,	/* Pointer to SFN */
2015:ff.c          **** 	const WCHAR* lfn,	/* Pointer to LFN */
2016:ff.c          **** 	UINT seq			/* Sequence number */
2017:ff.c          **** )
2018:ff.c          **** {
2019:ff.c          **** 	BYTE ns[8], c;
2020:ff.c          **** 	UINT i, j;
2021:ff.c          **** 	WCHAR wc;
2022:ff.c          **** 	DWORD sreg;
2023:ff.c          **** 
2024:ff.c          **** 
2025:ff.c          **** 	mem_cpy(dst, src, 11);
2026:ff.c          **** 
2027:ff.c          **** 	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number 
2028:ff.c          **** 		sreg = seq;
2029:ff.c          **** 		while (*lfn) {	/* Create a CRC as hash value */
2030:ff.c          **** 			wc = *lfn++;
2031:ff.c          **** 			for (i = 0; i < 16; i++) {
2032:ff.c          **** 				sreg = (sreg << 1) + (wc & 1);
2033:ff.c          **** 				wc >>= 1;
2034:ff.c          **** 				if (sreg & 0x10000) sreg ^= 0x11021;
2035:ff.c          **** 			}
2036:ff.c          **** 		}
2037:ff.c          **** 		seq = (UINT)sreg;
2038:ff.c          **** 	}
2039:ff.c          **** 
2040:ff.c          **** 	/* itoa (hexdecimal) */
2041:ff.c          **** 	i = 7;
2042:ff.c          **** 	do {
2043:ff.c          **** 		c = (BYTE)((seq % 16) + '0');
2044:ff.c          **** 		if (c > '9') c += 7;
2045:ff.c          **** 		ns[i--] = c;
2046:ff.c          **** 		seq /= 16;
2047:ff.c          **** 	} while (seq);
2048:ff.c          **** 	ns[i] = '~';
2049:ff.c          **** 
2050:ff.c          **** 	/* Append the number to the SFN body */
2051:ff.c          **** 	for (j = 0; j < i && dst[j] != ' '; j++) {
2052:ff.c          **** 		if (dbc_1st(dst[j])) {
2053:ff.c          **** 			if (j == i - 1) break;
2054:ff.c          **** 			j++;
2055:ff.c          **** 		}
2056:ff.c          **** 	}
2057:ff.c          **** 	do {
2058:ff.c          **** 		dst[j++] = (i < 8) ? ns[i++] : ' ';
2059:ff.c          **** 	} while (j < 8);
2060:ff.c          **** }
2061:ff.c          **** #endif	/* FF_USE_LFN && !FF_FS_READONLY */
2062:ff.c          **** 
2063:ff.c          **** 
2064:ff.c          **** 
2065:ff.c          **** #if FF_USE_LFN
2066:ff.c          **** /*-----------------------------------------------------------------------*/
2067:ff.c          **** /* FAT-LFN: Calculate checksum of an SFN entry                           */
2068:ff.c          **** /*-----------------------------------------------------------------------*/
2069:ff.c          **** 
2070:ff.c          **** static BYTE sum_sfn (
2071:ff.c          **** 	const BYTE* dir		/* Pointer to the SFN entry */
2072:ff.c          **** )
2073:ff.c          **** {
2074:ff.c          **** 	BYTE sum = 0;
2075:ff.c          **** 	UINT n = 11;
2076:ff.c          **** 
2077:ff.c          **** 	do {
2078:ff.c          **** 		sum = (sum >> 1) + (sum << 7) + *dir++;
2079:ff.c          **** 	} while (--n);
2080:ff.c          **** 	return sum;
2081:ff.c          **** }
2082:ff.c          **** 
2083:ff.c          **** #endif	/* FF_USE_LFN */
2084:ff.c          **** 
2085:ff.c          **** 
2086:ff.c          **** 
2087:ff.c          **** #if FF_FS_EXFAT
2088:ff.c          **** /*-----------------------------------------------------------------------*/
2089:ff.c          **** /* exFAT: Checksum                                                       */
2090:ff.c          **** /*-----------------------------------------------------------------------*/
2091:ff.c          **** 
2092:ff.c          **** static WORD xdir_sum (	/* Get checksum of the directoly entry block */
2093:ff.c          **** 	const BYTE* dir		/* Directory entry block to be calculated */
2094:ff.c          **** )
2095:ff.c          **** {
2096:ff.c          **** 	UINT i, szblk;
2097:ff.c          **** 	WORD sum;
2098:ff.c          **** 
2099:ff.c          **** 
2100:ff.c          **** 	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
2101:ff.c          **** 	for (i = sum = 0; i < szblk; i++) {
2102:ff.c          **** 		if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
2103:ff.c          **** 			i++;
2104:ff.c          **** 		} else {
2105:ff.c          **** 			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
2106:ff.c          **** 		}
2107:ff.c          **** 	}
2108:ff.c          **** 	return sum;
2109:ff.c          **** }
2110:ff.c          **** 
2111:ff.c          **** 
2112:ff.c          **** 
2113:ff.c          **** static WORD xname_sum (	/* Get check sum (to be used as hash) of the file name */
2114:ff.c          **** 	const WCHAR* name	/* File name to be calculated */
2115:ff.c          **** )
2116:ff.c          **** {
2117:ff.c          **** 	WCHAR chr;
2118:ff.c          **** 	WORD sum = 0;
2119:ff.c          **** 
2120:ff.c          **** 
2121:ff.c          **** 	while ((chr = *name++) != 0) {
2122:ff.c          **** 		chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
2123:ff.c          **** 		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
2124:ff.c          **** 		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
2125:ff.c          **** 	}
2126:ff.c          **** 	return sum;
2127:ff.c          **** }
2128:ff.c          **** 
2129:ff.c          **** 
2130:ff.c          **** #if !FF_FS_READONLY && FF_USE_MKFS
2131:ff.c          **** static DWORD xsum32 (	/* Returns 32-bit checksum */
2132:ff.c          **** 	BYTE  dat,			/* Byte to be calculated (byte-by-byte processing) */
2133:ff.c          **** 	DWORD sum			/* Previous sum value */
2134:ff.c          **** )
2135:ff.c          **** {
2136:ff.c          **** 	sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
2137:ff.c          **** 	return sum;
2138:ff.c          **** }
2139:ff.c          **** #endif
2140:ff.c          **** 
2141:ff.c          **** 
2142:ff.c          **** #if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
2143:ff.c          **** /*------------------------------------------------------*/
2144:ff.c          **** /* exFAT: Get object information from a directory block */
2145:ff.c          **** /*------------------------------------------------------*/
2146:ff.c          **** 
2147:ff.c          **** static void get_xfileinfo (
2148:ff.c          **** 	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
2149:ff.c          **** 	FILINFO* fno		/* Buffer to store the extracted file information */
2150:ff.c          **** )
2151:ff.c          **** {
2152:ff.c          **** 	WCHAR wc, hs;
2153:ff.c          **** 	UINT di, si, nc;
2154:ff.c          **** 
2155:ff.c          **** 	/* Get file name from the entry block */
2156:ff.c          **** 	si = SZDIRE * 2;	/* 1st C1 entry */
2157:ff.c          **** 	nc = 0; hs = 0; di = 0;
2158:ff.c          **** 	while (nc < dirb[XDIR_NumName]) {
2159:ff.c          **** 		if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
2160:ff.c          **** 		if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
2161:ff.c          **** 		wc = ld_word(dirb + si); si += 2; nc++;	/* Get a character */
2162:ff.c          **** 		if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
2163:ff.c          **** 			hs = wc; continue;	/* Get low surrogate */
2164:ff.c          **** 		}
2165:ff.c          **** 		wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding
2166:ff.c          **** 		if (wc == 0) { di = 0; break; }	/* Buffer overflow or wrong encoding? */
2167:ff.c          **** 		di += wc;
2168:ff.c          **** 		hs = 0;
2169:ff.c          **** 	}
2170:ff.c          **** 	if (hs != 0) di = 0;					/* Broken surrogate pair? */
2171:ff.c          **** 	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
2172:ff.c          **** 	fno->fname[di] = 0;						/* Terminate the name */
2173:ff.c          **** 	fno->altname[0] = 0;					/* exFAT does not support SFN */
2174:ff.c          **** 
2175:ff.c          **** 	fno->fattrib = dirb[XDIR_Attr];			/* Attribute */
2176:ff.c          **** 	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
2177:ff.c          **** 	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
2178:ff.c          **** 	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
2179:ff.c          **** }
2180:ff.c          **** 
2181:ff.c          **** #endif	/* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
2182:ff.c          **** 
2183:ff.c          **** 
2184:ff.c          **** /*-----------------------------------*/
2185:ff.c          **** /* exFAT: Get a directry entry block */
2186:ff.c          **** /*-----------------------------------*/
2187:ff.c          **** 
2188:ff.c          **** static FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
2189:ff.c          **** 	DIR* dp					/* Reading direcotry object pointing top of the entry block to load */
2190:ff.c          **** )
2191:ff.c          **** {
2192:ff.c          **** 	FRESULT res;
2193:ff.c          **** 	UINT i, sz_ent;
2194:ff.c          **** 	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
2195:ff.c          **** 
2196:ff.c          **** 
2197:ff.c          **** 	/* Load file-directory entry */
2198:ff.c          **** 	res = move_window(dp->obj.fs, dp->sect);
2199:ff.c          **** 	if (res != FR_OK) return res;
2200:ff.c          **** 	if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;	/* Invalid order */
2201:ff.c          **** 	mem_cpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
2202:ff.c          **** 	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
2203:ff.c          **** 	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
2204:ff.c          **** 
2205:ff.c          **** 	/* Load stream-extension entry */
2206:ff.c          **** 	res = dir_next(dp, 0);
2207:ff.c          **** 	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
2208:ff.c          **** 	if (res != FR_OK) return res;
2209:ff.c          **** 	res = move_window(dp->obj.fs, dp->sect);
2210:ff.c          **** 	if (res != FR_OK) return res;
2211:ff.c          **** 	if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;	/* Invalid order */
2212:ff.c          **** 	mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
2213:ff.c          **** 	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
2214:ff.c          **** 
2215:ff.c          **** 	/* Load file-name entries */
2216:ff.c          **** 	i = 2 * SZDIRE;	/* Name offset to load */
2217:ff.c          **** 	do {
2218:ff.c          **** 		res = dir_next(dp, 0);
2219:ff.c          **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
2220:ff.c          **** 		if (res != FR_OK) return res;
2221:ff.c          **** 		res = move_window(dp->obj.fs, dp->sect);
2222:ff.c          **** 		if (res != FR_OK) return res;
2223:ff.c          **** 		if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;	/* Invalid order */
2224:ff.c          **** 		if (i < MAXDIRB(FF_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
2225:ff.c          **** 	} while ((i += SZDIRE) < sz_ent);
2226:ff.c          **** 
2227:ff.c          **** 	/* Sanity check (do it for only accessible object) */
2228:ff.c          **** 	if (i <= MAXDIRB(FF_MAX_LFN)) {
2229:ff.c          **** 		if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
2230:ff.c          **** 	}
2231:ff.c          **** 	return FR_OK;
2232:ff.c          **** }
2233:ff.c          **** 
2234:ff.c          **** 
2235:ff.c          **** /*------------------------------------------------------------------*/
2236:ff.c          **** /* exFAT: Initialize object allocation info with loaded entry block */
2237:ff.c          **** /*------------------------------------------------------------------*/
2238:ff.c          **** 
2239:ff.c          **** static void init_alloc_info (
2240:ff.c          **** 	FATFS* fs,		/* Filesystem object */
2241:ff.c          **** 	FFOBJID* obj	/* Object allocation information to be initialized */
2242:ff.c          **** )
2243:ff.c          **** {
2244:ff.c          **** 	obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
2245:ff.c          **** 	obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
2246:ff.c          **** 	obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
2247:ff.c          **** 	obj->n_frag = 0;										/* No last fragment info */
2248:ff.c          **** }
2249:ff.c          **** 
2250:ff.c          **** 
2251:ff.c          **** 
2252:ff.c          **** #if !FF_FS_READONLY || FF_FS_RPATH != 0
2253:ff.c          **** /*------------------------------------------------*/
2254:ff.c          **** /* exFAT: Load the object's directory entry block */
2255:ff.c          **** /*------------------------------------------------*/
2256:ff.c          **** 
2257:ff.c          **** static FRESULT load_obj_xdir (
2258:ff.c          **** 	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
2259:ff.c          **** 	const FFOBJID* obj	/* Object with its containing directory information */
2260:ff.c          **** )
2261:ff.c          **** {
2262:ff.c          **** 	FRESULT res;
2263:ff.c          **** 
2264:ff.c          **** 	/* Open object containing directory */
2265:ff.c          **** 	dp->obj.fs = obj->fs;
2266:ff.c          **** 	dp->obj.sclust = obj->c_scl;
2267:ff.c          **** 	dp->obj.stat = (BYTE)obj->c_size;
2268:ff.c          **** 	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
2269:ff.c          **** 	dp->obj.n_frag = 0;
2270:ff.c          **** 	dp->blk_ofs = obj->c_ofs;
2271:ff.c          **** 
2272:ff.c          **** 	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
2273:ff.c          **** 	if (res == FR_OK) {
2274:ff.c          **** 		res = load_xdir(dp);		/* Load the object's entry block */
2275:ff.c          **** 	}
2276:ff.c          **** 	return res;
2277:ff.c          **** }
2278:ff.c          **** #endif
2279:ff.c          **** 
2280:ff.c          **** 
2281:ff.c          **** #if !FF_FS_READONLY
2282:ff.c          **** /*----------------------------------------*/
2283:ff.c          **** /* exFAT: Store the directory entry block */
2284:ff.c          **** /*----------------------------------------*/
2285:ff.c          **** 
2286:ff.c          **** static FRESULT store_xdir (
2287:ff.c          **** 	DIR* dp				/* Pointer to the direcotry object */
2288:ff.c          **** )
2289:ff.c          **** {
2290:ff.c          **** 	FRESULT res;
2291:ff.c          **** 	UINT nent;
2292:ff.c          **** 	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
2293:ff.c          **** 
2294:ff.c          **** 	/* Create set sum */
2295:ff.c          **** 	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
2296:ff.c          **** 	nent = dirb[XDIR_NumSec] + 1;
2297:ff.c          **** 
2298:ff.c          **** 	/* Store the direcotry entry block to the directory */
2299:ff.c          **** 	res = dir_sdi(dp, dp->blk_ofs);
2300:ff.c          **** 	while (res == FR_OK) {
2301:ff.c          **** 		res = move_window(dp->obj.fs, dp->sect);
2302:ff.c          **** 		if (res != FR_OK) break;
2303:ff.c          **** 		mem_cpy(dp->dir, dirb, SZDIRE);
2304:ff.c          **** 		dp->obj.fs->wflag = 1;
2305:ff.c          **** 		if (--nent == 0) break;
2306:ff.c          **** 		dirb += SZDIRE;
2307:ff.c          **** 		res = dir_next(dp, 0);
2308:ff.c          **** 	}
2309:ff.c          **** 	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
2310:ff.c          **** }
2311:ff.c          **** 
2312:ff.c          **** 
2313:ff.c          **** 
2314:ff.c          **** /*-------------------------------------------*/
2315:ff.c          **** /* exFAT: Create a new directory enrty block */
2316:ff.c          **** /*-------------------------------------------*/
2317:ff.c          **** 
2318:ff.c          **** static void create_xdir (
2319:ff.c          **** 	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
2320:ff.c          **** 	const WCHAR* lfn	/* Pointer to the object name */
2321:ff.c          **** )
2322:ff.c          **** {
2323:ff.c          **** 	UINT i;
2324:ff.c          **** 	BYTE nc1, nlen;
2325:ff.c          **** 	WCHAR wc;
2326:ff.c          **** 
2327:ff.c          **** 
2328:ff.c          **** 	/* Create file-directory and stream-extension entry */
2329:ff.c          **** 	mem_set(dirb, 0, 2 * SZDIRE);
2330:ff.c          **** 	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
2331:ff.c          **** 	dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
2332:ff.c          **** 
2333:ff.c          **** 	/* Create file-name entries */
2334:ff.c          **** 	i = SZDIRE * 2;	/* Top of file_name entries */
2335:ff.c          **** 	nlen = nc1 = 0; wc = 1;
2336:ff.c          **** 	do {
2337:ff.c          **** 		dirb[i++] = ET_FILENAME; dirb[i++] = 0;
2338:ff.c          **** 		do {	/* Fill name field */
2339:ff.c          **** 			if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
2340:ff.c          **** 			st_word(dirb + i, wc); 		/* Store it */
2341:ff.c          **** 			i += 2;
2342:ff.c          **** 		} while (i % SZDIRE != 0);
2343:ff.c          **** 		nc1++;
2344:ff.c          **** 	} while (lfn[nlen]);	/* Fill next entry if any char follows */
2345:ff.c          **** 
2346:ff.c          **** 	dirb[XDIR_NumName] = nlen;		/* Set name length */
2347:ff.c          **** 	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
2348:ff.c          **** 	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
2349:ff.c          **** }
2350:ff.c          **** 
2351:ff.c          **** #endif	/* !FF_FS_READONLY */
2352:ff.c          **** #endif	/* FF_FS_EXFAT */
2353:ff.c          **** 
2354:ff.c          **** 
2355:ff.c          **** 
2356:ff.c          **** #if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT
2357:ff.c          **** /*-----------------------------------------------------------------------*/
2358:ff.c          **** /* Read an object from the directory                                     */
2359:ff.c          **** /*-----------------------------------------------------------------------*/
2360:ff.c          **** 
2361:ff.c          **** #define DIR_READ_FILE(dp) dir_read(dp, 0)
2362:ff.c          **** #define DIR_READ_LABEL(dp) dir_read(dp, 1)
2363:ff.c          **** 
2364:ff.c          **** static FRESULT dir_read (
2365:ff.c          **** 	DIR* dp,		/* Pointer to the directory object */
2366:ff.c          **** 	int vol			/* Filtered by 0:file/directory or 1:volume label */
2367:ff.c          **** )
2368:ff.c          **** {
2369:ff.c          **** 	FRESULT res = FR_NO_FILE;
2370:ff.c          **** 	FATFS *fs = dp->obj.fs;
2371:ff.c          **** 	BYTE attr, b;
2372:ff.c          **** #if FF_USE_LFN
2373:ff.c          **** 	BYTE ord = 0xFF, sum = 0xFF;
2374:ff.c          **** #endif
2375:ff.c          **** 
2376:ff.c          **** 	while (dp->sect) {
2377:ff.c          **** 		res = move_window(fs, dp->sect);
2378:ff.c          **** 		if (res != FR_OK) break;
2379:ff.c          **** 		b = dp->dir[DIR_Name];	/* Test for the entry type */
2380:ff.c          **** 		if (b == 0) {
2381:ff.c          **** 			res = FR_NO_FILE; break; /* Reached to end of the directory */
2382:ff.c          **** 		}
2383:ff.c          **** #if FF_FS_EXFAT
2384:ff.c          **** 		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
2385:ff.c          **** 			if (FF_USE_LABEL && vol) {
2386:ff.c          **** 				if (b == ET_VLABEL) break;	/* Volume label entry? */
2387:ff.c          **** 			} else {
2388:ff.c          **** 				if (b == ET_FILEDIR) {		/* Start of the file entry block? */
2389:ff.c          **** 					dp->blk_ofs = dp->dptr;	/* Get location of the block */
2390:ff.c          **** 					res = load_xdir(dp);	/* Load the entry block */
2391:ff.c          **** 					if (res == FR_OK) {
2392:ff.c          **** 						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
2393:ff.c          **** 					}
2394:ff.c          **** 					break;
2395:ff.c          **** 				}
2396:ff.c          **** 			}
2397:ff.c          **** 		} else
2398:ff.c          **** #endif
2399:ff.c          **** 		{	/* On the FAT/FAT32 volume */
2400:ff.c          **** 			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
2401:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2402:ff.c          **** 			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without val
2403:ff.c          **** 				ord = 0xFF;
2404:ff.c          **** 			} else {
2405:ff.c          **** 				if (attr == AM_LFN) {			/* An LFN entry is found */
2406:ff.c          **** 					if (b & LLEF) {			/* Is it start of an LFN sequence? */
2407:ff.c          **** 						sum = dp->dir[LDIR_Chksum];
2408:ff.c          **** 						b &= (BYTE)~LLEF; ord = b;
2409:ff.c          **** 						dp->blk_ofs = dp->dptr;
2410:ff.c          **** 					}
2411:ff.c          **** 					/* Check LFN validity and capture it */
2412:ff.c          **** 					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0
2413:ff.c          **** 				} else {					/* An SFN entry is found */
2414:ff.c          **** 					if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
2415:ff.c          **** 						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
2416:ff.c          **** 					}
2417:ff.c          **** 					break;
2418:ff.c          **** 				}
2419:ff.c          **** 			}
2420:ff.c          **** #else		/* Non LFN configuration */
2421:ff.c          **** 			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is
2422:ff.c          **** 				break;
2423:ff.c          **** 			}
2424:ff.c          **** #endif
2425:ff.c          **** 		}
2426:ff.c          **** 		res = dir_next(dp, 0);		/* Next entry */
2427:ff.c          **** 		if (res != FR_OK) break;
2428:ff.c          **** 	}
2429:ff.c          **** 
2430:ff.c          **** 	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
2431:ff.c          **** 	return res;
2432:ff.c          **** }
2433:ff.c          **** 
2434:ff.c          **** #endif	/* FF_FS_MINIMIZE <= 1 || FF_USE_LABEL || FF_FS_RPATH >= 2 */
2435:ff.c          **** 
2436:ff.c          **** 
2437:ff.c          **** 
2438:ff.c          **** /*-----------------------------------------------------------------------*/
2439:ff.c          **** /* Directory handling - Find an object in the directory                  */
2440:ff.c          **** /*-----------------------------------------------------------------------*/
2441:ff.c          **** 
2442:ff.c          **** static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
2443:ff.c          **** 	DIR* dp					/* Pointer to the directory object with the file name */
2444:ff.c          **** )
2445:ff.c          **** {
2446:ff.c          **** 	FRESULT res;
2447:ff.c          **** 	FATFS *fs = dp->obj.fs;
2448:ff.c          **** 	BYTE c;
2449:ff.c          **** #if FF_USE_LFN
2450:ff.c          **** 	BYTE a, ord, sum;
2451:ff.c          **** #endif
2452:ff.c          **** 
2453:ff.c          **** 	res = dir_sdi(dp, 0);			/* Rewind directory object */
2454:ff.c          **** 	if (res != FR_OK) return res;
2455:ff.c          **** #if FF_FS_EXFAT
2456:ff.c          **** 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
2457:ff.c          **** 		BYTE nc;
2458:ff.c          **** 		UINT di, ni;
2459:ff.c          **** 		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
2460:ff.c          **** 
2461:ff.c          **** 		while ((res = DIR_READ_FILE(dp)) == FR_OK) {	/* Read an item */
2462:ff.c          **** #if FF_MAX_LFN < 255
2463:ff.c          **** 			if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;			/* Skip comparison if inaccessible object
2464:ff.c          **** #endif
2465:ff.c          **** 			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched
2466:ff.c          **** 			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compa
2467:ff.c          **** 				if ((di % SZDIRE) == 0) di += 2;
2468:ff.c          **** 				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
2469:ff.c          **** 			}
2470:ff.c          **** 			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
2471:ff.c          **** 		}
2472:ff.c          **** 		return res;
2473:ff.c          **** 	}
2474:ff.c          **** #endif
2475:ff.c          **** 	/* On the FAT/FAT32 volume */
2476:ff.c          **** #if FF_USE_LFN
2477:ff.c          **** 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
2478:ff.c          **** #endif
2479:ff.c          **** 	do {
2480:ff.c          **** 		res = move_window(fs, dp->sect);
2481:ff.c          **** 		if (res != FR_OK) break;
2482:ff.c          **** 		c = dp->dir[DIR_Name];
2483:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
2484:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2485:ff.c          **** 		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
2486:ff.c          **** 		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
2487:ff.c          **** 			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
2488:ff.c          **** 		} else {
2489:ff.c          **** 			if (a == AM_LFN) {			/* An LFN entry is found */
2490:ff.c          **** 				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
2491:ff.c          **** 					if (c & LLEF) {		/* Is it start of LFN sequence? */
2492:ff.c          **** 						sum = dp->dir[LDIR_Chksum];
2493:ff.c          **** 						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
2494:ff.c          **** 						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
2495:ff.c          **** 					}
2496:ff.c          **** 					/* Check validity of the LFN entry and compare it with given name */
2497:ff.c          **** 					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0x
2498:ff.c          **** 				}
2499:ff.c          **** 			} else {					/* An SFN entry is found */
2500:ff.c          **** 				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
2501:ff.c          **** 				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
2502:ff.c          **** 				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
2503:ff.c          **** 			}
2504:ff.c          **** 		}
2505:ff.c          **** #else		/* Non LFN configuration */
2506:ff.c          **** 		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
2507:ff.c          **** 		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry
2508:ff.c          **** #endif
2509:ff.c          **** 		res = dir_next(dp, 0);	/* Next entry */
2510:ff.c          **** 	} while (res == FR_OK);
2511:ff.c          **** 
2512:ff.c          **** 	return res;
2513:ff.c          **** }
2514:ff.c          **** 
2515:ff.c          **** 
2516:ff.c          **** 
2517:ff.c          **** 
2518:ff.c          **** #if !FF_FS_READONLY
2519:ff.c          **** /*-----------------------------------------------------------------------*/
2520:ff.c          **** /* Register an object to the directory                                   */
2521:ff.c          **** /*-----------------------------------------------------------------------*/
2522:ff.c          **** 
2523:ff.c          **** static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision
2524:ff.c          **** 	DIR* dp						/* Target directory with object name to be created */
2525:ff.c          **** )
2526:ff.c          **** {
2527:ff.c          **** 	FRESULT res;
2528:ff.c          **** 	FATFS *fs = dp->obj.fs;
2529:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2530:ff.c          **** 	UINT n, len, n_ent;
2531:ff.c          **** 	BYTE sn[12], sum;
2532:ff.c          **** 
2533:ff.c          **** 
2534:ff.c          **** 	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
2535:ff.c          **** 	for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get lfn length */
2536:ff.c          **** 
2537:ff.c          **** #if FF_FS_EXFAT
2538:ff.c          **** 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
2539:ff.c          **** 		n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
2540:ff.c          **** 		res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
2541:ff.c          **** 		if (res != FR_OK) return res;
2542:ff.c          **** 		dp->blk_ofs = dp->dptr - SZDIRE * (n_ent - 1);	/* Set the allocated entry block offset */
2543:ff.c          **** 
2544:ff.c          **** 		if (dp->obj.stat & 4) {			/* Has the directory been stretched by new allocation? */
2545:ff.c          **** 			dp->obj.stat &= ~4;
2546:ff.c          **** 			res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
2547:ff.c          **** 			if (res != FR_OK) return res;
2548:ff.c          **** 			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if n
2549:ff.c          **** 			if (res != FR_OK) return res;
2550:ff.c          **** 			if (dp->obj.sclust != 0) {		/* Is it a sub-directory? */
2551:ff.c          **** 				DIR dj;
2552:ff.c          **** 
2553:ff.c          **** 				res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
2554:ff.c          **** 				if (res != FR_OK) return res;
2555:ff.c          **** 				dp->obj.objsize += (DWORD)fs->csize * SS(fs);			/* Increase the directory size by cluster size 
2556:ff.c          **** 				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
2557:ff.c          **** 				st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
2558:ff.c          **** 				fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;			/* Update the allocation status */
2559:ff.c          **** 				res = store_xdir(&dj);				/* Store the object status */
2560:ff.c          **** 				if (res != FR_OK) return res;
2561:ff.c          **** 			}
2562:ff.c          **** 		}
2563:ff.c          **** 
2564:ff.c          **** 		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
2565:ff.c          **** 		return FR_OK;
2566:ff.c          **** 	}
2567:ff.c          **** #endif
2568:ff.c          **** 	/* On the FAT/FAT32 volume */
2569:ff.c          **** 	mem_cpy(sn, dp->fn, 12);
2570:ff.c          **** 	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
2571:ff.c          **** 		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
2572:ff.c          **** 		for (n = 1; n < 100; n++) {
2573:ff.c          **** 			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
2574:ff.c          **** 			res = dir_find(dp);				/* Check if the name collides with existing SFN */
2575:ff.c          **** 			if (res != FR_OK) break;
2576:ff.c          **** 		}
2577:ff.c          **** 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
2578:ff.c          **** 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
2579:ff.c          **** 		dp->fn[NSFLAG] = sn[NSFLAG];
2580:ff.c          **** 	}
2581:ff.c          **** 
2582:ff.c          **** 	/* Create an SFN with/without LFNs. */
2583:ff.c          **** 	n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
2584:ff.c          **** 	res = dir_alloc(dp, n_ent);		/* Allocate entries */
2585:ff.c          **** 	if (res == FR_OK && --n_ent) {	/* Set LFN entry if needed */
2586:ff.c          **** 		res = dir_sdi(dp, dp->dptr - n_ent * SZDIRE);
2587:ff.c          **** 		if (res == FR_OK) {
2588:ff.c          **** 			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
2589:ff.c          **** 			do {					/* Store LFN entries in bottom first */
2590:ff.c          **** 				res = move_window(fs, dp->sect);
2591:ff.c          **** 				if (res != FR_OK) break;
2592:ff.c          **** 				put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
2593:ff.c          **** 				fs->wflag = 1;
2594:ff.c          **** 				res = dir_next(dp, 0);	/* Next entry */
2595:ff.c          **** 			} while (res == FR_OK && --n_ent);
2596:ff.c          **** 		}
2597:ff.c          **** 	}
2598:ff.c          **** 
2599:ff.c          **** #else	/* Non LFN configuration */
2600:ff.c          **** 	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
2601:ff.c          **** 
2602:ff.c          **** #endif
2603:ff.c          **** 
2604:ff.c          **** 	/* Set SFN entry */
2605:ff.c          **** 	if (res == FR_OK) {
2606:ff.c          **** 		res = move_window(fs, dp->sect);
2607:ff.c          **** 		if (res == FR_OK) {
2608:ff.c          **** 			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
2609:ff.c          **** 			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
2610:ff.c          **** #if FF_USE_LFN
2611:ff.c          **** 			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
2612:ff.c          **** #endif
2613:ff.c          **** 			fs->wflag = 1;
2614:ff.c          **** 		}
2615:ff.c          **** 	}
2616:ff.c          **** 
2617:ff.c          **** 	return res;
2618:ff.c          **** }
2619:ff.c          **** 
2620:ff.c          **** #endif /* !FF_FS_READONLY */
2621:ff.c          **** 
2622:ff.c          **** 
2623:ff.c          **** 
2624:ff.c          **** #if !FF_FS_READONLY && FF_FS_MINIMIZE == 0
2625:ff.c          **** /*-----------------------------------------------------------------------*/
2626:ff.c          **** /* Remove an object from the directory                                   */
2627:ff.c          **** /*-----------------------------------------------------------------------*/
2628:ff.c          **** 
2629:ff.c          **** static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
2630:ff.c          **** 	DIR* dp					/* Directory object pointing the entry to be removed */
2631:ff.c          **** )
2632:ff.c          **** {
2633:ff.c          **** 	FRESULT res;
2634:ff.c          **** 	FATFS *fs = dp->obj.fs;
2635:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2636:ff.c          **** 	DWORD last = dp->dptr;
2637:ff.c          **** 
2638:ff.c          **** 	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry blo
2639:ff.c          **** 	if (res == FR_OK) {
2640:ff.c          **** 		do {
2641:ff.c          **** 			res = move_window(fs, dp->sect);
2642:ff.c          **** 			if (res != FR_OK) break;
2643:ff.c          **** 			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
2644:ff.c          **** 				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
2645:ff.c          **** 			} else {									/* On the FAT/FAT32 volume */
2646:ff.c          **** 				dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'. */
2647:ff.c          **** 			}
2648:ff.c          **** 			fs->wflag = 1;
2649:ff.c          **** 			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been de
2650:ff.c          **** 			res = dir_next(dp, 0);	/* Next entry */
2651:ff.c          **** 		} while (res == FR_OK);
2652:ff.c          **** 		if (res == FR_NO_FILE) res = FR_INT_ERR;
2653:ff.c          **** 	}
2654:ff.c          **** #else			/* Non LFN configuration */
2655:ff.c          **** 
2656:ff.c          **** 	res = move_window(fs, dp->sect);
2657:ff.c          **** 	if (res == FR_OK) {
2658:ff.c          **** 		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
2659:ff.c          **** 		fs->wflag = 1;
2660:ff.c          **** 	}
2661:ff.c          **** #endif
2662:ff.c          **** 
2663:ff.c          **** 	return res;
2664:ff.c          **** }
2665:ff.c          **** 
2666:ff.c          **** #endif /* !FF_FS_READONLY && FF_FS_MINIMIZE == 0 */
2667:ff.c          **** 
2668:ff.c          **** 
2669:ff.c          **** 
2670:ff.c          **** #if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2
2671:ff.c          **** /*-----------------------------------------------------------------------*/
2672:ff.c          **** /* Get file information from directory entry                             */
2673:ff.c          **** /*-----------------------------------------------------------------------*/
2674:ff.c          **** 
2675:ff.c          **** static void get_fileinfo (
2676:ff.c          **** 	DIR* dp,			/* Pointer to the directory object */
2677:ff.c          **** 	FILINFO* fno		/* Pointer to the file information to be filled */
2678:ff.c          **** )
2679:ff.c          **** {
2680:ff.c          **** 	UINT si, di;
2681:ff.c          **** #if FF_USE_LFN
2682:ff.c          **** 	BYTE lcf;
2683:ff.c          **** 	WCHAR wc, hs;
2684:ff.c          **** 	FATFS *fs = dp->obj.fs;
2685:ff.c          **** #else
2686:ff.c          **** 	TCHAR c;
2687:ff.c          **** #endif
2688:ff.c          **** 
2689:ff.c          **** 
2690:ff.c          **** 	fno->fname[0] = 0;			/* Invaidate file info */
2691:ff.c          **** 	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
2692:ff.c          **** 
2693:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2694:ff.c          **** #if FF_FS_EXFAT
2695:ff.c          **** 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
2696:ff.c          **** 		get_xfileinfo(fs->dirbuf, fno);
2697:ff.c          **** 		return;
2698:ff.c          **** 	} else
2699:ff.c          **** #endif
2700:ff.c          **** 	{	/* On the FAT/FAT32 volume */
2701:ff.c          **** 		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
2702:ff.c          **** 			si = di = hs = 0;
2703:ff.c          **** 			while (fs->lfnbuf[si] != 0) {
2704:ff.c          **** 				wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
2705:ff.c          **** 				if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
2706:ff.c          **** 					hs = wc; continue;		/* Get low surrogate */
2707:ff.c          **** 				}
2708:ff.c          **** 				wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or 
2709:ff.c          **** 				if (wc == 0) { di = 0; break; }	/* Invalid char or buffer overflow? */
2710:ff.c          **** 				di += wc;
2711:ff.c          **** 				hs = 0;
2712:ff.c          **** 			}
2713:ff.c          **** 			if (hs != 0) di = 0;	/* Broken surrogate pair? */
2714:ff.c          **** 			fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
2715:ff.c          **** 		}
2716:ff.c          **** 	}
2717:ff.c          **** 
2718:ff.c          **** 	si = di = 0;
2719:ff.c          **** 	while (si < 11) {		/* Get SFN from SFN entry */
2720:ff.c          **** 		wc = dp->dir[si++];			/* Get a char */
2721:ff.c          **** 		if (wc == ' ') continue;	/* Skip padding spaces */
2722:ff.c          **** 		if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
2723:ff.c          **** 		if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
2724:ff.c          **** #if FF_LFN_UNICODE >= 1	/* Unicode output */
2725:ff.c          **** 		if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) {	/* Make a DBC if needed *
2726:ff.c          **** 			wc = wc << 8 | dp->dir[si++];
2727:ff.c          **** 		}
2728:ff.c          **** 		wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
2729:ff.c          **** 		if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
2730:ff.c          **** 		wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
2731:ff.c          **** 		if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
2732:ff.c          **** 		di += wc;
2733:ff.c          **** #else					/* ANSI/OEM output */
2734:ff.c          **** 		fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
2735:ff.c          **** #endif
2736:ff.c          **** 	}
2737:ff.c          **** 	fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
2738:ff.c          **** 
2739:ff.c          **** 	if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
2740:ff.c          **** 		if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
2741:ff.c          **** 			fno->fname[di++] = '?';
2742:ff.c          **** 		} else {
2743:ff.c          **** 			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] wi
2744:ff.c          **** 				wc = (WCHAR)fno->altname[si];
2745:ff.c          **** 				if (wc == '.') lcf = NS_EXT;
2746:ff.c          **** 				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
2747:ff.c          **** 				fno->fname[di] = (TCHAR)wc;
2748:ff.c          **** 			}
2749:ff.c          **** 		}
2750:ff.c          **** 		fno->fname[di] = 0;	/* Terminate the LFN */
2751:ff.c          **** 		if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case in
2752:ff.c          **** 	}
2753:ff.c          **** 
2754:ff.c          **** #else	/* Non-LFN configuration */
2755:ff.c          **** 	si = di = 0;
2756:ff.c          **** 	while (si < 11) {		/* Copy name body and extension */
2757:ff.c          **** 		c = (TCHAR)dp->dir[si++];
2758:ff.c          **** 		if (c == ' ') continue;		/* Skip padding spaces */
2759:ff.c          **** 		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
2760:ff.c          **** 		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
2761:ff.c          **** 		fno->fname[di++] = c;
2762:ff.c          **** 	}
2763:ff.c          **** 	fno->fname[di] = 0;
2764:ff.c          **** #endif
2765:ff.c          **** 
2766:ff.c          **** 	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
2767:ff.c          **** 	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
2768:ff.c          **** 	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
2769:ff.c          **** 	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
2770:ff.c          **** }
2771:ff.c          **** 
2772:ff.c          **** #endif /* FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 */
2773:ff.c          **** 
2774:ff.c          **** 
2775:ff.c          **** 
2776:ff.c          **** #if FF_USE_FIND && FF_FS_MINIMIZE <= 1
2777:ff.c          **** /*-----------------------------------------------------------------------*/
2778:ff.c          **** /* Pattern matching                                                      */
2779:ff.c          **** /*-----------------------------------------------------------------------*/
2780:ff.c          **** 
2781:ff.c          **** #define FIND_RECURS	4	/* Maximum number of wildcard terms in the pattern to limit recursion */
2782:ff.c          **** 
2783:ff.c          **** 
2784:ff.c          **** static DWORD get_achar (	/* Get a character and advance ptr */
2785:ff.c          **** 	const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
2786:ff.c          **** )
2787:ff.c          **** {
2788:ff.c          **** 	DWORD chr;
2789:ff.c          **** 
2790:ff.c          **** 
2791:ff.c          **** #if FF_USE_LFN && FF_LFN_UNICODE >= 1	/* Unicode input */
2792:ff.c          **** 	chr = tchar2uni(ptr);
2793:ff.c          **** 	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
2794:ff.c          **** 	chr = ff_wtoupper(chr);
2795:ff.c          **** 
2796:ff.c          **** #else									/* ANSI/OEM input */
2797:ff.c          **** 	chr = (BYTE)*(*ptr)++;				/* Get a byte */
2798:ff.c          **** 	if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
2799:ff.c          **** #if FF_CODE_PAGE == 0
2800:ff.c          **** 	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
2801:ff.c          **** #elif FF_CODE_PAGE < 900
2802:ff.c          **** 	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
2803:ff.c          **** #endif
2804:ff.c          **** #if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900
2805:ff.c          **** 	if (dbc_1st((BYTE)chr)) {	/* Get DBC 2nd byte if needed */
2806:ff.c          **** 		chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
2807:ff.c          **** 	}
2808:ff.c          **** #endif
2809:ff.c          **** 
2810:ff.c          **** #endif
2811:ff.c          **** 	return chr;
2812:ff.c          **** }
2813:ff.c          **** 
2814:ff.c          **** 
2815:ff.c          **** static int pattern_match (	/* 0:mismatched, 1:matched */
2816:ff.c          **** 	const TCHAR* pat,	/* Matching pattern */
2817:ff.c          **** 	const TCHAR* nam,	/* String to be tested */
2818:ff.c          **** 	UINT skip,			/* Number of pre-skip chars (number of ?s, b8:infinite (* specified)) */
2819:ff.c          **** 	UINT recur			/* Recursion count */
2820:ff.c          **** )
2821:ff.c          **** {
2822:ff.c          **** 	const TCHAR *pptr, *nptr;
2823:ff.c          **** 	DWORD pchr, nchr;
2824:ff.c          **** 	UINT sk;
2825:ff.c          **** 
2826:ff.c          **** 
2827:ff.c          **** 	while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
2828:ff.c          **** 		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
2829:ff.c          **** 		skip--;
2830:ff.c          **** 	}
2831:ff.c          **** 	if (*pat == 0 && skip) return 1;	/* Matched? (short circuit) */
2832:ff.c          **** 
2833:ff.c          **** 	do {
2834:ff.c          **** 		pptr = pat; nptr = nam;			/* Top of pattern and name to match */
2835:ff.c          **** 		for (;;) {
2836:ff.c          **** 			if (*pptr == '?' || *pptr == '*') {	/* Wildcard term? */
2837:ff.c          **** 				if (recur == 0) return 0;	/* Too many wildcard terms? */
2838:ff.c          **** 				sk = 0;
2839:ff.c          **** 				do {	/* Analyze the wildcard term */
2840:ff.c          **** 					if (*pptr++ == '?') sk++; else sk |= 0x100;
2841:ff.c          **** 				} while (*pptr == '?' || *pptr == '*');
2842:ff.c          **** 				if (pattern_match(pptr, nptr, sk, recur - 1)) return 1;	/* Test new branch (recursive call) */
2843:ff.c          **** 				nchr = *nptr; break;	/* Branch mismatched */
2844:ff.c          **** 			}
2845:ff.c          **** 			pchr = get_achar(&pptr);	/* Get a pattern char */
2846:ff.c          **** 			nchr = get_achar(&nptr);	/* Get a name char */
2847:ff.c          **** 			if (pchr != nchr) break;	/* Branch mismatched? */
2848:ff.c          **** 			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
2849:ff.c          **** 		}
2850:ff.c          **** 		get_achar(&nam);			/* nam++ */
2851:ff.c          **** 	} while (skip && nchr);		/* Retry until end of name if infinite search is specified */
2852:ff.c          **** 
2853:ff.c          **** 	return 0;
2854:ff.c          **** }
2855:ff.c          **** 
2856:ff.c          **** #endif /* FF_USE_FIND && FF_FS_MINIMIZE <= 1 */
2857:ff.c          **** 
2858:ff.c          **** 
2859:ff.c          **** 
2860:ff.c          **** /*-----------------------------------------------------------------------*/
2861:ff.c          **** /* Pick a top segment and create the object name in directory form       */
2862:ff.c          **** /*-----------------------------------------------------------------------*/
2863:ff.c          **** 
2864:ff.c          **** static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
2865:ff.c          **** 	DIR* dp,					/* Pointer to the directory object */
2866:ff.c          **** 	const TCHAR** path			/* Pointer to pointer to the segment in the path string */
2867:ff.c          **** )
2868:ff.c          **** {
2869:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
2870:ff.c          **** 	BYTE b, cf;
2871:ff.c          **** 	WCHAR wc, *lfn;
2872:ff.c          **** 	DWORD uc;
2873:ff.c          **** 	UINT i, ni, si, di;
2874:ff.c          **** 	const TCHAR *p;
2875:ff.c          **** 
2876:ff.c          **** 
2877:ff.c          **** 	/* Create LFN into LFN working buffer */
2878:ff.c          **** 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
2879:ff.c          **** 	for (;;) {
2880:ff.c          **** 		uc = tchar2uni(&p);			/* Get a character */
2881:ff.c          **** 		if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
2882:ff.c          **** 		if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
2883:ff.c          **** 		wc = (WCHAR)uc;
2884:ff.c          **** 		if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is fou
2885:ff.c          **** 		if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characte
2886:ff.c          **** 		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
2887:ff.c          **** 		lfn[di++] = wc;					/* Store the Unicode character */
2888:ff.c          **** 	}
2889:ff.c          **** 	if (wc < ' ') {				/* End of path? */
2890:ff.c          **** 		cf = NS_LAST;			/* Set last segment flag */
2891:ff.c          **** 	} else {
2892:ff.c          **** 		cf = 0;					/* Next segment follows */
2893:ff.c          **** 		while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
2894:ff.c          **** 	}
2895:ff.c          **** 	*path = p;					/* Return pointer to the next segment */
2896:ff.c          **** 
2897:ff.c          **** #if FF_FS_RPATH != 0
2898:ff.c          **** 	if ((di == 1 && lfn[di - 1] == '.') ||
2899:ff.c          **** 		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
2900:ff.c          **** 		lfn[di] = 0;
2901:ff.c          **** 		for (i = 0; i < 11; i++) {		/* Create dot name for SFN entry */
2902:ff.c          **** 			dp->fn[i] = (i < di) ? '.' : ' ';
2903:ff.c          **** 		}
2904:ff.c          **** 		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
2905:ff.c          **** 		return FR_OK;
2906:ff.c          **** 	}
2907:ff.c          **** #endif
2908:ff.c          **** 	while (di) {						/* Snip off trailing spaces and dots if exist */
2909:ff.c          **** 		wc = lfn[di - 1];
2910:ff.c          **** 		if (wc != ' ' && wc != '.') break;
2911:ff.c          **** 		di--;
2912:ff.c          **** 	}
2913:ff.c          **** 	lfn[di] = 0;							/* LFN is created into the working buffer */
2914:ff.c          **** 	if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
2915:ff.c          **** 
2916:ff.c          **** 	/* Create SFN in directory form */
2917:ff.c          **** 	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
2918:ff.c          **** 	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
2919:ff.c          **** 	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
2920:ff.c          **** 
2921:ff.c          **** 	mem_set(dp->fn, ' ', 11);
2922:ff.c          **** 	i = b = 0; ni = 8;
2923:ff.c          **** 	for (;;) {
2924:ff.c          **** 		wc = lfn[si++];					/* Get an LFN character */
2925:ff.c          **** 		if (wc == 0) break;				/* Break on end of the LFN */
2926:ff.c          **** 		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
2927:ff.c          **** 			cf |= NS_LOSS | NS_LFN;
2928:ff.c          **** 			continue;
2929:ff.c          **** 		}
2930:ff.c          **** 
2931:ff.c          **** 		if (i >= ni || si == di) {		/* End of field? */
2932:ff.c          **** 			if (ni == 11) {				/* Name extension overflow? */
2933:ff.c          **** 				cf |= NS_LOSS | NS_LFN;
2934:ff.c          **** 				break;
2935:ff.c          **** 			}
2936:ff.c          **** 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
2937:ff.c          **** 			if (si > di) break;						/* No name extension? */
2938:ff.c          **** 			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
2939:ff.c          **** 			continue;
2940:ff.c          **** 		}
2941:ff.c          **** 
2942:ff.c          **** 		if (wc >= 0x80) {	/* Is this a non-ASCII character? */
2943:ff.c          **** 			cf |= NS_LFN;	/* LFN entry needs to be created */
2944:ff.c          **** #if FF_CODE_PAGE == 0
2945:ff.c          **** 			if (ExCvt) {	/* At SBCS */
2946:ff.c          **** 				wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
2947:ff.c          **** 				if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
2948:ff.c          **** 			} else {		/* At DBCS */
2949:ff.c          **** 				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
2950:ff.c          **** 			}
2951:ff.c          **** #elif FF_CODE_PAGE < 900	/* SBCS cfg */
2952:ff.c          **** 			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
2953:ff.c          **** 			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
2954:ff.c          **** #else						/* DBCS cfg */
2955:ff.c          **** 			wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
2956:ff.c          **** #endif
2957:ff.c          **** 		}
2958:ff.c          **** 
2959:ff.c          **** 		if (wc >= 0x100) {				/* Is this a DBC? */
2960:ff.c          **** 			if (i >= ni - 1) {			/* Field overflow? */
2961:ff.c          **** 				cf |= NS_LOSS | NS_LFN;
2962:ff.c          **** 				i = ni; continue;		/* Next field */
2963:ff.c          **** 			}
2964:ff.c          **** 			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
2965:ff.c          **** 		} else {						/* SBC */
2966:ff.c          **** 			if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
2967:ff.c          **** 				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
2968:ff.c          **** 			} else {
2969:ff.c          **** 				if (IsUpper(wc)) {		/* ASCII upper case? */
2970:ff.c          **** 					b |= 2;
2971:ff.c          **** 				}
2972:ff.c          **** 				if (IsLower(wc)) {		/* ASCII lower case? */
2973:ff.c          **** 					b |= 1; wc -= 0x20;
2974:ff.c          **** 				}
2975:ff.c          **** 			}
2976:ff.c          **** 		}
2977:ff.c          **** 		dp->fn[i++] = (BYTE)wc;
2978:ff.c          **** 	}
2979:ff.c          **** 
2980:ff.c          **** 	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it
2981:ff.c          **** 
2982:ff.c          **** 	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
2983:ff.c          **** 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if co
2984:ff.c          **** 	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are cre
2985:ff.c          **** 		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
2986:ff.c          **** 		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
2987:ff.c          **** 	}
2988:ff.c          **** 
2989:ff.c          **** 	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
2990:ff.c          **** 
2991:ff.c          **** 	return FR_OK;
2992:ff.c          **** 
2993:ff.c          **** 
2994:ff.c          **** #else	/* FF_USE_LFN : Non-LFN configuration */
2995:ff.c          **** 	BYTE c, d, *sfn;
2996:ff.c          **** 	UINT ni, si, i;
2997:ff.c          **** 	const char *p;
2998:ff.c          **** 
2999:ff.c          **** 	/* Create file name in directory form */
3000:ff.c          **** 	p = *path; sfn = dp->fn;
3001:ff.c          **** 	mem_set(sfn, ' ', 11);
3002:ff.c          **** 	si = i = 0; ni = 8;
3003:ff.c          **** #if FF_FS_RPATH != 0
3004:ff.c          **** 	if (p[si] == '.') { /* Is this a dot entry? */
3005:ff.c          **** 		for (;;) {
3006:ff.c          **** 			c = (BYTE)p[si++];
3007:ff.c          **** 			if (c != '.' || si >= 3) break;
3008:ff.c          **** 			sfn[i++] = c;
3009:ff.c          **** 		}
3010:ff.c          **** 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
3011:ff.c          **** 		*path = p + si;								/* Return pointer to the next segment */
3012:ff.c          **** 		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of the path
3013:ff.c          **** 		return FR_OK;
3014:ff.c          **** 	}
3015:ff.c          **** #endif
3016:ff.c          **** 	for (;;) {
3017:ff.c          **** 		c = (BYTE)p[si++];				/* Get a byte */
3018:ff.c          **** 		if (c <= ' ') break; 			/* Break if end of the path name */
3019:ff.c          **** 		if (c == '/' || c == '\\') {	/* Break if a separator is found */
3020:ff.c          **** 			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
3021:ff.c          **** 			break;
3022:ff.c          **** 		}
3023:ff.c          **** 		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
3024:ff.c          **** 			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
3025:ff.c          **** 			i = 8; ni = 11;				/* Enter file extension field */
3026:ff.c          **** 			continue;
3027:ff.c          **** 		}
3028:ff.c          **** #if FF_CODE_PAGE == 0
3029:ff.c          **** 		if (ExCvt && c >= 0x80) {		/* Is SBC extended character? */
3030:ff.c          **** 			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
3031:ff.c          **** 		}
3032:ff.c          **** #elif FF_CODE_PAGE < 900
3033:ff.c          **** 		if (c >= 0x80) {				/* Is SBC extended character? */
3034:ff.c          **** 			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
3035:ff.c          **** 		}
3036:ff.c          **** #endif
3037:ff.c          **** 		if (dbc_1st(c)) {				/* Check if it is a DBC 1st byte */
3038:ff.c          **** 			d = (BYTE)p[si++];			/* Get 2nd byte */
3039:ff.c          **** 			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
3040:ff.c          **** 			sfn[i++] = c;
3041:ff.c          **** 			sfn[i++] = d;
3042:ff.c          **** 		} else {						/* SBC */
3043:ff.c          **** 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
3044:ff.c          **** 			if (IsLower(c)) c -= 0x20;	/* To upper */
3045:ff.c          **** 			sfn[i++] = c;
3046:ff.c          **** 		}
3047:ff.c          **** 	}
3048:ff.c          **** 	*path = p + si;						/* Return pointer to the next segment */
3049:ff.c          **** 	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
3050:ff.c          **** 
3051:ff.c          **** 	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with 
3052:ff.c          **** 	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
3053:ff.c          **** 
3054:ff.c          **** 	return FR_OK;
3055:ff.c          **** #endif /* FF_USE_LFN */
3056:ff.c          **** }
3057:ff.c          **** 
3058:ff.c          **** 
3059:ff.c          **** 
3060:ff.c          **** 
3061:ff.c          **** /*-----------------------------------------------------------------------*/
3062:ff.c          **** /* Follow a file path                                                    */
3063:ff.c          **** /*-----------------------------------------------------------------------*/
3064:ff.c          **** 
3065:ff.c          **** static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
3066:ff.c          **** 	DIR* dp,					/* Directory object to return last directory and found object */
3067:ff.c          **** 	const TCHAR* path			/* Full-path string to find a file or directory */
3068:ff.c          **** )
3069:ff.c          **** {
3070:ff.c          **** 	FRESULT res;
3071:ff.c          **** 	BYTE ns;
3072:ff.c          **** 	FATFS *fs = dp->obj.fs;
3073:ff.c          **** 
3074:ff.c          **** 
3075:ff.c          **** #if FF_FS_RPATH != 0
3076:ff.c          **** 	if (*path != '/' && *path != '\\') {	/* Without heading separator */
3077:ff.c          **** 		dp->obj.sclust = fs->cdir;				/* Start from current directory */
3078:ff.c          **** 	} else
3079:ff.c          **** #endif
3080:ff.c          **** 	{										/* With heading separator */
3081:ff.c          **** 		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
3082:ff.c          **** 		dp->obj.sclust = 0;					/* Start from root directory */
3083:ff.c          **** 	}
3084:ff.c          **** #if FF_FS_EXFAT
3085:ff.c          **** 	dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
3086:ff.c          **** #if FF_FS_RPATH != 0
3087:ff.c          **** 	if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {	/* exFAT: Retrieve the sub-directory's status */
3088:ff.c          **** 		DIR dj;
3089:ff.c          **** 
3090:ff.c          **** 		dp->obj.c_scl = fs->cdc_scl;
3091:ff.c          **** 		dp->obj.c_size = fs->cdc_size;
3092:ff.c          **** 		dp->obj.c_ofs = fs->cdc_ofs;
3093:ff.c          **** 		res = load_obj_xdir(&dj, &dp->obj);
3094:ff.c          **** 		if (res != FR_OK) return res;
3095:ff.c          **** 		dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
3096:ff.c          **** 		dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
3097:ff.c          **** 	}
3098:ff.c          **** #endif
3099:ff.c          **** #endif
3100:ff.c          **** 
3101:ff.c          **** 	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
3102:ff.c          **** 		dp->fn[NSFLAG] = NS_NONAME;
3103:ff.c          **** 		res = dir_sdi(dp, 0);
3104:ff.c          **** 
3105:ff.c          **** 	} else {								/* Follow path */
3106:ff.c          **** 		for (;;) {
3107:ff.c          **** 			res = create_name(dp, &path);	/* Get a segment name of the path */
3108:ff.c          **** 			if (res != FR_OK) break;
3109:ff.c          **** 			res = dir_find(dp);				/* Find an object with the segment name */
3110:ff.c          **** 			ns = dp->fn[NSFLAG];
3111:ff.c          **** 			if (res != FR_OK) {				/* Failed to find the object */
3112:ff.c          **** 				if (res == FR_NO_FILE) {	/* Object is not found */
3113:ff.c          **** 					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
3114:ff.c          **** 						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
3115:ff.c          **** 						dp->fn[NSFLAG] = NS_NONAME;
3116:ff.c          **** 						res = FR_OK;
3117:ff.c          **** 					} else {							/* Could not find the object */
3118:ff.c          **** 						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
3119:ff.c          **** 					}
3120:ff.c          **** 				}
3121:ff.c          **** 				break;
3122:ff.c          **** 			}
3123:ff.c          **** 			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
3124:ff.c          **** 			/* Get into the sub-directory */
3125:ff.c          **** 			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
3126:ff.c          **** 				res = FR_NO_PATH; break;
3127:ff.c          **** 			}
3128:ff.c          **** #if FF_FS_EXFAT
3129:ff.c          **** 			if (fs->fs_type == FS_EXFAT) {		/* Save containing directory information for next dir */
3130:ff.c          **** 				dp->obj.c_scl = dp->obj.sclust;
3131:ff.c          **** 				dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
3132:ff.c          **** 				dp->obj.c_ofs = dp->blk_ofs;
3133:ff.c          **** 				init_alloc_info(fs, &dp->obj);	/* Open next directory */
3134:ff.c          **** 			} else
3135:ff.c          **** #endif
3136:ff.c          **** 			{
3137:ff.c          **** 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
3138:ff.c          **** 			}
3139:ff.c          **** 		}
3140:ff.c          **** 	}
3141:ff.c          **** 
3142:ff.c          **** 	return res;
3143:ff.c          **** }
3144:ff.c          **** 
3145:ff.c          **** 
3146:ff.c          **** 
3147:ff.c          **** 
3148:ff.c          **** /*-----------------------------------------------------------------------*/
3149:ff.c          **** /* Get logical drive number from path name                               */
3150:ff.c          **** /*-----------------------------------------------------------------------*/
3151:ff.c          **** 
3152:ff.c          **** static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer)
3153:ff.c          **** 	const TCHAR** path		/* Pointer to pointer to the path name */
3154:ff.c          **** )
3155:ff.c          **** {
 125               		.loc 1 3155 0
 126               		.cfi_startproc
 127               	.LVL9:
 128 007a CF93      		push r28
 129               	.LCFI2:
 130               		.cfi_def_cfa_offset 3
 131               		.cfi_offset 28, -2
 132 007c DF93      		push r29
 133               	.LCFI3:
 134               		.cfi_def_cfa_offset 4
 135               		.cfi_offset 29, -3
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 2 */
 139               	.L__stack_usage = 2
 140 007e DC01      		movw r26,r24
 141               	.LVL10:
3156:ff.c          **** 	const TCHAR *tp, *tt;
3157:ff.c          **** 	TCHAR tc;
3158:ff.c          **** 	int i, vol = -1;
3159:ff.c          **** #if FF_STR_VOLUME_ID		/* Find string volume ID */
3160:ff.c          **** 	const char *sp;
3161:ff.c          **** 	char c;
3162:ff.c          **** #endif
3163:ff.c          **** 
3164:ff.c          **** 	tt = tp = *path;
 142               		.loc 1 3164 0
 143 0080 ED91      		ld r30,X+
 144 0082 FC91      		ld r31,X
 145 0084 1197      		sbiw r26,1
 146               	.LVL11:
3165:ff.c          **** 	if (!tp) return vol;	/* Invalid path name? */
 147               		.loc 1 3165 0
 148 0086 3097      		sbiw r30,0
 149 0088 01F0      		breq .L18
 150 008a 9F01      		movw r18,r30
 151               	.LVL12:
 152               	.L8:
3166:ff.c          **** 	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the p
 153               		.loc 1 3166 0 discriminator 2
 154 008c 2F5F      		subi r18,-1
 155 008e 3F4F      		sbci r19,-1
 156               	.LVL13:
 157 0090 E901      		movw r28,r18
 158 0092 2197      		sbiw r28,1
 159 0094 8881      		ld r24,Y
 160               	.LVL14:
 161 0096 8132      		cpi r24,lo8(33)
 162 0098 00F0      		brlo .L12
 163               		.loc 1 3166 0 is_stmt 0 discriminator 1
 164 009a 8A33      		cpi r24,lo8(58)
 165 009c 01F4      		brne .L8
 166               	.LVL15:
3167:ff.c          **** 
3168:ff.c          **** 	if (tc == ':') {	/* DOS/Windows style volume ID? */
3169:ff.c          **** 		i = FF_VOLUMES;
3170:ff.c          **** 		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 167               		.loc 1 3170 0 is_stmt 1
 168 009e 9081      		ld r25,Z
 169 00a0 80ED      		ldi r24,lo8(-48)
 170               	.LVL16:
 171 00a2 890F      		add r24,r25
 172 00a4 8A30      		cpi r24,lo8(10)
 173 00a6 00F4      		brsh .L18
 174               		.loc 1 3170 0 is_stmt 0 discriminator 1
 175 00a8 3296      		adiw r30,2
 176               	.LVL17:
 177 00aa 2E17      		cp r18,r30
 178 00ac 3F07      		cpc r19,r31
 179 00ae 01F4      		brne .L18
 180               	.LVL18:
3171:ff.c          **** 			i = (int)*tp - '0';	/* Get the LD number */
3172:ff.c          **** 		}
3173:ff.c          **** #if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
3174:ff.c          **** 		else {
3175:ff.c          **** 			i = 0;
3176:ff.c          **** 			do {
3177:ff.c          **** 				sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
3178:ff.c          **** 				do {	/* Compare the volume ID with path name */
3179:ff.c          **** 					c = *sp++; tc = *tp++;
3180:ff.c          **** 					if (IsLower(c)) c -= 0x20;
3181:ff.c          **** 					if (IsLower(tc)) tc -= 0x20;
3182:ff.c          **** 				} while (c && (TCHAR)c == tc);
3183:ff.c          **** 			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
3184:ff.c          **** 		}
3185:ff.c          **** #endif
3186:ff.c          **** 		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 181               		.loc 1 3186 0 is_stmt 1
 182 00b0 9033      		cpi r25,lo8(48)
 183 00b2 01F4      		brne .L18
 184               	.LVL19:
3187:ff.c          **** 			vol = i;		/* Drive number */
3188:ff.c          **** 			*path = tt;		/* Snip the drive prefix off */
 185               		.loc 1 3188 0
 186 00b4 2D93      		st X+,r18
 187 00b6 3C93      		st X,r19
 188               	.LVL20:
 189               	.L12:
3189:ff.c          **** 		}
3190:ff.c          **** 		return vol;
3191:ff.c          **** 	}
3192:ff.c          **** #if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
3193:ff.c          **** 	if (*tp == '/') {
3194:ff.c          **** 		i = 0;
3195:ff.c          **** 		do {
3196:ff.c          **** 			sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
3197:ff.c          **** 			do {	/* Compare the volume ID with path name */
3198:ff.c          **** 				c = *sp++; tc = *(++tp);
3199:ff.c          **** 				if (IsLower(c)) c -= 0x20;
3200:ff.c          **** 				if (IsLower(tc)) tc -= 0x20;
3201:ff.c          **** 			} while (c && (TCHAR)c == tc);
3202:ff.c          **** 		} while ((c || (tc != '/' && (UINT)tc >= (FF_USE_LFN ? ' ' : '!'))) && ++i < FF_VOLUMES);	/* Repe
3203:ff.c          **** 		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
3204:ff.c          **** 			vol = i;		/* Drive number */
3205:ff.c          **** 			*path = tp;		/* Snip the drive prefix off */
3206:ff.c          **** 			return vol;
3207:ff.c          **** 		}
3208:ff.c          **** 	}
3209:ff.c          **** #endif
3210:ff.c          **** 	/* No drive prefix is found */
3211:ff.c          **** #if FF_FS_RPATH != 0
3212:ff.c          **** 	vol = CurrVol;	/* Default drive is current drive */
3213:ff.c          **** #else
3214:ff.c          **** 	vol = 0;		/* Default drive is 0 */
3215:ff.c          **** #endif
3216:ff.c          **** 	return vol;		/* Return the default drive */
 190               		.loc 1 3216 0
 191 00b8 80E0      		ldi r24,0
 192 00ba 90E0      		ldi r25,0
 193 00bc 00C0      		rjmp .L17
 194               	.LVL21:
 195               	.L18:
3165:ff.c          **** 	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the p
 196               		.loc 1 3165 0
 197 00be 8FEF      		ldi r24,lo8(-1)
 198 00c0 9FEF      		ldi r25,lo8(-1)
 199               	.LVL22:
 200               	.L17:
 201               	/* epilogue start */
3217:ff.c          **** }
 202               		.loc 1 3217 0
 203 00c2 DF91      		pop r29
 204 00c4 CF91      		pop r28
 205 00c6 0895      		ret
 206               		.cfi_endproc
 207               	.LFE31:
 210               	validate:
 211               	.LFB35:
3218:ff.c          **** 
3219:ff.c          **** 
3220:ff.c          **** 
3221:ff.c          **** 
3222:ff.c          **** /*-----------------------------------------------------------------------*/
3223:ff.c          **** /* GPT support functions                                                 */
3224:ff.c          **** /*-----------------------------------------------------------------------*/
3225:ff.c          **** 
3226:ff.c          **** #if FF_LBA64
3227:ff.c          **** 
3228:ff.c          **** /* Calculate CRC32 in byte-by-byte */
3229:ff.c          **** 
3230:ff.c          **** static DWORD crc32 (	/* Returns next CRC value */
3231:ff.c          **** 	DWORD crc,			/* Current CRC value */
3232:ff.c          **** 	BYTE d				/* A byte to be processed */
3233:ff.c          **** )
3234:ff.c          **** {
3235:ff.c          **** 	BYTE b;
3236:ff.c          **** 
3237:ff.c          **** 
3238:ff.c          **** 	for (b = 1; b; b <<= 1) {
3239:ff.c          **** 		crc ^= (d & b) ? 1 : 0;
3240:ff.c          **** 		crc = (crc & 1) ? crc >> 1 ^ 0xEDB88320 : crc >> 1;
3241:ff.c          **** 	}
3242:ff.c          **** 	return crc;
3243:ff.c          **** }
3244:ff.c          **** 
3245:ff.c          **** 
3246:ff.c          **** /* Check validity of GPT header */
3247:ff.c          **** 
3248:ff.c          **** static int test_gpt_header (	/* 0:Invalid, 1:Valid */
3249:ff.c          **** 	const BYTE* gpth			/* Pointer to the GPT header */
3250:ff.c          **** )
3251:ff.c          **** {
3252:ff.c          **** 	UINT i;
3253:ff.c          **** 	DWORD bcc;
3254:ff.c          **** 
3255:ff.c          **** 
3256:ff.c          **** 	if (mem_cmp(gpth + GPTH_Sign, "EFI PART" "\0\0\1\0" "\x5C\0\0", 16)) return 0;	/* Check sign, vers
3257:ff.c          **** 	for (i = 0, bcc = 0xFFFFFFFF; i < 92; i++) {		/* Check header BCC */
3258:ff.c          **** 		bcc = crc32(bcc, i - GPTH_Bcc < 4 ? 0 : gpth[i]);
3259:ff.c          **** 	}
3260:ff.c          **** 	if (~bcc != ld_dword(gpth + GPTH_Bcc)) return 0;
3261:ff.c          **** 	if (ld_dword(gpth + GPTH_PteSize) != SZ_GPTE) return 0;	/* Table entry size (must be SZ_GPTE bytes
3262:ff.c          **** 	if (ld_dword(gpth + GPTH_PtNum) > 128) return 0;	/* Table size (must be 128 entries or less) */
3263:ff.c          **** 
3264:ff.c          **** 	return 1;
3265:ff.c          **** }
3266:ff.c          **** 
3267:ff.c          **** #if !FF_FS_READONLY && FF_USE_MKFS
3268:ff.c          **** 
3269:ff.c          **** /* Generate random value */
3270:ff.c          **** static DWORD make_rand (
3271:ff.c          **** 	DWORD seed,		/* Seed value */
3272:ff.c          **** 	BYTE* buff,		/* Output buffer */
3273:ff.c          **** 	UINT n			/* Data length */
3274:ff.c          **** )
3275:ff.c          **** {
3276:ff.c          **** 	UINT r;
3277:ff.c          **** 
3278:ff.c          **** 
3279:ff.c          **** 	if (seed == 0) seed = 1;
3280:ff.c          **** 	do {
3281:ff.c          **** 		for (r = 0; r < 8; r++) seed = seed & 1 ? seed >> 1 ^ 0xA3000000 : seed >> 1;	/* Shift 8 bits the
3282:ff.c          **** 		*buff++ = (BYTE)seed;
3283:ff.c          **** 	} while (--n);
3284:ff.c          **** 	return seed;
3285:ff.c          **** }
3286:ff.c          **** 
3287:ff.c          **** #endif
3288:ff.c          **** #endif
3289:ff.c          **** 
3290:ff.c          **** 
3291:ff.c          **** 
3292:ff.c          **** /*-----------------------------------------------------------------------*/
3293:ff.c          **** /* Load a sector and check if it is an FAT VBR                           */
3294:ff.c          **** /*-----------------------------------------------------------------------*/
3295:ff.c          **** 
3296:ff.c          **** /* Check what the sector is */
3297:ff.c          **** 
3298:ff.c          **** static UINT check_fs (	/* 0:FAT VBR, 1:exFAT VBR, 2:Not FAT and valid BS, 3:Not FAT and invalid BS,
3299:ff.c          **** 	FATFS* fs,			/* Filesystem object */
3300:ff.c          **** 	LBA_t sect			/* Sector to load and check if it is an FAT-VBR or not */
3301:ff.c          **** )
3302:ff.c          **** {
3303:ff.c          **** 	WORD w, sign;
3304:ff.c          **** 	BYTE b;
3305:ff.c          **** 
3306:ff.c          **** 
3307:ff.c          **** 	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
3308:ff.c          **** 	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
3309:ff.c          **** 	sign = ld_word(fs->win + BS_55AA);
3310:ff.c          **** #if FF_FS_EXFAT
3311:ff.c          **** 	if (sign == 0xAA55 && !mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* 
3312:ff.c          **** #endif
3313:ff.c          **** 	b = fs->win[BS_JmpBoot];
3314:ff.c          **** 	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near 
3315:ff.c          **** 		if (sign == 0xAA55 && !mem_cmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) return 0;	/* It is an F
3316:ff.c          **** 		/* FAT volumes formatted with early MS-DOS lack boot signature and FAT string, so that we need to
3317:ff.c          **** 		w = ld_word(fs->win + BPB_BytsPerSec);
3318:ff.c          **** 		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS) {	/* Properness of sector size */
3319:ff.c          **** 			b = fs->win[BPB_SecPerClus];
3320:ff.c          **** 			if (b != 0 && (b & (b - 1)) == 0						/* Properness of cluster size */
3321:ff.c          **** 			&& (fs->win[BPB_NumFATs] == 1 || fs->win[BPB_NumFATs] == 2)	/* Properness of number of FATs */
3322:ff.c          **** 			&& ld_word(fs->win + BPB_RootEntCnt) != 0				/* Properness of root entry count */
3323:ff.c          **** 			&& ld_word(fs->win + BPB_FATSz16) != 0) {				/* Properness of FAT size */
3324:ff.c          **** 				return 0;	/* Sector can be presumed an FAT VBR */
3325:ff.c          **** 			}
3326:ff.c          **** 		}
3327:ff.c          **** 	}
3328:ff.c          **** 	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (valid or invalid BS) */
3329:ff.c          **** }
3330:ff.c          **** 
3331:ff.c          **** 
3332:ff.c          **** /* Find an FAT volume */
3333:ff.c          **** /* (It supports only generic partitioning rules, MBR, GPT and SFD) */
3334:ff.c          **** 
3335:ff.c          **** static UINT find_volume (	/* Returns BS status found in the hosting drive */
3336:ff.c          **** 	FATFS* fs,		/* Filesystem object */
3337:ff.c          **** 	UINT part		/* Partition to fined = 0:auto, 1..:forced */
3338:ff.c          **** )
3339:ff.c          **** {
3340:ff.c          **** 	UINT fmt, i;
3341:ff.c          **** 	DWORD mbr_pt[4];
3342:ff.c          **** 
3343:ff.c          **** 
3344:ff.c          **** 	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD */
3345:ff.c          **** 	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is a FAT VBR as auto scan, n
3346:ff.c          **** 
3347:ff.c          **** 	/* Sector 0 is not an FAT VBR or forced partition number wants a partition */
3348:ff.c          **** 
3349:ff.c          **** #if FF_LBA64
3350:ff.c          **** 	if (fs->win[MBR_Table + PTE_System] == 0xEE) {	/* GPT protective MBR? */
3351:ff.c          **** 		DWORD n_ent, v_ent, ofs;
3352:ff.c          **** 		QWORD pt_lba;
3353:ff.c          **** 
3354:ff.c          **** 		if (move_window(fs, 1) != FR_OK) return 4;	/* Load GPT header sector (next to MBR) */
3355:ff.c          **** 		if (!test_gpt_header(fs->win)) return 3;	/* Check if GPT header is valid */
3356:ff.c          **** 		n_ent = ld_dword(fs->win + GPTH_PtNum);		/* Number of entries */
3357:ff.c          **** 		pt_lba = ld_qword(fs->win + GPTH_PtOfs);	/* Table location */
3358:ff.c          **** 		for (v_ent = i = 0; i < n_ent; i++) {		/* Find FAT partition */
3359:ff.c          **** 			if (move_window(fs, pt_lba + i * SZ_GPTE / SS(fs)) != FR_OK) return 4;	/* PT sector */
3360:ff.c          **** 			ofs = i * SZ_GPTE % SS(fs);												/* Offset in the sector */
3361:ff.c          **** 			if (!mem_cmp(fs->win + ofs + GPTE_PtGuid, GUID_MS_Basic, 16)) {	/* MS basic data partition? */
3362:ff.c          **** 				v_ent++;
3363:ff.c          **** 				fmt = check_fs(fs, ld_qword(fs->win + ofs + GPTE_FstLba));	/* Load VBR and check status */
3364:ff.c          **** 				if (part == 0 && fmt <= 1) return fmt;			/* Auto search (valid FAT volume found first) */
3365:ff.c          **** 				if (part != 0 && v_ent == part) return fmt;		/* Forced partition order (regardless of it is val
3366:ff.c          **** 			}
3367:ff.c          **** 		}
3368:ff.c          **** 		return 3;	/* Not found */
3369:ff.c          **** 	}
3370:ff.c          **** #endif
3371:ff.c          **** 	if (FF_MULTI_PARTITION && part > 4) return 3;	/* MBR has 4 partitions max */
3372:ff.c          **** 	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
3373:ff.c          **** 		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
3374:ff.c          **** 	}
3375:ff.c          **** 	i = part ? part - 1 : 0;		/* Table index to find first */
3376:ff.c          **** 	do {							/* Find an FAT volume */
3377:ff.c          **** 		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
3378:ff.c          **** 	} while (part == 0 && fmt >= 2 && ++i < 4);
3379:ff.c          **** 	return fmt;
3380:ff.c          **** }
3381:ff.c          **** 
3382:ff.c          **** 
3383:ff.c          **** 
3384:ff.c          **** 
3385:ff.c          **** /*-----------------------------------------------------------------------*/
3386:ff.c          **** /* Determine logical drive number and mount the volume if needed         */
3387:ff.c          **** /*-----------------------------------------------------------------------*/
3388:ff.c          **** 
3389:ff.c          **** static FRESULT mount_volume (	/* FR_OK(0): successful, !=0: an error occurred */
3390:ff.c          **** 	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
3391:ff.c          **** 	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
3392:ff.c          **** 	BYTE mode					/* !=0: Check write protection for write access */
3393:ff.c          **** )
3394:ff.c          **** {
3395:ff.c          **** 	int vol;
3396:ff.c          **** 	DSTATUS stat;
3397:ff.c          **** 	LBA_t bsect;
3398:ff.c          **** 	DWORD tsect, sysect, fasize, nclst, szbfat;
3399:ff.c          **** 	WORD nrsv;
3400:ff.c          **** 	FATFS *fs;
3401:ff.c          **** 	UINT fmt;
3402:ff.c          **** 
3403:ff.c          **** 
3404:ff.c          **** 	/* Get logical drive number */
3405:ff.c          **** 	*rfs = 0;
3406:ff.c          **** 	vol = get_ldnumber(path);
3407:ff.c          **** 	if (vol < 0) return FR_INVALID_DRIVE;
3408:ff.c          **** 
3409:ff.c          **** 	/* Check if the filesystem object is valid or not */
3410:ff.c          **** 	fs = FatFs[vol];					/* Get pointer to the filesystem object */
3411:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
3412:ff.c          **** #if FF_FS_REENTRANT
3413:ff.c          **** 	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
3414:ff.c          **** #endif
3415:ff.c          **** 	*rfs = fs;							/* Return pointer to the filesystem object */
3416:ff.c          **** 
3417:ff.c          **** 	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
3418:ff.c          **** 	if (fs->fs_type != 0) {				/* If the volume has been mounted */
3419:ff.c          **** 		stat = disk_status(fs->pdrv);
3420:ff.c          **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
3421:ff.c          **** 			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
3422:ff.c          **** 				return FR_WRITE_PROTECTED;
3423:ff.c          **** 			}
3424:ff.c          **** 			return FR_OK;				/* The filesystem object is already valid */
3425:ff.c          **** 		}
3426:ff.c          **** 	}
3427:ff.c          **** 
3428:ff.c          **** 	/* The filesystem object is not valid. */
3429:ff.c          **** 	/* Following code attempts to mount the volume. (find a FAT volume, analyze the BPB and initialize
3430:ff.c          **** 
3431:ff.c          **** 	fs->fs_type = 0;					/* Clear the filesystem object */
3432:ff.c          **** 	fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
3433:ff.c          **** 	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
3434:ff.c          **** 	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
3435:ff.c          **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
3436:ff.c          **** 	}
3437:ff.c          **** 	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
3438:ff.c          **** 		return FR_WRITE_PROTECTED;
3439:ff.c          **** 	}
3440:ff.c          **** #if FF_MAX_SS != FF_MIN_SS				/* Get sector size (multiple sector size cfg only) */
3441:ff.c          **** 	if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
3442:ff.c          **** 	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
3443:ff.c          **** #endif
3444:ff.c          **** 
3445:ff.c          **** 	/* Find an FAT volume on the drive */
3446:ff.c          **** 	fmt = find_volume(fs, LD2PT(vol));
3447:ff.c          **** 	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
3448:ff.c          **** 	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
3449:ff.c          **** 	bsect = fs->winsect;					/* Volume location */
3450:ff.c          **** 
3451:ff.c          **** 	/* An FAT volume is found (bsect). Following code initializes the filesystem object */
3452:ff.c          **** 
3453:ff.c          **** #if FF_FS_EXFAT
3454:ff.c          **** 	if (fmt == 1) {
3455:ff.c          **** 		QWORD maxlba;
3456:ff.c          **** 		DWORD so, cv, bcl, i;
3457:ff.c          **** 
3458:ff.c          **** 		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
3459:ff.c          **** 		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
3460:ff.c          **** 
3461:ff.c          **** 		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (mus
3462:ff.c          **** 
3463:ff.c          **** 		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physica
3464:ff.c          **** 			return FR_NO_FILESYSTEM;
3465:ff.c          **** 		}
3466:ff.c          **** 
3467:ff.c          **** 		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA + 1 of the volume */
3468:ff.c          **** 		if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-b
3469:ff.c          **** 
3470:ff.c          **** 		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
3471:ff.c          **** 
3472:ff.c          **** 		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
3473:ff.c          **** 		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
3474:ff.c          **** 
3475:ff.c          **** 		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
3476:ff.c          **** 		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
3477:ff.c          **** 
3478:ff.c          **** 		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
3479:ff.c          **** 		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
3480:ff.c          **** 		fs->n_fatent = nclst + 2;
3481:ff.c          **** 
3482:ff.c          **** 		/* Boundaries and Limits */
3483:ff.c          **** 		fs->volbase = bsect;
3484:ff.c          **** 		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
3485:ff.c          **** 		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
3486:ff.c          **** 		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size mu
3487:ff.c          **** 		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
3488:ff.c          **** 
3489:ff.c          **** 		/* Get bitmap location and check if it is contiguous (implementation assumption) */
3490:ff.c          **** 		so = i = 0;
3491:ff.c          **** 		for (;;) {	/* Find the bitmap entry in the root directory (in only first cluster) */
3492:ff.c          **** 			if (i == 0) {
3493:ff.c          **** 				if (so >= fs->csize) return FR_NO_FILESYSTEM;	/* Not found? */
3494:ff.c          **** 				if (move_window(fs, clst2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
3495:ff.c          **** 				so++;
3496:ff.c          **** 			}
3497:ff.c          **** 			if (fs->win[i] == ET_BITMAP) break;				/* Is it a bitmap entry? */
3498:ff.c          **** 			i = (i + SZDIRE) % SS(fs);	/* Next entry */
3499:ff.c          **** 		}
3500:ff.c          **** 		bcl = ld_dword(fs->win + i + 20);					/* Bitmap cluster */
3501:ff.c          **** 		if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;
3502:ff.c          **** 		fs->bitbase = fs->database + fs->csize * (bcl - 2);	/* Bitmap sector */
3503:ff.c          **** 		for (;;) {	/* Check if bitmap is contiguous */
3504:ff.c          **** 			if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
3505:ff.c          **** 			cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);
3506:ff.c          **** 			if (cv == 0xFFFFFFFF) break;				/* Last link? */
3507:ff.c          **** 			if (cv != ++bcl) return FR_NO_FILESYSTEM;	/* Fragmented? */
3508:ff.c          **** 		}
3509:ff.c          **** 
3510:ff.c          **** #if !FF_FS_READONLY
3511:ff.c          **** 		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
3512:ff.c          **** #endif
3513:ff.c          **** 		fmt = FS_EXFAT;			/* FAT sub-type */
3514:ff.c          **** 	} else
3515:ff.c          **** #endif	/* FF_FS_EXFAT */
3516:ff.c          **** 	{
3517:ff.c          **** 		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must
3518:ff.c          **** 
3519:ff.c          **** 		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
3520:ff.c          **** 		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
3521:ff.c          **** 		fs->fsize = fasize;
3522:ff.c          **** 
3523:ff.c          **** 		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
3524:ff.c          **** 		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
3525:ff.c          **** 		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
3526:ff.c          **** 
3527:ff.c          **** 		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
3528:ff.c          **** 		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power o
3529:ff.c          **** 
3530:ff.c          **** 		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
3531:ff.c          **** 		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
3532:ff.c          **** 
3533:ff.c          **** 		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
3534:ff.c          **** 		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
3535:ff.c          **** 
3536:ff.c          **** 		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
3537:ff.c          **** 		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
3538:ff.c          **** 
3539:ff.c          **** 		/* Determine the FAT sub type */
3540:ff.c          **** 		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
3541:ff.c          **** 		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
3542:ff.c          **** 		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
3543:ff.c          **** 		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
3544:ff.c          **** 		fmt = 0;
3545:ff.c          **** 		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
3546:ff.c          **** 		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
3547:ff.c          **** 		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
3548:ff.c          **** 		if (fmt == 0) return FR_NO_FILESYSTEM;
3549:ff.c          **** 
3550:ff.c          **** 		/* Boundaries and Limits */
3551:ff.c          **** 		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
3552:ff.c          **** 		fs->volbase = bsect;							/* Volume start sector */
3553:ff.c          **** 		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
3554:ff.c          **** 		fs->database = bsect + sysect;					/* Data start sector */
3555:ff.c          **** 		if (fmt == FS_FAT32) {
3556:ff.c          **** 			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0
3557:ff.c          **** 			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
3558:ff.c          **** 			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
3559:ff.c          **** 			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
3560:ff.c          **** 		} else {
3561:ff.c          **** 			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
3562:ff.c          **** 			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
3563:ff.c          **** 			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
3564:ff.c          **** 				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
3565:ff.c          **** 		}
3566:ff.c          **** 		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not
3567:ff.c          **** 
3568:ff.c          **** #if !FF_FS_READONLY
3569:ff.c          **** 		/* Get FSInfo if available */
3570:ff.c          **** 		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
3571:ff.c          **** 		fs->fsi_flag = 0x80;
3572:ff.c          **** #if (FF_FS_NOFSINFO & 3) != 3
3573:ff.c          **** 		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
3574:ff.c          **** 			&& ld_word(fs->win + BPB_FSInfo32) == 1
3575:ff.c          **** 			&& move_window(fs, bsect + 1) == FR_OK)
3576:ff.c          **** 		{
3577:ff.c          **** 			fs->fsi_flag = 0;
3578:ff.c          **** 			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
3579:ff.c          **** 				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
3580:ff.c          **** 				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
3581:ff.c          **** 			{
3582:ff.c          **** #if (FF_FS_NOFSINFO & 1) == 0
3583:ff.c          **** 				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
3584:ff.c          **** #endif
3585:ff.c          **** #if (FF_FS_NOFSINFO & 2) == 0
3586:ff.c          **** 				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
3587:ff.c          **** #endif
3588:ff.c          **** 			}
3589:ff.c          **** 		}
3590:ff.c          **** #endif	/* (FF_FS_NOFSINFO & 3) != 3 */
3591:ff.c          **** #endif	/* !FF_FS_READONLY */
3592:ff.c          **** 	}
3593:ff.c          **** 
3594:ff.c          **** 	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
3595:ff.c          **** 	fs->id = ++Fsid;		/* Volume mount ID */
3596:ff.c          **** #if FF_USE_LFN == 1
3597:ff.c          **** 	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
3598:ff.c          **** #if FF_FS_EXFAT
3599:ff.c          **** 	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
3600:ff.c          **** #endif
3601:ff.c          **** #endif
3602:ff.c          **** #if FF_FS_RPATH != 0
3603:ff.c          **** 	fs->cdir = 0;			/* Initialize current directory */
3604:ff.c          **** #endif
3605:ff.c          **** #if FF_FS_LOCK != 0			/* Clear file lock semaphores */
3606:ff.c          **** 	clear_lock(fs);
3607:ff.c          **** #endif
3608:ff.c          **** 	return FR_OK;
3609:ff.c          **** }
3610:ff.c          **** 
3611:ff.c          **** 
3612:ff.c          **** 
3613:ff.c          **** 
3614:ff.c          **** /*-----------------------------------------------------------------------*/
3615:ff.c          **** /* Check if the file/directory object is valid or not                    */
3616:ff.c          **** /*-----------------------------------------------------------------------*/
3617:ff.c          **** 
3618:ff.c          **** static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
3619:ff.c          **** 	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity
3620:ff.c          **** 	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
3621:ff.c          **** )
3622:ff.c          **** {
 212               		.loc 1 3622 0
 213               		.cfi_startproc
 214               	.LVL23:
 215 00c8 0F93      		push r16
 216               	.LCFI4:
 217               		.cfi_def_cfa_offset 3
 218               		.cfi_offset 16, -2
 219 00ca 1F93      		push r17
 220               	.LCFI5:
 221               		.cfi_def_cfa_offset 4
 222               		.cfi_offset 17, -3
 223 00cc CF93      		push r28
 224               	.LCFI6:
 225               		.cfi_def_cfa_offset 5
 226               		.cfi_offset 28, -4
 227 00ce DF93      		push r29
 228               	.LCFI7:
 229               		.cfi_def_cfa_offset 6
 230               		.cfi_offset 29, -5
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 4 */
 234               	.L__stack_usage = 4
 235 00d0 EC01      		movw r28,r24
 236 00d2 8B01      		movw r16,r22
 237               	.LVL24:
3623:ff.c          **** 	FRESULT res = FR_INVALID_OBJECT;
3624:ff.c          **** 
3625:ff.c          **** 
3626:ff.c          **** 	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid
 238               		.loc 1 3626 0
 239 00d4 892B      		or r24,r25
 240 00d6 01F0      		breq .L20
 241               		.loc 1 3626 0 is_stmt 0 discriminator 1
 242 00d8 E881      		ld r30,Y
 243 00da F981      		ldd r31,Y+1
 244 00dc 3097      		sbiw r30,0
 245 00de 01F0      		breq .L20
 246               		.loc 1 3626 0 discriminator 2
 247 00e0 8081      		ld r24,Z
 248               	.LVL25:
 249 00e2 8823      		tst r24
 250 00e4 01F0      		breq .L20
 251               		.loc 1 3626 0 discriminator 3
 252 00e6 2A81      		ldd r18,Y+2
 253 00e8 3B81      		ldd r19,Y+3
 254 00ea 8581      		ldd r24,Z+5
 255 00ec 9681      		ldd r25,Z+6
 256 00ee 2817      		cp r18,r24
 257 00f0 3907      		cpc r19,r25
 258 00f2 01F4      		brne .L20
3627:ff.c          **** #if FF_FS_REENTRANT
3628:ff.c          **** 		if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
3629:ff.c          **** 			if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initializ
3630:ff.c          **** 				res = FR_OK;
3631:ff.c          **** 			} else {
3632:ff.c          **** 				unlock_fs(obj->fs, FR_OK);
3633:ff.c          **** 			}
3634:ff.c          **** 		} else {
3635:ff.c          **** 			res = FR_TIMEOUT;
3636:ff.c          **** 		}
3637:ff.c          **** #else
3638:ff.c          **** 		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialize
 259               		.loc 1 3638 0 is_stmt 1
 260 00f4 8181      		ldd r24,Z+1
 261 00f6 0E94 0000 		call disk_status
 262               	.LVL26:
 263 00fa 80FD      		sbrc r24,0
 264 00fc 00C0      		rjmp .L20
 265               	.LVL27:
3639:ff.c          **** 			res = FR_OK;
3640:ff.c          **** 		}
3641:ff.c          **** #endif
3642:ff.c          **** 	}
3643:ff.c          **** 	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 266               		.loc 1 3643 0
 267 00fe 2881      		ld r18,Y
 268 0100 3981      		ldd r19,Y+1
3639:ff.c          **** 			res = FR_OK;
 269               		.loc 1 3639 0
 270 0102 80E0      		ldi r24,0
 271               	.LVL28:
 272               	.L22:
 273               		.loc 1 3643 0 discriminator 4
 274 0104 F801      		movw r30,r16
 275 0106 3183      		std Z+1,r19
 276 0108 2083      		st Z,r18
 277               	/* epilogue start */
3644:ff.c          **** 	return res;
3645:ff.c          **** }
 278               		.loc 1 3645 0 discriminator 4
 279 010a DF91      		pop r29
 280 010c CF91      		pop r28
 281               	.LVL29:
 282 010e 1F91      		pop r17
 283 0110 0F91      		pop r16
 284               	.LVL30:
 285 0112 0895      		ret
 286               	.LVL31:
 287               	.L20:
3639:ff.c          **** 			res = FR_OK;
 288               		.loc 1 3639 0
 289 0114 89E0      		ldi r24,lo8(9)
3643:ff.c          **** 	return res;
 290               		.loc 1 3643 0
 291 0116 20E0      		ldi r18,0
 292 0118 30E0      		ldi r19,0
 293 011a 00C0      		rjmp .L22
 294               		.cfi_endproc
 295               	.LFE35:
 298               	mem_cpy.part.0:
 299               	.LFB52:
 684:ff.c          **** {
 300               		.loc 1 684 0
 301               		.cfi_startproc
 302               	.LVL32:
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 0 */
 306               	.L__stack_usage = 0
 307 011c FB01      		movw r30,r22
 308 011e 480F      		add r20,r24
 309 0120 591F      		adc r21,r25
 310               	.LVL33:
 311               	.L34:
 691:ff.c          **** 		} while (--cnt);
 312               		.loc 1 691 0
 313 0122 2191      		ld r18,Z+
 314               	.LVL34:
 315 0124 DC01      		movw r26,r24
 316 0126 2D93      		st X+,r18
 317 0128 CD01      		movw r24,r26
 318               	.LVL35:
 692:ff.c          **** 	}
 319               		.loc 1 692 0
 320 012a A417      		cp r26,r20
 321 012c B507      		cpc r27,r21
 322 012e 01F4      		brne .L34
 323               	/* epilogue start */
 694:ff.c          **** 
 324               		.loc 1 694 0
 325 0130 0895      		ret
 326               		.cfi_endproc
 327               	.LFE52:
 330               	ld_clust.isra.3:
 331               	.LFB55:
1864:ff.c          **** 	FATFS* fs,			/* Pointer to the fs object */
 332               		.loc 1 1864 0
 333               		.cfi_startproc
 334               	.LVL36:
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 339 0132 FB01      		movw r30,r22
 340               	.LVL37:
1871:ff.c          **** 	if (fs->fs_type == FS_FAT32) {
 341               		.loc 1 1871 0
 342 0134 428D      		ldd r20,Z+26
 343 0136 538D      		ldd r21,Z+27
 344 0138 60E0      		ldi r22,0
 345 013a 70E0      		ldi r23,0
 346               	.LVL38:
1872:ff.c          **** 		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 347               		.loc 1 1872 0
 348 013c 8330      		cpi r24,lo8(3)
 349 013e 01F4      		brne .L37
1873:ff.c          **** 	}
 350               		.loc 1 1873 0
 351 0140 8489      		ldd r24,Z+20
 352 0142 9589      		ldd r25,Z+21
 353 0144 A0E0      		ldi r26,0
 354 0146 B0E0      		ldi r27,0
 355 0148 DC01      		movw r26,r24
 356 014a 9927      		clr r25
 357 014c 8827      		clr r24
 358 014e 482B      		or r20,r24
 359 0150 592B      		or r21,r25
 360 0152 6A2B      		or r22,r26
 361 0154 7B2B      		or r23,r27
 362               	.LVL39:
 363               	.L37:
1877:ff.c          **** 
 364               		.loc 1 1877 0
 365 0156 CB01      		movw r24,r22
 366 0158 BA01      		movw r22,r20
 367 015a 0895      		ret
 368               		.cfi_endproc
 369               	.LFE55:
 372               	st_clust.isra.4:
 373               	.LFB56:
1881:ff.c          **** 	FATFS* fs,	/* Pointer to the fs object */
 374               		.loc 1 1881 0
 375               		.cfi_startproc
 376               	.LVL40:
 377               	/* prologue: function */
 378               	/* frame size = 0 */
 379               	/* stack size = 0 */
 380               	.L__stack_usage = 0
 381 015c FB01      		movw r30,r22
 382               	.LVL41:
 383               	.LBB102:
 384               	.LBB103:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 385               		.loc 1 650 0
 386 015e 228F      		std Z+26,r18
 387               	.LVL42:
 651:ff.c          **** }
 388               		.loc 1 651 0
 389 0160 338F      		std Z+27,r19
 390               	.LVL43:
 391               	.LBE103:
 392               	.LBE102:
1888:ff.c          **** 		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 393               		.loc 1 1888 0
 394 0162 DC01      		movw r26,r24
 395 0164 8C91      		ld r24,X
 396 0166 8330      		cpi r24,lo8(3)
 397 0168 01F4      		brne .L38
1889:ff.c          **** 	}
 398               		.loc 1 1889 0
 399 016a CA01      		movw r24,r20
 400 016c AA27      		clr r26
 401 016e BB27      		clr r27
 402               	.LVL44:
 403               	.LBB104:
 404               	.LBB105:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 405               		.loc 1 650 0
 406 0170 848B      		std Z+20,r24
 407               	.LVL45:
 651:ff.c          **** }
 408               		.loc 1 651 0
 409 0172 958B      		std Z+21,r25
 410               	.LVL46:
 411               	.L38:
 412 0174 0895      		ret
 413               	.LBE105:
 414               	.LBE104:
 415               		.cfi_endproc
 416               	.LFE56:
 419               	get_fileinfo.part.5:
 420               	.LFB57:
2675:ff.c          **** 	DIR* dp,			/* Pointer to the directory object */
 421               		.loc 1 2675 0
 422               		.cfi_startproc
 423               	.LVL47:
 424 0176 0F93      		push r16
 425               	.LCFI8:
 426               		.cfi_def_cfa_offset 3
 427               		.cfi_offset 16, -2
 428 0178 1F93      		push r17
 429               	.LCFI9:
 430               		.cfi_def_cfa_offset 4
 431               		.cfi_offset 17, -3
 432 017a CF93      		push r28
 433               	.LCFI10:
 434               		.cfi_def_cfa_offset 5
 435               		.cfi_offset 28, -4
 436 017c DF93      		push r29
 437               	.LCFI11:
 438               		.cfi_def_cfa_offset 6
 439               		.cfi_offset 29, -5
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442               	/* stack size = 4 */
 443               	.L__stack_usage = 4
 444 017e FC01      		movw r30,r24
 445 0180 EB01      		movw r28,r22
 446               	.LVL48:
2675:ff.c          **** 	DIR* dp,			/* Pointer to the directory object */
 447               		.loc 1 2675 0
 448 0182 20E0      		ldi r18,0
 449 0184 30E0      		ldi r19,0
 450 0186 40E0      		ldi r20,0
 451 0188 50E0      		ldi r21,0
2760:ff.c          **** 		fno->fname[di++] = c;
 452               		.loc 1 2760 0
 453 018a 8EE2      		ldi r24,lo8(46)
 454               	.LVL49:
 455               	.L44:
2757:ff.c          **** 		if (c == ' ') continue;		/* Skip padding spaces */
 456               		.loc 1 2757 0
 457 018c BA01      		movw r22,r20
 458 018e 6F5F      		subi r22,-1
 459 0190 7F4F      		sbci r23,-1
 460               	.LVL50:
 461 0192 A28D      		ldd r26,Z+26
 462 0194 B38D      		ldd r27,Z+27
 463 0196 A40F      		add r26,r20
 464 0198 B51F      		adc r27,r21
 465 019a 9C91      		ld r25,X
 466               	.LVL51:
2758:ff.c          **** 		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
 467               		.loc 1 2758 0
 468 019c 9032      		cpi r25,lo8(32)
 469 019e 01F0      		breq .L41
2759:ff.c          **** 		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
 470               		.loc 1 2759 0
 471 01a0 9530      		cpi r25,lo8(5)
 472 01a2 01F4      		brne .L42
 473 01a4 95EE      		ldi r25,lo8(-27)
 474               	.LVL52:
 475               	.L42:
2760:ff.c          **** 		fno->fname[di++] = c;
 476               		.loc 1 2760 0
 477 01a6 6930      		cpi r22,9
 478 01a8 7105      		cpc r23,__zero_reg__
 479 01aa 01F4      		brne .L43
 480               	.LVL53:
 481 01ac DE01      		movw r26,r28
 482 01ae A20F      		add r26,r18
 483 01b0 B31F      		adc r27,r19
 484 01b2 1996      		adiw r26,9
 485 01b4 8C93      		st X,r24
 486 01b6 2F5F      		subi r18,-1
 487 01b8 3F4F      		sbci r19,-1
 488               	.LVL54:
 489               	.L43:
2761:ff.c          **** 	}
 490               		.loc 1 2761 0
 491 01ba DE01      		movw r26,r28
 492 01bc A20F      		add r26,r18
 493 01be B31F      		adc r27,r19
 494 01c0 1996      		adiw r26,9
 495 01c2 9C93      		st X,r25
 496 01c4 2F5F      		subi r18,-1
 497 01c6 3F4F      		sbci r19,-1
 498               	.LVL55:
 499               	.L41:
 500 01c8 AB01      		movw r20,r22
2756:ff.c          **** 		c = (TCHAR)dp->dir[si++];
 501               		.loc 1 2756 0
 502 01ca 6B30      		cpi r22,11
 503 01cc 7105      		cpc r23,__zero_reg__
 504 01ce 01F4      		brne .L44
 505               	.LVL56:
2763:ff.c          **** #endif
 506               		.loc 1 2763 0
 507 01d0 DE01      		movw r26,r28
 508 01d2 A20F      		add r26,r18
 509 01d4 B31F      		adc r27,r19
 510 01d6 1996      		adiw r26,9
 511 01d8 1C92      		st X,__zero_reg__
2766:ff.c          **** 	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
 512               		.loc 1 2766 0
 513 01da A28D      		ldd r26,Z+26
 514 01dc B38D      		ldd r27,Z+27
 515 01de 1B96      		adiw r26,11
 516 01e0 8C91      		ld r24,X
 517 01e2 8887      		std Y+8,r24
2767:ff.c          **** 	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
 518               		.loc 1 2767 0
 519 01e4 028D      		ldd r16,Z+26
 520 01e6 138D      		ldd r17,Z+27
 521 01e8 C801      		movw r24,r16
 522 01ea 4C96      		adiw r24,28
 523 01ec 0E94 0000 		call ld_dword
 524               	.LVL57:
 525 01f0 6883      		st Y,r22
 526 01f2 7983      		std Y+1,r23
 527 01f4 8A83      		std Y+2,r24
 528 01f6 9B83      		std Y+3,r25
 529               	.LVL58:
 530               	.LBB106:
 531               	.LBB107:
 615:ff.c          **** 	return rv;
 532               		.loc 1 615 0
 533 01f8 F801      		movw r30,r16
 534 01fa 8689      		ldd r24,Z+22
 535 01fc 9789      		ldd r25,Z+23
 536               	.LVL59:
 537               	.LBE107:
 538               	.LBE106:
2768:ff.c          **** 	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
 539               		.loc 1 2768 0
 540 01fe 9F83      		std Y+7,r25
 541 0200 8E83      		std Y+6,r24
 542               	.LVL60:
 543               	.LBB108:
 544               	.LBB109:
 615:ff.c          **** 	return rv;
 545               		.loc 1 615 0
 546 0202 808D      		ldd r24,Z+24
 547 0204 918D      		ldd r25,Z+25
 548               	.LBE109:
 549               	.LBE108:
2769:ff.c          **** }
 550               		.loc 1 2769 0
 551 0206 9D83      		std Y+5,r25
 552 0208 8C83      		std Y+4,r24
 553               	/* epilogue start */
2770:ff.c          **** 
 554               		.loc 1 2770 0
 555 020a DF91      		pop r29
 556 020c CF91      		pop r28
 557               	.LVL61:
 558 020e 1F91      		pop r17
 559 0210 0F91      		pop r16
 560 0212 0895      		ret
 561               		.cfi_endproc
 562               	.LFE57:
 565               	sync_window:
 566               	.LFB10:
1075:ff.c          **** 	FRESULT res = FR_OK;
 567               		.loc 1 1075 0
 568               		.cfi_startproc
 569               	.LVL62:
 570 0214 8F92      		push r8
 571               	.LCFI12:
 572               		.cfi_def_cfa_offset 3
 573               		.cfi_offset 8, -2
 574 0216 9F92      		push r9
 575               	.LCFI13:
 576               		.cfi_def_cfa_offset 4
 577               		.cfi_offset 9, -3
 578 0218 AF92      		push r10
 579               	.LCFI14:
 580               		.cfi_def_cfa_offset 5
 581               		.cfi_offset 10, -4
 582 021a BF92      		push r11
 583               	.LCFI15:
 584               		.cfi_def_cfa_offset 6
 585               		.cfi_offset 11, -5
 586 021c EF92      		push r14
 587               	.LCFI16:
 588               		.cfi_def_cfa_offset 7
 589               		.cfi_offset 14, -6
 590 021e FF92      		push r15
 591               	.LCFI17:
 592               		.cfi_def_cfa_offset 8
 593               		.cfi_offset 15, -7
 594 0220 0F93      		push r16
 595               	.LCFI18:
 596               		.cfi_def_cfa_offset 9
 597               		.cfi_offset 16, -8
 598 0222 1F93      		push r17
 599               	.LCFI19:
 600               		.cfi_def_cfa_offset 10
 601               		.cfi_offset 17, -9
 602 0224 CF93      		push r28
 603               	.LCFI20:
 604               		.cfi_def_cfa_offset 11
 605               		.cfi_offset 28, -10
 606 0226 DF93      		push r29
 607               	.LCFI21:
 608               		.cfi_def_cfa_offset 12
 609               		.cfi_offset 29, -11
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 10 */
 613               	.L__stack_usage = 10
 614               	.LVL63:
1079:ff.c          **** 		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume *
 615               		.loc 1 1079 0
 616 0228 FC01      		movw r30,r24
 617 022a 2381      		ldd r18,Z+3
 618 022c 2223      		tst r18
 619 022e 01F0      		breq .L54
 620 0230 EC01      		movw r28,r24
 621               	.LVL64:
 622               	.LBB112:
 623               	.LBB113:
1080:ff.c          **** 			fs->wflag = 0;	/* Clear window dirty flag */
 624               		.loc 1 1080 0
 625 0232 7C01      		movw r14,r24
 626 0234 FFE2      		ldi r31,47
 627 0236 EF0E      		add r14,r31
 628 0238 F11C      		adc r15,__zero_reg__
 629 023a 2BA5      		ldd r18,Y+43
 630 023c 3CA5      		ldd r19,Y+44
 631 023e 4DA5      		ldd r20,Y+45
 632 0240 5EA5      		ldd r21,Y+46
 633 0242 01E0      		ldi r16,lo8(1)
 634 0244 10E0      		ldi r17,0
 635 0246 B701      		movw r22,r14
 636 0248 8981      		ldd r24,Y+1
 637               	.LVL65:
 638 024a 0E94 0000 		call disk_write
 639               	.LVL66:
 640 024e 8111      		cpse r24,__zero_reg__
 641 0250 00C0      		rjmp .L53
1081:ff.c          **** 			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 642               		.loc 1 1081 0
 643 0252 1B82      		std Y+3,__zero_reg__
1082:ff.c          **** 				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it t
 644               		.loc 1 1082 0
 645 0254 0BA5      		ldd r16,Y+43
 646 0256 1CA5      		ldd r17,Y+44
 647 0258 2DA5      		ldd r18,Y+45
 648 025a 3EA5      		ldd r19,Y+46
 649 025c 8F89      		ldd r24,Y+23
 650 025e 988D      		ldd r25,Y+24
 651 0260 A98D      		ldd r26,Y+25
 652 0262 BA8D      		ldd r27,Y+26
 653 0264 8F8C      		ldd r8,Y+31
 654 0266 98A0      		ldd r9,Y+32
 655 0268 A9A0      		ldd r10,Y+33
 656 026a BAA0      		ldd r11,Y+34
 657 026c B901      		movw r22,r18
 658 026e A801      		movw r20,r16
 659 0270 4819      		sub r20,r8
 660 0272 5909      		sbc r21,r9
 661 0274 6A09      		sbc r22,r10
 662 0276 7B09      		sbc r23,r11
 663 0278 4817      		cp r20,r24
 664 027a 5907      		cpc r21,r25
 665 027c 6A07      		cpc r22,r26
 666 027e 7B07      		cpc r23,r27
 667 0280 00F4      		brsh .L54
1083:ff.c          **** 			}
 668               		.loc 1 1083 0
 669 0282 6A81      		ldd r22,Y+2
 670 0284 6230      		cpi r22,lo8(2)
 671 0286 01F4      		brne .L54
 672 0288 A901      		movw r20,r18
 673 028a 9801      		movw r18,r16
 674 028c 280F      		add r18,r24
 675 028e 391F      		adc r19,r25
 676 0290 4A1F      		adc r20,r26
 677 0292 5B1F      		adc r21,r27
 678 0294 01E0      		ldi r16,lo8(1)
 679 0296 10E0      		ldi r17,0
 680 0298 B701      		movw r22,r14
 681 029a 8981      		ldd r24,Y+1
 682 029c 0E94 0000 		call disk_write
 683               	.LVL67:
 684               	.L54:
1076:ff.c          **** 
 685               		.loc 1 1076 0
 686 02a0 80E0      		ldi r24,0
 687 02a2 00C0      		rjmp .L51
 688               	.LVL68:
 689               	.L53:
1086:ff.c          **** 		}
 690               		.loc 1 1086 0
 691 02a4 81E0      		ldi r24,lo8(1)
 692               	.LVL69:
 693               	.L51:
 694               	/* epilogue start */
 695               	.LBE113:
 696               	.LBE112:
1090:ff.c          **** #endif
 697               		.loc 1 1090 0
 698 02a6 DF91      		pop r29
 699 02a8 CF91      		pop r28
 700 02aa 1F91      		pop r17
 701 02ac 0F91      		pop r16
 702 02ae FF90      		pop r15
 703 02b0 EF90      		pop r14
 704 02b2 BF90      		pop r11
 705 02b4 AF90      		pop r10
 706 02b6 9F90      		pop r9
 707 02b8 8F90      		pop r8
 708 02ba 0895      		ret
 709               		.cfi_endproc
 710               	.LFE10:
 713               	move_window.part.7:
 714               	.LFB59:
1094:ff.c          **** 	FATFS* fs,		/* Filesystem object */
 715               		.loc 1 1094 0
 716               		.cfi_startproc
 717               	.LVL70:
 718 02bc 8F92      		push r8
 719               	.LCFI22:
 720               		.cfi_def_cfa_offset 3
 721               		.cfi_offset 8, -2
 722 02be 9F92      		push r9
 723               	.LCFI23:
 724               		.cfi_def_cfa_offset 4
 725               		.cfi_offset 9, -3
 726 02c0 AF92      		push r10
 727               	.LCFI24:
 728               		.cfi_def_cfa_offset 5
 729               		.cfi_offset 10, -4
 730 02c2 BF92      		push r11
 731               	.LCFI25:
 732               		.cfi_def_cfa_offset 6
 733               		.cfi_offset 11, -5
 734 02c4 FF92      		push r15
 735               	.LCFI26:
 736               		.cfi_def_cfa_offset 7
 737               		.cfi_offset 15, -6
 738 02c6 0F93      		push r16
 739               	.LCFI27:
 740               		.cfi_def_cfa_offset 8
 741               		.cfi_offset 16, -7
 742 02c8 1F93      		push r17
 743               	.LCFI28:
 744               		.cfi_def_cfa_offset 9
 745               		.cfi_offset 17, -8
 746 02ca CF93      		push r28
 747               	.LCFI29:
 748               		.cfi_def_cfa_offset 10
 749               		.cfi_offset 28, -9
 750 02cc DF93      		push r29
 751               	.LCFI30:
 752               		.cfi_def_cfa_offset 11
 753               		.cfi_offset 29, -10
 754               	/* prologue: function */
 755               	/* frame size = 0 */
 756               	/* stack size = 9 */
 757               	.L__stack_usage = 9
 758 02ce EC01      		movw r28,r24
 759 02d0 4A01      		movw r8,r20
 760 02d2 5B01      		movw r10,r22
1104:ff.c          **** #endif
 761               		.loc 1 1104 0
 762 02d4 0E94 0000 		call sync_window
 763               	.LVL71:
 764 02d8 F82E      		mov r15,r24
 765               	.LVL72:
1106:ff.c          **** 			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 766               		.loc 1 1106 0
 767 02da 8111      		cpse r24,__zero_reg__
 768 02dc 00C0      		rjmp .L56
1107:ff.c          **** 				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
 769               		.loc 1 1107 0
 770 02de 01E0      		ldi r16,lo8(1)
 771 02e0 10E0      		ldi r17,0
 772 02e2 A501      		movw r20,r10
 773 02e4 9401      		movw r18,r8
 774 02e6 BE01      		movw r22,r28
 775 02e8 615D      		subi r22,-47
 776 02ea 7F4F      		sbci r23,-1
 777 02ec 8981      		ldd r24,Y+1
 778 02ee 0E94 0000 		call disk_read
 779               	.LVL73:
 780 02f2 8823      		tst r24
 781 02f4 01F0      		breq .L57
1109:ff.c          **** 			}
 782               		.loc 1 1109 0
 783 02f6 FF24      		clr r15
 784 02f8 F394      		inc r15
 785               	.LVL74:
1108:ff.c          **** 				res = FR_DISK_ERR;
 786               		.loc 1 1108 0
 787 02fa 8824      		clr r8
 788 02fc 8A94      		dec r8
 789 02fe 982C      		mov r9,r8
 790 0300 5401      		movw r10,r8
 791               	.LVL75:
 792               	.L57:
1111:ff.c          **** 		}
 793               		.loc 1 1111 0
 794 0302 8BA6      		std Y+43,r8
 795 0304 9CA6      		std Y+44,r9
 796 0306 ADA6      		std Y+45,r10
 797 0308 BEA6      		std Y+46,r11
 798               	.L56:
1115:ff.c          **** 
 799               		.loc 1 1115 0
 800 030a 8F2D      		mov r24,r15
 801               	/* epilogue start */
 802 030c DF91      		pop r29
 803 030e CF91      		pop r28
 804               	.LVL76:
 805 0310 1F91      		pop r17
 806 0312 0F91      		pop r16
 807 0314 FF90      		pop r15
 808               	.LVL77:
 809 0316 BF90      		pop r11
 810 0318 AF90      		pop r10
 811 031a 9F90      		pop r9
 812 031c 8F90      		pop r8
 813               	.LVL78:
 814 031e 0895      		ret
 815               		.cfi_endproc
 816               	.LFE59:
 819               	move_window:
 820               	.LFB11:
1098:ff.c          **** 	FRESULT res = FR_OK;
 821               		.loc 1 1098 0
 822               		.cfi_startproc
 823               	.LVL79:
 824 0320 0F93      		push r16
 825               	.LCFI31:
 826               		.cfi_def_cfa_offset 3
 827               		.cfi_offset 16, -2
 828 0322 1F93      		push r17
 829               	.LCFI32:
 830               		.cfi_def_cfa_offset 4
 831               		.cfi_offset 17, -3
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 2 */
 835               	.L__stack_usage = 2
 836               	.LVL80:
1102:ff.c          **** #if !FF_FS_READONLY
 837               		.loc 1 1102 0
 838 0324 FC01      		movw r30,r24
 839 0326 03A5      		ldd r16,Z+43
 840 0328 14A5      		ldd r17,Z+44
 841 032a 25A5      		ldd r18,Z+45
 842 032c 36A5      		ldd r19,Z+46
 843 032e 0417      		cp r16,r20
 844 0330 1507      		cpc r17,r21
 845 0332 2607      		cpc r18,r22
 846 0334 3707      		cpc r19,r23
 847 0336 01F0      		breq .L62
 848               	/* epilogue start */
1115:ff.c          **** 
 849               		.loc 1 1115 0
 850 0338 1F91      		pop r17
 851 033a 0F91      		pop r16
 852 033c 0C94 0000 		jmp move_window.part.7
 853               	.LVL81:
 854               	.L62:
 855 0340 80E0      		ldi r24,0
 856               	.LVL82:
 857               	/* epilogue start */
 858 0342 1F91      		pop r17
 859 0344 0F91      		pop r16
 860 0346 0895      		ret
 861               		.cfi_endproc
 862               	.LFE11:
 864               		.section	.rodata.str1.1,"aMS",@progbits,1
 865               	.LC0:
 866 0000 4641 5433 		.string	"FAT32   "
 866      3220 2020 
 866      00
 867               		.text
 869               	check_fs.part.8:
 870               	.LFB60:
3298:ff.c          **** 	FATFS* fs,			/* Filesystem object */
 871               		.loc 1 3298 0
 872               		.cfi_startproc
 873               	.LVL83:
 874 0348 CF93      		push r28
 875               	.LCFI33:
 876               		.cfi_def_cfa_offset 3
 877               		.cfi_offset 28, -2
 878 034a DF93      		push r29
 879               	.LCFI34:
 880               		.cfi_def_cfa_offset 4
 881               		.cfi_offset 29, -3
 882               	/* prologue: function */
 883               	/* frame size = 0 */
 884               	/* stack size = 2 */
 885               	.L__stack_usage = 2
 886 034c FC01      		movw r30,r24
 887               	.LVL84:
 888               	.LBB124:
 889               	.LBB125:
 615:ff.c          **** 	return rv;
 890               		.loc 1 615 0
 891 034e DC01      		movw r26,r24
 892 0350 A35D      		subi r26,-45
 893 0352 BD4F      		sbci r27,-3
 894 0354 4D91      		ld r20,X+
 895 0356 5C91      		ld r21,X
 896               	.LVL85:
 897               	.LBE125:
 898               	.LBE124:
3313:ff.c          **** 	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near 
 899               		.loc 1 3313 0
 900 0358 87A5      		ldd r24,Z+47
 901               	.LVL86:
3314:ff.c          **** 		if (sign == 0xAA55 && !mem_cmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) return 0;	/* It is an F
 902               		.loc 1 3314 0
 903 035a 8B3E      		cpi r24,lo8(-21)
 904 035c 01F0      		breq .L64
 905 035e 885E      		subi r24,lo8(-(24))
 906               	.LVL87:
 907 0360 8230      		cpi r24,lo8(2)
 908 0362 00F0      		brlo .+2
 909 0364 00C0      		rjmp .L65
 910               	.L64:
3315:ff.c          **** 		/* FAT volumes formatted with early MS-DOS lack boot signature and FAT string, so that we need to
 911               		.loc 1 3315 0
 912 0366 4535      		cpi r20,85
 913 0368 6AEA      		ldi r22,-86
 914 036a 5607      		cpc r21,r22
 915 036c 01F4      		brne .L66
 916               	.LVL88:
 917 036e DF01      		movw r26,r30
 918 0370 AF57      		subi r26,127
 919 0372 BF4F      		sbci r27,-1
 920               	.LVL89:
 921 0374 C0E0      		ldi r28,lo8(.LC0)
 922 0376 D0E0      		ldi r29,hi8(.LC0)
 923 0378 9F01      		movw r18,r30
 924 037a 2757      		subi r18,119
 925 037c 3F4F      		sbci r19,-1
 926               	.LVL90:
 927               	.L68:
 928               	.LBB126:
 929               	.LBB127:
 715:ff.c          **** 	} while (--cnt && r == 0);
 930               		.loc 1 715 0
 931 037e 8D91      		ld r24,X+
 932               	.LVL91:
 933 0380 6991      		ld r22,Y+
 934 0382 90E0      		ldi r25,0
 935 0384 861B      		sub r24,r22
 936 0386 9109      		sbc r25,__zero_reg__
 937               	.LVL92:
 716:ff.c          **** 
 938               		.loc 1 716 0
 939 0388 A217      		cp r26,r18
 940 038a B307      		cpc r27,r19
 941 038c 01F0      		breq .L67
 942 038e 892B      		or r24,r25
 943 0390 01F0      		breq .L68
 944 0392 00C0      		rjmp .L66
 945               	.L67:
 946               	.LVL93:
 947               	.LBE127:
 948               	.LBE126:
3315:ff.c          **** 		/* FAT volumes formatted with early MS-DOS lack boot signature and FAT string, so that we need to
 949               		.loc 1 3315 0
 950 0394 892B      		or r24,r25
 951 0396 01F0      		breq .L70
 952               	.LVL94:
 953               	.L66:
 954               	.LBB128:
 955               	.LBB129:
 615:ff.c          **** 	return rv;
 956               		.loc 1 615 0
 957 0398 22AD      		ldd r18,Z+58
 958 039a 33AD      		ldd r19,Z+59
 959               	.LVL95:
 960               	.LBE129:
 961               	.LBE128:
3318:ff.c          **** 			b = fs->win[BPB_SecPerClus];
 962               		.loc 1 3318 0
 963 039c C901      		movw r24,r18
 964 039e 0197      		sbiw r24,1
 965 03a0 8223      		and r24,r18
 966 03a2 9323      		and r25,r19
 967 03a4 0097      		sbiw r24,0
 968 03a6 01F4      		brne .L65
 969 03a8 2115      		cp r18,__zero_reg__
 970 03aa 3240      		sbci r19,2
 971 03ac 01F4      		brne .L65
3319:ff.c          **** 			if (b != 0 && (b & (b - 1)) == 0						/* Properness of cluster size */
 972               		.loc 1 3319 0
 973 03ae 24AD      		ldd r18,Z+60
 974               	.LVL96:
3320:ff.c          **** 			&& (fs->win[BPB_NumFATs] == 1 || fs->win[BPB_NumFATs] == 2)	/* Properness of number of FATs */
 975               		.loc 1 3320 0
 976 03b0 2223      		tst r18
 977 03b2 01F0      		breq .L65
 978 03b4 30E0      		ldi r19,0
 979 03b6 B901      		movw r22,r18
 980 03b8 6150      		subi r22,1
 981 03ba 7109      		sbc r23,__zero_reg__
 982 03bc 2623      		and r18,r22
 983 03be 3723      		and r19,r23
 984               	.LVL97:
 985 03c0 232B      		or r18,r19
 986 03c2 01F4      		brne .L65
3321:ff.c          **** 			&& ld_word(fs->win + BPB_RootEntCnt) != 0				/* Properness of root entry count */
 987               		.loc 1 3321 0
 988 03c4 27AD      		ldd r18,Z+63
 989 03c6 2150      		subi r18,lo8(-(-1))
 990 03c8 2230      		cpi r18,lo8(2)
 991 03ca 00F4      		brsh .L65
 992               	.LBB130:
 993               	.LBB131:
 615:ff.c          **** 	return rv;
 994               		.loc 1 615 0
 995 03cc DF01      		movw r26,r30
 996 03ce A05C      		subi r26,-64
 997 03d0 BF4F      		sbci r27,-1
 998               	.LBE131:
 999               	.LBE130:
3322:ff.c          **** 			&& ld_word(fs->win + BPB_FATSz16) != 0) {				/* Properness of FAT size */
 1000               		.loc 1 3322 0
 1001 03d2 2D91      		ld r18,X+
 1002 03d4 3C91      		ld r19,X
 1003 03d6 232B      		or r18,r19
 1004 03d8 01F0      		breq .L65
 1005               	.LBB132:
 1006               	.LBB133:
 615:ff.c          **** 	return rv;
 1007               		.loc 1 615 0
 1008 03da EB5B      		subi r30,-69
 1009 03dc FF4F      		sbci r31,-1
 1010               	.LVL98:
 1011               	.LBE133:
 1012               	.LBE132:
3323:ff.c          **** 				return 0;	/* Sector can be presumed an FAT VBR */
 1013               		.loc 1 3323 0
 1014 03de 2081      		ld r18,Z
 1015 03e0 3181      		ldd r19,Z+1
 1016 03e2 232B      		or r18,r19
 1017 03e4 01F4      		brne .L69
 1018               	.LVL99:
 1019               	.L65:
3328:ff.c          **** }
 1020               		.loc 1 3328 0
 1021 03e6 4535      		cpi r20,85
 1022 03e8 5A4A      		sbci r21,-86
 1023 03ea 01F0      		breq .L71
 1024 03ec 83E0      		ldi r24,lo8(3)
 1025 03ee 90E0      		ldi r25,0
 1026 03f0 00C0      		rjmp .L69
 1027               	.LVL100:
 1028               	.L70:
3315:ff.c          **** 		/* FAT volumes formatted with early MS-DOS lack boot signature and FAT string, so that we need to
 1029               		.loc 1 3315 0
 1030 03f2 80E0      		ldi r24,0
 1031 03f4 90E0      		ldi r25,0
 1032 03f6 00C0      		rjmp .L69
 1033               	.LVL101:
 1034               	.L71:
3328:ff.c          **** }
 1035               		.loc 1 3328 0
 1036 03f8 82E0      		ldi r24,lo8(2)
 1037 03fa 90E0      		ldi r25,0
 1038               	.L69:
 1039               	/* epilogue start */
3329:ff.c          **** 
 1040               		.loc 1 3329 0
 1041 03fc DF91      		pop r29
 1042 03fe CF91      		pop r28
 1043 0400 0895      		ret
 1044               		.cfi_endproc
 1045               	.LFE60:
 1048               	get_fat.isra.10:
 1049               	.LFB62:
1178:ff.c          **** 	FFOBJID* obj,	/* Corresponding object */
 1050               		.loc 1 1178 0
 1051               		.cfi_startproc
 1052               	.LVL102:
 1053 0402 AF92      		push r10
 1054               	.LCFI35:
 1055               		.cfi_def_cfa_offset 3
 1056               		.cfi_offset 10, -2
 1057 0404 BF92      		push r11
 1058               	.LCFI36:
 1059               		.cfi_def_cfa_offset 4
 1060               		.cfi_offset 11, -3
 1061 0406 CF92      		push r12
 1062               	.LCFI37:
 1063               		.cfi_def_cfa_offset 5
 1064               		.cfi_offset 12, -4
 1065 0408 DF92      		push r13
 1066               	.LCFI38:
 1067               		.cfi_def_cfa_offset 6
 1068               		.cfi_offset 13, -5
 1069 040a EF92      		push r14
 1070               	.LCFI39:
 1071               		.cfi_def_cfa_offset 7
 1072               		.cfi_offset 14, -6
 1073 040c FF92      		push r15
 1074               	.LCFI40:
 1075               		.cfi_def_cfa_offset 8
 1076               		.cfi_offset 15, -7
 1077 040e 0F93      		push r16
 1078               	.LCFI41:
 1079               		.cfi_def_cfa_offset 9
 1080               		.cfi_offset 16, -8
 1081 0410 1F93      		push r17
 1082               	.LCFI42:
 1083               		.cfi_def_cfa_offset 10
 1084               		.cfi_offset 17, -9
 1085 0412 CF93      		push r28
 1086               	.LCFI43:
 1087               		.cfi_def_cfa_offset 11
 1088               		.cfi_offset 28, -10
 1089 0414 DF93      		push r29
 1090               	.LCFI44:
 1091               		.cfi_def_cfa_offset 12
 1092               		.cfi_offset 29, -11
 1093               	/* prologue: function */
 1094               	/* frame size = 0 */
 1095               	/* stack size = 10 */
 1096               	.L__stack_usage = 10
 1097               	.LVL103:
1188:ff.c          **** 		val = 1;	/* Internal error */
 1098               		.loc 1 1188 0
 1099 0416 4230      		cpi r20,2
 1100 0418 5105      		cpc r21,__zero_reg__
 1101 041a 6105      		cpc r22,__zero_reg__
 1102 041c 7105      		cpc r23,__zero_reg__
 1103 041e 00F4      		brsh .+2
 1104 0420 00C0      		rjmp .L94
 1105 0422 FC01      		movw r30,r24
 1106 0424 0389      		ldd r16,Z+19
 1107 0426 1489      		ldd r17,Z+20
 1108 0428 2589      		ldd r18,Z+21
 1109 042a 3689      		ldd r19,Z+22
 1110 042c 4017      		cp r20,r16
 1111 042e 5107      		cpc r21,r17
 1112 0430 6207      		cpc r22,r18
 1113 0432 7307      		cpc r23,r19
 1114 0434 00F0      		brlo .+2
 1115 0436 00C0      		rjmp .L94
 1116 0438 6A01      		movw r12,r20
 1117 043a 7B01      		movw r14,r22
 1118 043c 8C01      		movw r16,r24
 1119               	.LVL104:
1194:ff.c          **** 		case FS_FAT12 :
 1120               		.loc 1 1194 0
 1121 043e 8081      		ld r24,Z
 1122               	.LVL105:
 1123 0440 8230      		cpi r24,lo8(2)
 1124 0442 01F4      		brne .+2
 1125 0444 00C0      		rjmp .L85
 1126 0446 8330      		cpi r24,lo8(3)
 1127 0448 01F4      		brne .+2
 1128 044a 00C0      		rjmp .L86
 1129 044c 8130      		cpi r24,lo8(1)
 1130 044e 01F0      		breq .+2
 1131 0450 00C0      		rjmp .L94
 1132               	.LVL106:
1196:ff.c          **** 			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 1133               		.loc 1 1196 0
 1134 0452 EA01      		movw r28,r20
 1135 0454 D695      		lsr r29
 1136 0456 C795      		ror r28
 1137 0458 CC0D      		add r28,r12
 1138 045a DD1D      		adc r29,r13
 1139               	.LVL107:
1197:ff.c          **** 			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 1140               		.loc 1 1197 0
 1141 045c CE01      		movw r24,r28
 1142 045e 892F      		mov r24,r25
 1143 0460 9927      		clr r25
 1144 0462 8695      		lsr r24
 1145 0464 478D      		ldd r20,Z+31
 1146 0466 50A1      		ldd r21,Z+32
 1147 0468 61A1      		ldd r22,Z+33
 1148 046a 72A1      		ldd r23,Z+34
 1149               	.LVL108:
 1150 046c 480F      		add r20,r24
 1151 046e 591F      		adc r21,r25
 1152 0470 611D      		adc r22,__zero_reg__
 1153 0472 711D      		adc r23,__zero_reg__
 1154 0474 CF01      		movw r24,r30
 1155 0476 0E94 0000 		call move_window
 1156               	.LVL109:
 1157 047a 8823      		tst r24
 1158 047c 01F0      		breq .L88
 1159               	.LVL110:
 1160               	.L89:
1192:ff.c          **** 
 1161               		.loc 1 1192 0
 1162 047e 6FEF      		ldi r22,lo8(-1)
 1163 0480 7FEF      		ldi r23,lo8(-1)
 1164 0482 CB01      		movw r24,r22
 1165 0484 00C0      		rjmp .L84
 1166               	.LVL111:
 1167               	.L88:
1198:ff.c          **** 			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 1168               		.loc 1 1198 0
 1169 0486 5E01      		movw r10,r28
 1170 0488 FFEF      		ldi r31,-1
 1171 048a AF1A      		sub r10,r31
 1172 048c BF0A      		sbc r11,r31
 1173               	.LVL112:
 1174 048e D170      		andi r29,1
 1175 0490 C00F      		add r28,r16
 1176 0492 D11F      		adc r29,r17
 1177 0494 CFA5      		ldd r28,Y+47
 1178               	.LVL113:
1199:ff.c          **** 			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 1179               		.loc 1 1199 0
 1180 0496 C501      		movw r24,r10
 1181 0498 892F      		mov r24,r25
 1182 049a 9927      		clr r25
 1183 049c 8695      		lsr r24
 1184 049e F801      		movw r30,r16
 1185 04a0 478D      		ldd r20,Z+31
 1186 04a2 50A1      		ldd r21,Z+32
 1187 04a4 61A1      		ldd r22,Z+33
 1188 04a6 72A1      		ldd r23,Z+34
 1189 04a8 480F      		add r20,r24
 1190 04aa 591F      		adc r21,r25
 1191 04ac 611D      		adc r22,__zero_reg__
 1192 04ae 711D      		adc r23,__zero_reg__
 1193 04b0 C801      		movw r24,r16
 1194 04b2 0E94 0000 		call move_window
 1195               	.LVL114:
 1196 04b6 8111      		cpse r24,__zero_reg__
 1197 04b8 00C0      		rjmp .L89
1200:ff.c          **** 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 1198               		.loc 1 1200 0
 1199 04ba F1E0      		ldi r31,1
 1200 04bc BF22      		and r11,r31
 1201               	.LVL115:
 1202 04be F801      		movw r30,r16
 1203 04c0 EA0D      		add r30,r10
 1204 04c2 FB1D      		adc r31,r11
 1205 04c4 87A5      		ldd r24,Z+47
 1206 04c6 6C2F      		mov r22,r28
 1207 04c8 70E0      		ldi r23,0
 1208 04ca 782B      		or r23,r24
 1209               	.LVL116:
1201:ff.c          **** 			break;
 1210               		.loc 1 1201 0
 1211 04cc C0FE      		sbrs r12,0
 1212 04ce 00C0      		rjmp .L90
 1213 04d0 54E0      		ldi r21,4
 1214               		1:
 1215 04d2 7695      		lsr r23
 1216 04d4 6795      		ror r22
 1217 04d6 5A95      		dec r21
 1218 04d8 01F4      		brne 1b
 1219               	.LVL117:
 1220 04da 00C0      		rjmp .L95
 1221               	.LVL118:
 1222               	.L90:
 1223 04dc 7F70      		andi r23,15
 1224               	.LVL119:
 1225 04de 00C0      		rjmp .L95
 1226               	.L85:
1205:ff.c          **** 			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 1227               		.loc 1 1205 0
 1228 04e0 7727      		clr r23
 1229 04e2 6F2D      		mov r22,r15
 1230 04e4 5E2D      		mov r21,r14
 1231 04e6 4D2D      		mov r20,r13
 1232 04e8 878D      		ldd r24,Z+31
 1233 04ea 90A1      		ldd r25,Z+32
 1234 04ec A1A1      		ldd r26,Z+33
 1235 04ee B2A1      		ldd r27,Z+34
 1236 04f0 480F      		add r20,r24
 1237 04f2 591F      		adc r21,r25
 1238 04f4 6A1F      		adc r22,r26
 1239 04f6 7B1F      		adc r23,r27
 1240 04f8 CF01      		movw r24,r30
 1241 04fa 0E94 0000 		call move_window
 1242               	.LVL120:
 1243 04fe 8111      		cpse r24,__zero_reg__
 1244 0500 00C0      		rjmp .L89
 1245               	.LBB134:
 1246               	.LBB135:
 615:ff.c          **** 	return rv;
 1247               		.loc 1 615 0
 1248 0502 CC0C      		lsl r12
 1249 0504 DD1C      		rol r13
 1250               	.LVL121:
 1251 0506 E894      		clt
 1252 0508 C0F8      		bld r12,0
 1253 050a F1E0      		ldi r31,1
 1254 050c DF22      		and r13,r31
 1255 050e F801      		movw r30,r16
 1256 0510 EC0D      		add r30,r12
 1257 0512 FD1D      		adc r31,r13
 1258               	.LBE135:
 1259               	.LBE134:
1206:ff.c          **** 			break;
 1260               		.loc 1 1206 0
 1261 0514 67A5      		ldd r22,Z+47
 1262 0516 70A9      		ldd r23,Z+48
 1263               	.L95:
 1264 0518 80E0      		ldi r24,0
 1265 051a 90E0      		ldi r25,0
 1266               	.LVL122:
 1267 051c 00C0      		rjmp .L84
 1268               	.LVL123:
 1269               	.L86:
1210:ff.c          **** 			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upp
 1270               		.loc 1 1210 0
 1271 051e 878D      		ldd r24,Z+31
 1272 0520 90A1      		ldd r25,Z+32
 1273 0522 A1A1      		ldd r26,Z+33
 1274 0524 B2A1      		ldd r27,Z+34
 1275 0526 27E0      		ldi r18,7
 1276               		1:
 1277 0528 7695      		lsr r23
 1278 052a 6795      		ror r22
 1279 052c 5795      		ror r21
 1280 052e 4795      		ror r20
 1281 0530 2A95      		dec r18
 1282 0532 01F4      		brne 1b
 1283 0534 480F      		add r20,r24
 1284 0536 591F      		adc r21,r25
 1285 0538 6A1F      		adc r22,r26
 1286 053a 7B1F      		adc r23,r27
 1287 053c CF01      		movw r24,r30
 1288 053e 0E94 0000 		call move_window
 1289               	.LVL124:
 1290 0542 8111      		cpse r24,__zero_reg__
 1291 0544 00C0      		rjmp .L89
1211:ff.c          **** 			break;
 1292               		.loc 1 1211 0
 1293 0546 015D      		subi r16,-47
 1294 0548 1F4F      		sbci r17,-1
 1295               	.LVL125:
 1296 054a CC0C      		lsl r12
 1297 054c DD1C      		rol r13
 1298 054e CC0C      		lsl r12
 1299 0550 DD1C      		rol r13
 1300               	.LVL126:
 1301 0552 C601      		movw r24,r12
 1302 0554 8C7F      		andi r24,252
 1303 0556 9170      		andi r25,1
 1304 0558 800F      		add r24,r16
 1305 055a 911F      		adc r25,r17
 1306 055c 0E94 0000 		call ld_dword
 1307               	.LVL127:
 1308 0560 9F70      		andi r25,15
 1309               	.LVL128:
 1310 0562 00C0      		rjmp .L84
 1311               	.LVL129:
 1312               	.L94:
1241:ff.c          **** 		}
 1313               		.loc 1 1241 0
 1314 0564 61E0      		ldi r22,lo8(1)
 1315 0566 70E0      		ldi r23,0
 1316 0568 80E0      		ldi r24,0
 1317 056a 90E0      		ldi r25,0
 1318               	.LVL130:
 1319               	.L84:
 1320               	/* epilogue start */
1246:ff.c          **** 
 1321               		.loc 1 1246 0
 1322 056c DF91      		pop r29
 1323 056e CF91      		pop r28
 1324 0570 1F91      		pop r17
 1325 0572 0F91      		pop r16
 1326 0574 FF90      		pop r15
 1327 0576 EF90      		pop r14
 1328 0578 DF90      		pop r13
 1329 057a CF90      		pop r12
 1330 057c BF90      		pop r11
 1331 057e AF90      		pop r10
 1332 0580 0895      		ret
 1333               		.cfi_endproc
 1334               	.LFE62:
 1337               	dir_sdi.constprop.15:
 1338               	.LFB65:
1713:ff.c          **** 	DIR* dp,		/* Pointer to directory object */
 1339               		.loc 1 1713 0
 1340               		.cfi_startproc
 1341               	.LVL131:
 1342 0582 CF92      		push r12
 1343               	.LCFI45:
 1344               		.cfi_def_cfa_offset 3
 1345               		.cfi_offset 12, -2
 1346 0584 DF92      		push r13
 1347               	.LCFI46:
 1348               		.cfi_def_cfa_offset 4
 1349               		.cfi_offset 13, -3
 1350 0586 EF92      		push r14
 1351               	.LCFI47:
 1352               		.cfi_def_cfa_offset 5
 1353               		.cfi_offset 14, -4
 1354 0588 FF92      		push r15
 1355               	.LCFI48:
 1356               		.cfi_def_cfa_offset 6
 1357               		.cfi_offset 15, -5
 1358 058a 0F93      		push r16
 1359               	.LCFI49:
 1360               		.cfi_def_cfa_offset 7
 1361               		.cfi_offset 16, -6
 1362 058c 1F93      		push r17
 1363               	.LCFI50:
 1364               		.cfi_def_cfa_offset 8
 1365               		.cfi_offset 17, -7
 1366 058e CF93      		push r28
 1367               	.LCFI51:
 1368               		.cfi_def_cfa_offset 9
 1369               		.cfi_offset 28, -8
 1370 0590 DF93      		push r29
 1371               	.LCFI52:
 1372               		.cfi_def_cfa_offset 10
 1373               		.cfi_offset 29, -9
 1374               	/* prologue: function */
 1375               	/* frame size = 0 */
 1376               	/* stack size = 8 */
 1377               	.L__stack_usage = 8
 1378 0592 8C01      		movw r16,r24
 1379               	.LVL132:
1719:ff.c          **** 
 1380               		.loc 1 1719 0
 1381 0594 FC01      		movw r30,r24
 1382 0596 C081      		ld r28,Z
 1383 0598 D181      		ldd r29,Z+1
 1384               	.LVL133:
1725:ff.c          **** 	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 1385               		.loc 1 1725 0
 1386 059a 1686      		std Z+14,__zero_reg__
 1387 059c 1786      		std Z+15,__zero_reg__
 1388 059e 108A      		std Z+16,__zero_reg__
 1389 05a0 118A      		std Z+17,__zero_reg__
1726:ff.c          **** 	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 1390               		.loc 1 1726 0
 1391 05a2 C680      		ldd r12,Z+6
 1392 05a4 D780      		ldd r13,Z+7
 1393 05a6 E084      		ldd r14,Z+8
 1394 05a8 F184      		ldd r15,Z+9
 1395               	.LVL134:
1727:ff.c          **** 		clst = (DWORD)fs->dirbase;
 1396               		.loc 1 1727 0
 1397 05aa C114      		cp r12,__zero_reg__
 1398 05ac D104      		cpc r13,__zero_reg__
 1399 05ae E104      		cpc r14,__zero_reg__
 1400 05b0 F104      		cpc r15,__zero_reg__
 1401 05b2 01F4      		brne .L97
 1402 05b4 8881      		ld r24,Y
 1403               	.LVL135:
 1404 05b6 8330      		cpi r24,lo8(3)
 1405 05b8 00F0      		brlo .L98
1728:ff.c          **** 		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 1406               		.loc 1 1728 0
 1407 05ba 8BA1      		ldd r24,Y+35
 1408 05bc 9CA1      		ldd r25,Y+36
 1409 05be ADA1      		ldd r26,Y+37
 1410 05c0 BEA1      		ldd r27,Y+38
 1411               	.LVL136:
1732:ff.c          **** 		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 1412               		.loc 1 1732 0
 1413 05c2 0097      		sbiw r24,0
 1414 05c4 A105      		cpc r26,__zero_reg__
 1415 05c6 B105      		cpc r27,__zero_reg__
 1416 05c8 01F4      		brne .L105
 1417               	.LVL137:
 1418               	.L98:
1733:ff.c          **** 		dp->sect = fs->dirbase;
 1419               		.loc 1 1733 0
 1420 05ca 8F81      		ldd r24,Y+7
 1421 05cc 9885      		ldd r25,Y+8
 1422 05ce 892B      		or r24,r25
 1423 05d0 01F4      		brne .L99
 1424               	.L103:
 1425 05d2 82E0      		ldi r24,lo8(2)
 1426 05d4 00C0      		rjmp .L100
 1427               	.L99:
1734:ff.c          **** 
 1428               		.loc 1 1734 0
 1429 05d6 8BA1      		ldd r24,Y+35
 1430 05d8 9CA1      		ldd r25,Y+36
 1431 05da ADA1      		ldd r26,Y+37
 1432 05dc BEA1      		ldd r27,Y+38
 1433 05de F801      		movw r30,r16
 1434 05e0 868B      		std Z+22,r24
 1435 05e2 978B      		std Z+23,r25
 1436 05e4 A08F      		std Z+24,r26
 1437 05e6 B18F      		std Z+25,r27
 1438 05e8 00C0      		rjmp .L101
 1439               	.LVL138:
 1440               	.L105:
1732:ff.c          **** 		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 1441               		.loc 1 1732 0
 1442 05ea 6C01      		movw r12,r24
 1443 05ec 7D01      		movw r14,r26
 1444               	.LVL139:
 1445               	.L97:
1737:ff.c          **** 		while (ofs >= csz) {				/* Follow cluster chain */
 1446               		.loc 1 1737 0
 1447 05ee 8985      		ldd r24,Y+9
 1448 05f0 9A85      		ldd r25,Y+10
 1449               	.LVL140:
1738:ff.c          **** 			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 1450               		.loc 1 1738 0
 1451 05f2 892B      		or r24,r25
 1452 05f4 01F4      		brne .L102
 1453               	.LVL141:
 1454               	.L104:
1739:ff.c          **** 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 1455               		.loc 1 1739 0
 1456 05f6 B701      		movw r22,r14
 1457 05f8 A601      		movw r20,r12
 1458 05fa F801      		movw r30,r16
 1459 05fc 8081      		ld r24,Z
 1460 05fe 9181      		ldd r25,Z+1
 1461 0600 0E94 0000 		call get_fat.isra.10
 1462               	.LVL142:
 1463 0604 6B01      		movw r12,r22
 1464 0606 7C01      		movw r14,r24
 1465               	.LVL143:
1740:ff.c          **** 			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal 
 1466               		.loc 1 1740 0
 1467 0608 6F3F      		cpi r22,-1
 1468 060a 7F4F      		sbci r23,-1
 1469 060c 8F4F      		sbci r24,-1
 1470 060e 9F4F      		sbci r25,-1
 1471 0610 01F0      		breq .L106
1741:ff.c          **** 			ofs -= csz;
 1472               		.loc 1 1741 0
 1473 0612 82E0      		ldi r24,2
 1474 0614 C816      		cp r12,r24
 1475 0616 D104      		cpc r13,__zero_reg__
 1476 0618 E104      		cpc r14,__zero_reg__
 1477 061a F104      		cpc r15,__zero_reg__
 1478 061c 00F0      		brlo .L103
 1479 061e 8B89      		ldd r24,Y+19
 1480 0620 9C89      		ldd r25,Y+20
 1481 0622 AD89      		ldd r26,Y+21
 1482 0624 BE89      		ldd r27,Y+22
 1483 0626 C816      		cp r12,r24
 1484 0628 D906      		cpc r13,r25
 1485 062a EA06      		cpc r14,r26
 1486 062c FB06      		cpc r15,r27
 1487 062e 00F0      		brlo .L104
 1488 0630 00C0      		rjmp .L103
 1489               	.LVL144:
 1490               	.L102:
1744:ff.c          **** 	}
 1491               		.loc 1 1744 0
 1492 0632 B701      		movw r22,r14
 1493 0634 A601      		movw r20,r12
 1494 0636 CE01      		movw r24,r28
 1495               	.LVL145:
 1496 0638 0E94 0000 		call clst2sect
 1497               	.LVL146:
 1498 063c F801      		movw r30,r16
 1499 063e 668B      		std Z+22,r22
 1500 0640 778B      		std Z+23,r23
 1501 0642 808F      		std Z+24,r24
 1502 0644 918F      		std Z+25,r25
 1503               	.LVL147:
 1504               	.L101:
1746:ff.c          **** 	if (dp->sect == 0) return FR_INT_ERR;
 1505               		.loc 1 1746 0
 1506 0646 F801      		movw r30,r16
 1507 0648 C28A      		std Z+18,r12
 1508 064a D38A      		std Z+19,r13
 1509 064c E48A      		std Z+20,r14
 1510 064e F58A      		std Z+21,r15
1747:ff.c          **** 	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 1511               		.loc 1 1747 0
 1512 0650 8689      		ldd r24,Z+22
 1513 0652 9789      		ldd r25,Z+23
 1514 0654 A08D      		ldd r26,Z+24
 1515 0656 B18D      		ldd r27,Z+25
 1516 0658 892B      		or r24,r25
 1517 065a 8A2B      		or r24,r26
 1518 065c 8B2B      		or r24,r27
 1519 065e 01F4      		brne .+2
 1520 0660 00C0      		rjmp .L103
1749:ff.c          **** 
 1521               		.loc 1 1749 0
 1522 0662 AF96      		adiw r28,47
 1523               	.LVL148:
 1524 0664 D38F      		std Z+27,r29
 1525 0666 C28F      		std Z+26,r28
1751:ff.c          **** }
 1526               		.loc 1 1751 0
 1527 0668 80E0      		ldi r24,0
 1528 066a 00C0      		rjmp .L100
 1529               	.LVL149:
 1530               	.L106:
1740:ff.c          **** 			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal 
 1531               		.loc 1 1740 0
 1532 066c 81E0      		ldi r24,lo8(1)
 1533               	.LVL150:
 1534               	.L100:
 1535               	/* epilogue start */
1752:ff.c          **** 
 1536               		.loc 1 1752 0
 1537 066e DF91      		pop r29
 1538 0670 CF91      		pop r28
 1539 0672 1F91      		pop r17
 1540 0674 0F91      		pop r16
 1541               	.LVL151:
 1542 0676 FF90      		pop r15
 1543 0678 EF90      		pop r14
 1544 067a DF90      		pop r13
 1545 067c CF90      		pop r12
 1546 067e 0895      		ret
 1547               		.cfi_endproc
 1548               	.LFE65:
 1551               	dir_clear:
 1552               	.LFB18:
1678:ff.c          **** 	LBA_t sect;
 1553               		.loc 1 1678 0
 1554               		.cfi_startproc
 1555               	.LVL152:
 1556 0680 8F92      		push r8
 1557               	.LCFI53:
 1558               		.cfi_def_cfa_offset 3
 1559               		.cfi_offset 8, -2
 1560 0682 9F92      		push r9
 1561               	.LCFI54:
 1562               		.cfi_def_cfa_offset 4
 1563               		.cfi_offset 9, -3
 1564 0684 AF92      		push r10
 1565               	.LCFI55:
 1566               		.cfi_def_cfa_offset 5
 1567               		.cfi_offset 10, -4
 1568 0686 BF92      		push r11
 1569               	.LCFI56:
 1570               		.cfi_def_cfa_offset 6
 1571               		.cfi_offset 11, -5
 1572 0688 CF92      		push r12
 1573               	.LCFI57:
 1574               		.cfi_def_cfa_offset 7
 1575               		.cfi_offset 12, -6
 1576 068a DF92      		push r13
 1577               	.LCFI58:
 1578               		.cfi_def_cfa_offset 8
 1579               		.cfi_offset 13, -7
 1580 068c EF92      		push r14
 1581               	.LCFI59:
 1582               		.cfi_def_cfa_offset 9
 1583               		.cfi_offset 14, -8
 1584 068e FF92      		push r15
 1585               	.LCFI60:
 1586               		.cfi_def_cfa_offset 10
 1587               		.cfi_offset 15, -9
 1588 0690 0F93      		push r16
 1589               	.LCFI61:
 1590               		.cfi_def_cfa_offset 11
 1591               		.cfi_offset 16, -10
 1592 0692 1F93      		push r17
 1593               	.LCFI62:
 1594               		.cfi_def_cfa_offset 12
 1595               		.cfi_offset 17, -11
 1596 0694 CF93      		push r28
 1597               	.LCFI63:
 1598               		.cfi_def_cfa_offset 13
 1599               		.cfi_offset 28, -12
 1600 0696 DF93      		push r29
 1601               	.LCFI64:
 1602               		.cfi_def_cfa_offset 14
 1603               		.cfi_offset 29, -13
 1604               	/* prologue: function */
 1605               	/* frame size = 0 */
 1606               	/* stack size = 12 */
 1607               	.L__stack_usage = 12
 1608 0698 EC01      		movw r28,r24
 1609 069a 6A01      		movw r12,r20
 1610 069c 7B01      		movw r14,r22
1684:ff.c          **** 	sect = clst2sect(fs, clst);		/* Top of the cluster */
 1611               		.loc 1 1684 0
 1612 069e 0E94 0000 		call sync_window
 1613               	.LVL153:
 1614 06a2 8111      		cpse r24,__zero_reg__
 1615 06a4 00C0      		rjmp .L118
 1616               	.LVL154:
 1617               	.LBB140:
 1618               	.LBB141:
1685:ff.c          **** 	fs->winsect = sect;				/* Set window to top of the cluster */
 1619               		.loc 1 1685 0
 1620 06a6 B701      		movw r22,r14
 1621 06a8 A601      		movw r20,r12
 1622 06aa CE01      		movw r24,r28
 1623 06ac 0E94 0000 		call clst2sect
 1624               	.LVL155:
 1625 06b0 4B01      		movw r8,r22
 1626 06b2 5C01      		movw r10,r24
 1627               	.LVL156:
1686:ff.c          **** 	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 1628               		.loc 1 1686 0
 1629 06b4 6BA7      		std Y+43,r22
 1630 06b6 7CA7      		std Y+44,r23
 1631 06b8 8DA7      		std Y+45,r24
 1632 06ba 9EA7      		std Y+46,r25
1687:ff.c          **** #if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
 1633               		.loc 1 1687 0
 1634 06bc 6E01      		movw r12,r28
 1635               	.LVL157:
 1636 06be 8FE2      		ldi r24,47
 1637 06c0 C80E      		add r12,r24
 1638 06c2 D11C      		adc r13,__zero_reg__
 1639               	.LVL158:
 1640 06c4 F601      		movw r30,r12
 1641 06c6 CE01      		movw r24,r28
 1642 06c8 815D      		subi r24,-47
 1643 06ca 9D4F      		sbci r25,-3
 1644               	.LVL159:
 1645               	.L112:
 1646               	.LBB142:
 1647               	.LBB143:
 703:ff.c          **** 	} while (--cnt);
 1648               		.loc 1 703 0
 1649 06cc 1192      		st Z+,__zero_reg__
 1650               	.LVL160:
 704:ff.c          **** }
 1651               		.loc 1 704 0
 1652 06ce E817      		cp r30,r24
 1653 06d0 F907      		cpc r31,r25
 1654 06d2 01F4      		brne .L112
 1655 06d4 E12C      		mov r14,__zero_reg__
 1656 06d6 F12C      		mov r15,__zero_reg__
 1657               	.LVL161:
 1658               	.L113:
 1659               	.LBE143:
 1660               	.LBE142:
1700:ff.c          **** 	}
 1661               		.loc 1 1700 0
 1662 06d8 8985      		ldd r24,Y+9
 1663 06da 9A85      		ldd r25,Y+10
 1664 06dc E816      		cp r14,r24
 1665 06de F906      		cpc r15,r25
 1666 06e0 00F0      		brlo .L114
 1667               	.L117:
1702:ff.c          **** }
 1668               		.loc 1 1702 0
 1669 06e2 81E0      		ldi r24,lo8(1)
 1670 06e4 2985      		ldd r18,Y+9
 1671 06e6 3A85      		ldd r19,Y+10
 1672 06e8 2E15      		cp r18,r14
 1673 06ea 3F05      		cpc r19,r15
 1674 06ec 01F4      		brne .L111
 1675 06ee 80E0      		ldi r24,0
 1676               	.LVL162:
 1677 06f0 00C0      		rjmp .L111
 1678               	.LVL163:
 1679               	.L114:
1700:ff.c          **** 	}
 1680               		.loc 1 1700 0
 1681 06f2 01E0      		ldi r16,lo8(1)
 1682 06f4 10E0      		ldi r17,0
 1683 06f6 A501      		movw r20,r10
 1684 06f8 9401      		movw r18,r8
 1685 06fa 2E0D      		add r18,r14
 1686 06fc 3F1D      		adc r19,r15
 1687 06fe 411D      		adc r20,__zero_reg__
 1688 0700 511D      		adc r21,__zero_reg__
 1689 0702 B601      		movw r22,r12
 1690 0704 8981      		ldd r24,Y+1
 1691 0706 0E94 0000 		call disk_write
 1692               	.LVL164:
 1693 070a 8111      		cpse r24,__zero_reg__
 1694 070c 00C0      		rjmp .L117
 1695 070e 8FEF      		ldi r24,-1
 1696 0710 E81A      		sub r14,r24
 1697 0712 F80A      		sbc r15,r24
 1698               	.LVL165:
 1699 0714 00C0      		rjmp .L113
 1700               	.LVL166:
 1701               	.L118:
 1702               	.LBE141:
 1703               	.LBE140:
1684:ff.c          **** 	sect = clst2sect(fs, clst);		/* Top of the cluster */
 1704               		.loc 1 1684 0
 1705 0716 81E0      		ldi r24,lo8(1)
 1706               	.LVL167:
 1707               	.L111:
 1708               	/* epilogue start */
1703:ff.c          **** #endif	/* !FF_FS_READONLY */
 1709               		.loc 1 1703 0
 1710 0718 DF91      		pop r29
 1711 071a CF91      		pop r28
 1712               	.LVL168:
 1713 071c 1F91      		pop r17
 1714 071e 0F91      		pop r16
 1715 0720 FF90      		pop r15
 1716 0722 EF90      		pop r14
 1717 0724 DF90      		pop r13
 1718 0726 CF90      		pop r12
 1719 0728 BF90      		pop r11
 1720 072a AF90      		pop r10
 1721 072c 9F90      		pop r9
 1722 072e 8F90      		pop r8
 1723 0730 0895      		ret
 1724               		.cfi_endproc
 1725               	.LFE18:
 1728               	mount_volume:
 1729               	.LFB34:
3394:ff.c          **** 	int vol;
 1730               		.loc 1 3394 0
 1731               		.cfi_startproc
 1732               	.LVL169:
 1733 0732 4F92      		push r4
 1734               	.LCFI65:
 1735               		.cfi_def_cfa_offset 3
 1736               		.cfi_offset 4, -2
 1737 0734 5F92      		push r5
 1738               	.LCFI66:
 1739               		.cfi_def_cfa_offset 4
 1740               		.cfi_offset 5, -3
 1741 0736 6F92      		push r6
 1742               	.LCFI67:
 1743               		.cfi_def_cfa_offset 5
 1744               		.cfi_offset 6, -4
 1745 0738 7F92      		push r7
 1746               	.LCFI68:
 1747               		.cfi_def_cfa_offset 6
 1748               		.cfi_offset 7, -5
 1749 073a 8F92      		push r8
 1750               	.LCFI69:
 1751               		.cfi_def_cfa_offset 7
 1752               		.cfi_offset 8, -6
 1753 073c 9F92      		push r9
 1754               	.LCFI70:
 1755               		.cfi_def_cfa_offset 8
 1756               		.cfi_offset 9, -7
 1757 073e AF92      		push r10
 1758               	.LCFI71:
 1759               		.cfi_def_cfa_offset 9
 1760               		.cfi_offset 10, -8
 1761 0740 BF92      		push r11
 1762               	.LCFI72:
 1763               		.cfi_def_cfa_offset 10
 1764               		.cfi_offset 11, -9
 1765 0742 CF92      		push r12
 1766               	.LCFI73:
 1767               		.cfi_def_cfa_offset 11
 1768               		.cfi_offset 12, -10
 1769 0744 DF92      		push r13
 1770               	.LCFI74:
 1771               		.cfi_def_cfa_offset 12
 1772               		.cfi_offset 13, -11
 1773 0746 EF92      		push r14
 1774               	.LCFI75:
 1775               		.cfi_def_cfa_offset 13
 1776               		.cfi_offset 14, -12
 1777 0748 FF92      		push r15
 1778               	.LCFI76:
 1779               		.cfi_def_cfa_offset 14
 1780               		.cfi_offset 15, -13
 1781 074a 0F93      		push r16
 1782               	.LCFI77:
 1783               		.cfi_def_cfa_offset 15
 1784               		.cfi_offset 16, -14
 1785 074c 1F93      		push r17
 1786               	.LCFI78:
 1787               		.cfi_def_cfa_offset 16
 1788               		.cfi_offset 17, -15
 1789 074e CF93      		push r28
 1790               	.LCFI79:
 1791               		.cfi_def_cfa_offset 17
 1792               		.cfi_offset 28, -16
 1793 0750 DF93      		push r29
 1794               	.LCFI80:
 1795               		.cfi_def_cfa_offset 18
 1796               		.cfi_offset 29, -17
 1797 0752 CDB7      		in r28,__SP_L__
 1798 0754 DEB7      		in r29,__SP_H__
 1799               	.LCFI81:
 1800               		.cfi_def_cfa_register 28
 1801 0756 A097      		sbiw r28,32
 1802               	.LCFI82:
 1803               		.cfi_def_cfa_offset 50
 1804 0758 0FB6      		in __tmp_reg__,__SREG__
 1805 075a F894      		cli
 1806 075c DEBF      		out __SP_H__,r29
 1807 075e 0FBE      		out __SREG__,__tmp_reg__
 1808 0760 CDBF      		out __SP_L__,r28
 1809               	/* prologue: function */
 1810               	/* frame size = 32 */
 1811               	/* stack size = 48 */
 1812               	.L__stack_usage = 48
 1813 0762 5B01      		movw r10,r22
 1814 0764 F42E      		mov r15,r20
3405:ff.c          **** 	vol = get_ldnumber(path);
 1815               		.loc 1 3405 0
 1816 0766 DB01      		movw r26,r22
 1817 0768 1D92      		st X+,__zero_reg__
 1818 076a 1C92      		st X,__zero_reg__
3406:ff.c          **** 	if (vol < 0) return FR_INVALID_DRIVE;
 1819               		.loc 1 3406 0
 1820 076c 0E94 0000 		call get_ldnumber
 1821               	.LVL170:
 1822 0770 6C01      		movw r12,r24
 1823               	.LVL171:
3407:ff.c          **** 
 1824               		.loc 1 3407 0
 1825 0772 97FD      		sbrc r25,7
 1826 0774 00C0      		rjmp .L142
3410:ff.c          **** 	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 1827               		.loc 1 3410 0
 1828 0776 FC01      		movw r30,r24
 1829 0778 EE0F      		lsl r30
 1830 077a FF1F      		rol r31
 1831 077c E050      		subi r30,lo8(-(FatFs))
 1832 077e F040      		sbci r31,hi8(-(FatFs))
 1833 0780 0081      		ld r16,Z
 1834 0782 1181      		ldd r17,Z+1
 1835               	.LVL172:
3411:ff.c          **** #if FF_FS_REENTRANT
 1836               		.loc 1 3411 0
 1837 0784 0115      		cp r16,__zero_reg__
 1838 0786 1105      		cpc r17,__zero_reg__
 1839 0788 01F4      		brne .+2
 1840 078a 00C0      		rjmp .L143
3415:ff.c          **** 
 1841               		.loc 1 3415 0
 1842 078c F501      		movw r30,r10
 1843 078e 1183      		std Z+1,r17
 1844 0790 0083      		st Z,r16
3417:ff.c          **** 	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 1845               		.loc 1 3417 0
 1846 0792 FF2D      		mov r31,r15
 1847 0794 FE7F      		andi r31,lo8(-2)
 1848 0796 FF2E      		mov r15,r31
 1849               	.LVL173:
3418:ff.c          **** 		stat = disk_status(fs->pdrv);
 1850               		.loc 1 3418 0
 1851 0798 D801      		movw r26,r16
 1852 079a 8C91      		ld r24,X
 1853 079c 8823      		tst r24
 1854 079e 01F0      		breq .L122
3419:ff.c          **** 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 1855               		.loc 1 3419 0
 1856 07a0 1196      		adiw r26,1
 1857 07a2 8C91      		ld r24,X
 1858 07a4 0E94 0000 		call disk_status
 1859               	.LVL174:
3420:ff.c          **** 			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 1860               		.loc 1 3420 0
 1861 07a8 80FD      		sbrc r24,0
 1862 07aa 00C0      		rjmp .L122
3421:ff.c          **** 				return FR_WRITE_PROTECTED;
 1863               		.loc 1 3421 0
 1864 07ac FF20      		tst r15
 1865 07ae 01F4      		brne .+2
 1866 07b0 00C0      		rjmp .L145
3421:ff.c          **** 				return FR_WRITE_PROTECTED;
 1867               		.loc 1 3421 0 is_stmt 0 discriminator 1
 1868 07b2 82FF      		sbrs r24,2
 1869 07b4 00C0      		rjmp .L145
 1870               	.L124:
3422:ff.c          **** 			}
 1871               		.loc 1 3422 0 is_stmt 1
 1872 07b6 8AE0      		ldi r24,lo8(10)
 1873               	.LVL175:
 1874 07b8 00C0      		rjmp .L171
 1875               	.L122:
3431:ff.c          **** 	fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
 1876               		.loc 1 3431 0
 1877 07ba F801      		movw r30,r16
 1878 07bc 1082      		st Z,__zero_reg__
3432:ff.c          **** 	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 1879               		.loc 1 3432 0
 1880 07be C182      		std Z+1,r12
3433:ff.c          **** 	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 1881               		.loc 1 3433 0
 1882 07c0 8C2D      		mov r24,r12
 1883 07c2 0E94 0000 		call disk_initialize
 1884               	.LVL176:
3434:ff.c          **** 		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 1885               		.loc 1 3434 0
 1886 07c6 80FD      		sbrc r24,0
 1887 07c8 00C0      		rjmp .L146
3437:ff.c          **** 		return FR_WRITE_PROTECTED;
 1888               		.loc 1 3437 0
 1889 07ca FF20      		tst r15
 1890 07cc 01F0      		breq .L123
3437:ff.c          **** 		return FR_WRITE_PROTECTED;
 1891               		.loc 1 3437 0 is_stmt 0 discriminator 1
 1892 07ce 82FD      		sbrc r24,2
 1893 07d0 00C0      		rjmp .L124
 1894               	.L123:
 1895               	.LVL177:
 1896               	.LBB168:
 1897               	.LBB169:
 1898               	.LBB170:
 1899               	.LBB171:
3307:ff.c          **** 	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 1900               		.loc 1 3307 0 is_stmt 1
 1901 07d2 D801      		movw r26,r16
 1902 07d4 1396      		adiw r26,3
 1903 07d6 1C92      		st X,__zero_reg__
 1904 07d8 8FEF      		ldi r24,lo8(-1)
 1905 07da 9FEF      		ldi r25,lo8(-1)
 1906 07dc DC01      		movw r26,r24
 1907               	.LVL178:
 1908 07de F801      		movw r30,r16
 1909 07e0 83A7      		std Z+43,r24
 1910 07e2 94A7      		std Z+44,r25
 1911 07e4 A5A7      		std Z+45,r26
 1912 07e6 B6A7      		std Z+46,r27
 1913               	.LVL179:
 1914               	.LBB172:
 1915               	.LBB173:
 1916 07e8 40E0      		ldi r20,0
 1917 07ea 50E0      		ldi r21,0
 1918 07ec BA01      		movw r22,r20
 1919 07ee C801      		movw r24,r16
 1920 07f0 0E94 0000 		call move_window.part.7
 1921               	.LVL180:
 1922               	.LBE173:
 1923               	.LBE172:
3308:ff.c          **** 	sign = ld_word(fs->win + BS_55AA);
 1924               		.loc 1 3308 0
 1925 07f4 8111      		cpse r24,__zero_reg__
 1926 07f6 00C0      		rjmp .L147
 1927 07f8 C801      		movw r24,r16
 1928 07fa 0E94 0000 		call check_fs.part.8
 1929               	.LVL181:
 1930               	.LBE171:
 1931               	.LBE170:
3345:ff.c          **** 
 1932               		.loc 1 3345 0
 1933 07fe 8230      		cpi r24,2
 1934 0800 9105      		cpc r25,__zero_reg__
 1935 0802 01F0      		breq .+2
 1936 0804 00C0      		rjmp .L125
 1937 0806 6801      		movw r12,r16
 1938               	.LVL182:
 1939 0808 FBE0      		ldi r31,11
 1940 080a CF1A      		sub r12,r31
 1941 080c FEEF      		ldi r31,-2
 1942 080e DF0A      		sbc r13,r31
 1943 0810 9E01      		movw r18,r28
 1944 0812 2F5F      		subi r18,-1
 1945 0814 3F4F      		sbci r19,-1
 1946 0816 7901      		movw r14,r18
 1947 0818 4801      		movw r8,r16
 1948 081a 3BEC      		ldi r19,-53
 1949 081c 831A      		sub r8,r19
 1950 081e 3DEF      		ldi r19,-3
 1951 0820 930A      		sbc r9,r19
 1952 0822 5701      		movw r10,r14
 1953               	.LVL183:
 1954               	.L126:
3373:ff.c          **** 	}
 1955               		.loc 1 3373 0
 1956 0824 C601      		movw r24,r12
 1957 0826 0E94 0000 		call ld_dword
 1958               	.LVL184:
 1959 082a D501      		movw r26,r10
 1960 082c 6D93      		st X+,r22
 1961 082e 7D93      		st X+,r23
 1962 0830 8D93      		st X+,r24
 1963 0832 9D93      		st X+,r25
 1964 0834 5D01      		movw r10,r26
 1965               	.LVL185:
 1966 0836 B0E1      		ldi r27,16
 1967 0838 CB0E      		add r12,r27
 1968 083a D11C      		adc r13,__zero_reg__
3372:ff.c          **** 		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 1969               		.loc 1 3372 0
 1970 083c C814      		cp r12,r8
 1971 083e D904      		cpc r13,r9
 1972 0840 01F4      		brne .L126
 1973 0842 6E01      		movw r12,r28
 1974 0844 E1E1      		ldi r30,17
 1975 0846 CE0E      		add r12,r30
 1976 0848 D11C      		adc r13,__zero_reg__
 1977               	.LBB175:
 1978               	.LBB176:
3307:ff.c          **** 	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 1979               		.loc 1 3307 0
 1980 084a 8824      		clr r8
 1981 084c 8A94      		dec r8
 1982 084e 982C      		mov r9,r8
 1983 0850 5401      		movw r10,r8
 1984               	.L128:
 1985               	.LBE176:
 1986               	.LBE175:
3377:ff.c          **** 	} while (part == 0 && fmt >= 2 && ++i < 4);
 1987               		.loc 1 3377 0
 1988 0852 D701      		movw r26,r14
 1989 0854 4D91      		ld r20,X+
 1990 0856 5D91      		ld r21,X+
 1991 0858 6D91      		ld r22,X+
 1992 085a 7D91      		ld r23,X+
 1993 085c 7D01      		movw r14,r26
 1994 085e 4115      		cp r20,__zero_reg__
 1995 0860 5105      		cpc r21,__zero_reg__
 1996 0862 6105      		cpc r22,__zero_reg__
 1997 0864 7105      		cpc r23,__zero_reg__
 1998 0866 01F4      		brne .+2
 1999 0868 00C0      		rjmp .L148
 2000               	.LVL186:
 2001               	.LBB179:
 2002               	.LBB177:
3307:ff.c          **** 	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 2003               		.loc 1 3307 0
 2004 086a F801      		movw r30,r16
 2005 086c 1382      		std Z+3,__zero_reg__
 2006 086e 83A6      		std Z+43,r8
 2007 0870 94A6      		std Z+44,r9
 2008 0872 A5A6      		std Z+45,r10
 2009 0874 B6A6      		std Z+46,r11
3308:ff.c          **** 	sign = ld_word(fs->win + BS_55AA);
 2010               		.loc 1 3308 0
 2011 0876 C801      		movw r24,r16
 2012 0878 0E94 0000 		call move_window
 2013               	.LVL187:
 2014 087c 8111      		cpse r24,__zero_reg__
 2015 087e 00C0      		rjmp .L149
 2016 0880 C801      		movw r24,r16
 2017 0882 0E94 0000 		call check_fs.part.8
 2018               	.LVL188:
 2019               	.LBE177:
 2020               	.LBE179:
3378:ff.c          **** 	return fmt;
 2021               		.loc 1 3378 0
 2022 0886 8230      		cpi r24,2
 2023 0888 9105      		cpc r25,__zero_reg__
 2024 088a 00F0      		brlo .L125
 2025               	.LVL189:
 2026               	.L141:
 2027 088c CE14      		cp r12,r14
 2028 088e DF04      		cpc r13,r15
 2029 0890 01F4      		brne .L128
 2030 0892 00C0      		rjmp .L125
 2031               	.LVL190:
 2032               	.L147:
 2033               	.LBB180:
 2034               	.LBB174:
3308:ff.c          **** 	sign = ld_word(fs->win + BS_55AA);
 2035               		.loc 1 3308 0
 2036 0894 84E0      		ldi r24,lo8(4)
 2037 0896 90E0      		ldi r25,0
 2038               	.LVL191:
 2039               	.L125:
 2040               	.LBE174:
 2041               	.LBE180:
 2042               	.LBE169:
 2043               	.LBE168:
3447:ff.c          **** 	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 2044               		.loc 1 3447 0
 2045 0898 8430      		cpi r24,4
 2046 089a 9105      		cpc r25,__zero_reg__
 2047 089c 01F4      		brne .+2
 2048 089e 00C0      		rjmp .L151
3448:ff.c          **** 	bsect = fs->winsect;					/* Volume location */
 2049               		.loc 1 3448 0
 2050 08a0 0297      		sbiw r24,2
 2051 08a2 00F0      		brlo .L129
 2052               	.L130:
 2053 08a4 8DE0      		ldi r24,lo8(13)
 2054 08a6 00C0      		rjmp .L171
 2055               	.L129:
 2056               	.LVL192:
3517:ff.c          **** 
 2057               		.loc 1 3517 0
 2058 08a8 F801      		movw r30,r16
 2059 08aa 82AD      		ldd r24,Z+58
 2060 08ac 93AD      		ldd r25,Z+59
 2061 08ae 8115      		cp r24,__zero_reg__
 2062 08b0 9240      		sbci r25,2
 2063 08b2 01F4      		brne .L130
 2064               	.LVL193:
 2065               	.LBB183:
 2066               	.LBB184:
 615:ff.c          **** 	return rv;
 2067               		.loc 1 615 0
 2068 08b4 F801      		movw r30,r16
 2069 08b6 EB5B      		subi r30,-69
 2070 08b8 FF4F      		sbci r31,-1
 2071 08ba 4080      		ld r4,Z
 2072 08bc 5180      		ldd r5,Z+1
 2073               	.LVL194:
 2074               	.LBE184:
 2075               	.LBE183:
3520:ff.c          **** 		fs->fsize = fasize;
 2076               		.loc 1 3520 0
 2077 08be 4114      		cp r4,__zero_reg__
 2078 08c0 5104      		cpc r5,__zero_reg__
 2079 08c2 01F0      		breq .L131
3519:ff.c          **** 		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 2080               		.loc 1 3519 0
 2081 08c4 612C      		mov r6,__zero_reg__
 2082 08c6 712C      		mov r7,__zero_reg__
 2083 08c8 00C0      		rjmp .L132
 2084               	.L131:
3520:ff.c          **** 		fs->fsize = fasize;
 2085               		.loc 1 3520 0 discriminator 1
 2086 08ca C801      		movw r24,r16
 2087 08cc 8D5A      		subi r24,-83
 2088 08ce 9F4F      		sbci r25,-1
 2089 08d0 0E94 0000 		call ld_dword
 2090               	.LVL195:
 2091 08d4 2B01      		movw r4,r22
 2092 08d6 3C01      		movw r6,r24
 2093               	.LVL196:
 2094               	.L132:
3449:ff.c          **** 
 2095               		.loc 1 3449 0
 2096 08d8 D801      		movw r26,r16
 2097 08da 9B96      		adiw r26,43
 2098 08dc 2D91      		ld r18,X+
 2099 08de 3D91      		ld r19,X+
 2100 08e0 4D91      		ld r20,X+
 2101 08e2 5C91      		ld r21,X
 2102 08e4 9E97      		sbiw r26,43+3
 2103 08e6 298B      		std Y+17,r18
 2104 08e8 3A8B      		std Y+18,r19
 2105 08ea 4B8B      		std Y+19,r20
 2106 08ec 5C8B      		std Y+20,r21
 2107               	.LVL197:
3521:ff.c          **** 
 2108               		.loc 1 3521 0
 2109 08ee F801      		movw r30,r16
 2110 08f0 478A      		std Z+23,r4
 2111 08f2 508E      		std Z+24,r5
 2112 08f4 618E      		std Z+25,r6
 2113 08f6 728E      		std Z+26,r7
3523:ff.c          **** 		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 2114               		.loc 1 3523 0
 2115 08f8 A7AC      		ldd r10,Z+63
 2116 08fa A282      		std Z+2,r10
3524:ff.c          **** 		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 2117               		.loc 1 3524 0
 2118 08fc 8FEF      		ldi r24,lo8(-1)
 2119 08fe 8A0D      		add r24,r10
 2120 0900 8230      		cpi r24,lo8(2)
 2121 0902 00F4      		brsh .L130
 2122               	.LVL198:
3527:ff.c          **** 		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power o
 2123               		.loc 1 3527 0
 2124 0904 B4AC      		ldd r11,Z+60
 2125 0906 8B2D      		mov r24,r11
 2126 0908 90E0      		ldi r25,0
 2127 090a 9287      		std Z+10,r25
 2128 090c 8187      		std Z+9,r24
3528:ff.c          **** 
 2129               		.loc 1 3528 0
 2130 090e 0097      		sbiw r24,0
 2131 0910 01F0      		breq .L130
3528:ff.c          **** 
 2132               		.loc 1 3528 0 is_stmt 0 discriminator 2
 2133 0912 9C01      		movw r18,r24
 2134 0914 2150      		subi r18,1
 2135 0916 3109      		sbc r19,__zero_reg__
 2136 0918 8223      		and r24,r18
 2137 091a 9323      		and r25,r19
 2138 091c 892B      		or r24,r25
 2139 091e 01F4      		brne .L130
 2140               	.LVL199:
 2141               	.LBB185:
 2142               	.LBB186:
 615:ff.c          **** 	return rv;
 2143               		.loc 1 615 0 is_stmt 1
 2144 0920 E05C      		subi r30,-64
 2145 0922 FF4F      		sbci r31,-1
 2146 0924 8080      		ld r8,Z
 2147 0926 9180      		ldd r9,Z+1
 2148               	.LVL200:
 2149               	.LBE186:
 2150               	.LBE185:
3530:ff.c          **** 		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 2151               		.loc 1 3530 0
 2152 0928 1896      		adiw r26,7+1
 2153 092a 9C92      		st X,r9
 2154 092c 8E92      		st -X,r8
 2155 092e 1797      		sbiw r26,7
3531:ff.c          **** 
 2156               		.loc 1 3531 0
 2157 0930 C401      		movw r24,r8
 2158 0932 8F70      		andi r24,15
 2159 0934 9927      		clr r25
 2160 0936 892B      		or r24,r25
 2161 0938 01F0      		breq .+2
 2162 093a 00C0      		rjmp .L130
 2163               	.LVL201:
 2164               	.LBB187:
 2165               	.LBB188:
 615:ff.c          **** 	return rv;
 2166               		.loc 1 615 0
 2167 093c 3296      		adiw r30,2
 2168 093e 8081      		ld r24,Z
 2169 0940 9181      		ldd r25,Z+1
 2170               	.LVL202:
 2171               	.LBE188:
 2172               	.LBE187:
3533:ff.c          **** 		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 2173               		.loc 1 3533 0
 2174 0942 6C01      		movw r12,r24
 2175 0944 E12C      		mov r14,__zero_reg__
 2176 0946 F12C      		mov r15,__zero_reg__
 2177               	.LVL203:
3534:ff.c          **** 
 2178               		.loc 1 3534 0
 2179 0948 892B      		or r24,r25
 2180 094a 01F4      		brne .L133
3534:ff.c          **** 
 2181               		.loc 1 3534 0 is_stmt 0 discriminator 1
 2182 094c C801      		movw r24,r16
 2183 094e 815B      		subi r24,-79
 2184 0950 9F4F      		sbci r25,-1
 2185 0952 0E94 0000 		call ld_dword
 2186               	.LVL204:
 2187 0956 6B01      		movw r12,r22
 2188 0958 7C01      		movw r14,r24
 2189               	.LVL205:
 2190               	.L133:
 2191               	.LBB189:
 2192               	.LBB190:
 615:ff.c          **** 	return rv;
 2193               		.loc 1 615 0 is_stmt 1
 2194 095a D801      		movw r26,r16
 2195 095c DD96      		adiw r26,61
 2196 095e ED91      		ld r30,X+
 2197 0960 FC91      		ld r31,X
 2198 0962 DE97      		sbiw r26,61+1
 2199               	.LVL206:
 2200               	.LBE190:
 2201               	.LBE189:
3537:ff.c          **** 
 2202               		.loc 1 3537 0
 2203 0964 3097      		sbiw r30,0
 2204 0966 01F4      		brne .+2
 2205 0968 00C0      		rjmp .L130
3525:ff.c          **** 
 2206               		.loc 1 3525 0
 2207 096a AA2D      		mov r26,r10
 2208 096c B0E0      		ldi r27,0
 2209 096e A301      		movw r20,r6
 2210 0970 9201      		movw r18,r4
 2211 0972 0E94 0000 		call __muluhisi3
 2212 0976 698F      		std Y+25,r22
 2213 0978 7A8F      		std Y+26,r23
 2214 097a 8B8F      		std Y+27,r24
 2215 097c 9C8F      		std Y+28,r25
3540:ff.c          **** 		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 2216               		.loc 1 3540 0
 2217 097e 9F01      		movw r18,r30
 2218 0980 40E0      		ldi r20,0
 2219 0982 50E0      		ldi r21,0
 2220 0984 2D8F      		std Y+29,r18
 2221 0986 3E8F      		std Y+30,r19
 2222 0988 4F8F      		std Y+31,r20
 2223 098a 58A3      		std Y+32,r21
 2224 098c C401      		movw r24,r8
 2225 098e F4E0      		ldi r31,4
 2226               		1:
 2227 0990 9695      		lsr r25
 2228 0992 8795      		ror r24
 2229 0994 FA95      		dec r31
 2230 0996 01F4      		brne 1b
 2231 0998 280F      		add r18,r24
 2232 099a 391F      		adc r19,r25
 2233 099c 411D      		adc r20,__zero_reg__
 2234 099e 511D      		adc r21,__zero_reg__
 2235 09a0 DA01      		movw r26,r20
 2236 09a2 C901      		movw r24,r18
 2237 09a4 298D      		ldd r18,Y+25
 2238 09a6 3A8D      		ldd r19,Y+26
 2239 09a8 4B8D      		ldd r20,Y+27
 2240 09aa 5C8D      		ldd r21,Y+28
 2241 09ac 280F      		add r18,r24
 2242 09ae 391F      		adc r19,r25
 2243 09b0 4A1F      		adc r20,r26
 2244 09b2 5B1F      		adc r21,r27
 2245 09b4 2D8B      		std Y+21,r18
 2246 09b6 3E8B      		std Y+22,r19
 2247 09b8 4F8B      		std Y+23,r20
 2248 09ba 588F      		std Y+24,r21
 2249               	.LVL207:
3541:ff.c          **** 		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 2250               		.loc 1 3541 0
 2251 09bc C216      		cp r12,r18
 2252 09be D306      		cpc r13,r19
 2253 09c0 E406      		cpc r14,r20
 2254 09c2 F506      		cpc r15,r21
 2255 09c4 00F4      		brsh .+2
 2256 09c6 00C0      		rjmp .L130
3542:ff.c          **** 		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 2257               		.loc 1 3542 0
 2258 09c8 C701      		movw r24,r14
 2259 09ca B601      		movw r22,r12
 2260 09cc 621B      		sub r22,r18
 2261 09ce 730B      		sbc r23,r19
 2262 09d0 840B      		sbc r24,r20
 2263 09d2 950B      		sbc r25,r21
 2264 09d4 2B2D      		mov r18,r11
 2265               	.LVL208:
 2266 09d6 30E0      		ldi r19,0
 2267 09d8 40E0      		ldi r20,0
 2268 09da 50E0      		ldi r21,0
 2269 09dc 0E94 0000 		call __udivmodsi4
 2270               	.LVL209:
3543:ff.c          **** 		fmt = 0;
 2271               		.loc 1 3543 0
 2272 09e0 DA01      		movw r26,r20
 2273 09e2 C901      		movw r24,r18
 2274 09e4 0197      		sbiw r24,1
 2275 09e6 A109      		sbc r26,__zero_reg__
 2276 09e8 B109      		sbc r27,__zero_reg__
 2277 09ea 853F      		cpi r24,-11
 2278 09ec 9F4F      		sbci r25,-1
 2279 09ee AF4F      		sbci r26,-1
 2280 09f0 BF40      		sbci r27,15
 2281 09f2 00F0      		brlo .+2
 2282 09f4 00C0      		rjmp .L130
 2283               	.LVL210:
3546:ff.c          **** 		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 2284               		.loc 1 3546 0
 2285 09f6 263F      		cpi r18,-10
 2286 09f8 8FEF      		ldi r24,-1
 2287 09fa 3807      		cpc r19,r24
 2288 09fc 4105      		cpc r20,__zero_reg__
 2289 09fe 5105      		cpc r21,__zero_reg__
 2290 0a00 00F4      		brsh .L152
 2291               	.LVL211:
3547:ff.c          **** 		if (fmt == 0) return FR_NO_FILESYSTEM;
 2292               		.loc 1 3547 0
 2293 0a02 263F      		cpi r18,-10
 2294 0a04 9FE0      		ldi r25,15
 2295 0a06 3907      		cpc r19,r25
 2296 0a08 4105      		cpc r20,__zero_reg__
 2297 0a0a 5105      		cpc r21,__zero_reg__
 2298 0a0c 00F4      		brsh .L153
 2299 0a0e AA24      		clr r10
 2300 0a10 A394      		inc r10
 2301 0a12 B12C      		mov r11,__zero_reg__
 2302               	.LVL212:
 2303 0a14 00C0      		rjmp .L134
 2304               	.LVL213:
 2305               	.L152:
3545:ff.c          **** 		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 2306               		.loc 1 3545 0
 2307 0a16 73E0      		ldi r23,lo8(3)
 2308 0a18 A72E      		mov r10,r23
 2309 0a1a B12C      		mov r11,__zero_reg__
 2310               	.LVL214:
 2311 0a1c 00C0      		rjmp .L134
 2312               	.LVL215:
 2313               	.L153:
3546:ff.c          **** 		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 2314               		.loc 1 3546 0
 2315 0a1e 62E0      		ldi r22,lo8(2)
 2316 0a20 A62E      		mov r10,r22
 2317 0a22 B12C      		mov r11,__zero_reg__
 2318               	.LVL216:
 2319               	.L134:
3551:ff.c          **** 		fs->volbase = bsect;							/* Volume start sector */
 2320               		.loc 1 3551 0
 2321 0a24 6901      		movw r12,r18
 2322 0a26 7A01      		movw r14,r20
 2323               	.LVL217:
 2324 0a28 A2E0      		ldi r26,2
 2325 0a2a CA0E      		add r12,r26
 2326 0a2c D11C      		adc r13,__zero_reg__
 2327 0a2e E11C      		adc r14,__zero_reg__
 2328 0a30 F11C      		adc r15,__zero_reg__
 2329 0a32 F801      		movw r30,r16
 2330 0a34 C38A      		std Z+19,r12
 2331 0a36 D48A      		std Z+20,r13
 2332 0a38 E58A      		std Z+21,r14
 2333 0a3a F68A      		std Z+22,r15
3552:ff.c          **** 		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 2334               		.loc 1 3552 0
 2335 0a3c 2989      		ldd r18,Y+17
 2336 0a3e 3A89      		ldd r19,Y+18
 2337 0a40 4B89      		ldd r20,Y+19
 2338 0a42 5C89      		ldd r21,Y+20
 2339               	.LVL218:
 2340 0a44 238F      		std Z+27,r18
 2341 0a46 348F      		std Z+28,r19
 2342 0a48 458F      		std Z+29,r20
 2343 0a4a 568F      		std Z+30,r21
3553:ff.c          **** 		fs->database = bsect + sysect;					/* Data start sector */
 2344               		.loc 1 3553 0
 2345 0a4c 8D8D      		ldd r24,Y+29
 2346 0a4e 9E8D      		ldd r25,Y+30
 2347 0a50 AF8D      		ldd r26,Y+31
 2348 0a52 B8A1      		ldd r27,Y+32
 2349 0a54 280F      		add r18,r24
 2350 0a56 391F      		adc r19,r25
 2351 0a58 4A1F      		adc r20,r26
 2352 0a5a 5B1F      		adc r21,r27
 2353 0a5c 2D8F      		std Y+29,r18
 2354 0a5e 3E8F      		std Y+30,r19
 2355 0a60 4F8F      		std Y+31,r20
 2356 0a62 58A3      		std Y+32,r21
 2357 0a64 278F      		std Z+31,r18
 2358 0a66 30A3      		std Z+32,r19
 2359 0a68 41A3      		std Z+33,r20
 2360 0a6a 52A3      		std Z+34,r21
3554:ff.c          **** 		if (fmt == FS_FAT32) {
 2361               		.loc 1 3554 0
 2362 0a6c 4989      		ldd r20,Y+17
 2363 0a6e 5A89      		ldd r21,Y+18
 2364 0a70 6B89      		ldd r22,Y+19
 2365 0a72 7C89      		ldd r23,Y+20
 2366 0a74 8D89      		ldd r24,Y+21
 2367 0a76 9E89      		ldd r25,Y+22
 2368 0a78 AF89      		ldd r26,Y+23
 2369 0a7a B88D      		ldd r27,Y+24
 2370 0a7c 480F      		add r20,r24
 2371 0a7e 591F      		adc r21,r25
 2372 0a80 6A1F      		adc r22,r26
 2373 0a82 7B1F      		adc r23,r27
 2374 0a84 47A3      		std Z+39,r20
 2375 0a86 50A7      		std Z+40,r21
 2376 0a88 61A7      		std Z+41,r22
 2377 0a8a 72A7      		std Z+42,r23
3555:ff.c          **** 			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0
 2378               		.loc 1 3555 0
 2379 0a8c B3E0      		ldi r27,3
 2380 0a8e AB16      		cp r10,r27
 2381 0a90 B104      		cpc r11,__zero_reg__
 2382 0a92 01F4      		brne .L135
 2383               	.LVL219:
 2384               	.LBB191:
 2385               	.LBB192:
 615:ff.c          **** 	return rv;
 2386               		.loc 1 615 0
 2387 0a94 E75A      		subi r30,-89
 2388 0a96 FF4F      		sbci r31,-1
 2389               	.LBE192:
 2390               	.LBE191:
3556:ff.c          **** 			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 2391               		.loc 1 3556 0
 2392 0a98 8081      		ld r24,Z
 2393 0a9a 9181      		ldd r25,Z+1
 2394 0a9c 892B      		or r24,r25
 2395 0a9e 01F0      		breq .+2
 2396 0aa0 00C0      		rjmp .L130
3557:ff.c          **** 			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 2397               		.loc 1 3557 0
 2398 0aa2 8928      		or r8,r9
 2399 0aa4 01F0      		breq .+2
 2400 0aa6 00C0      		rjmp .L130
3558:ff.c          **** 			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 2401               		.loc 1 3558 0
 2402 0aa8 C801      		movw r24,r16
 2403 0aaa 855A      		subi r24,-91
 2404 0aac 9F4F      		sbci r25,-1
 2405 0aae 0E94 0000 		call ld_dword
 2406               	.LVL220:
 2407 0ab2 F801      		movw r30,r16
 2408 0ab4 63A3      		std Z+35,r22
 2409 0ab6 74A3      		std Z+36,r23
 2410 0ab8 85A3      		std Z+37,r24
 2411 0aba 96A3      		std Z+38,r25
3559:ff.c          **** 		} else {
 2412               		.loc 1 3559 0
 2413 0abc 42E0      		ldi r20,2
 2414               		1:
 2415 0abe CC0C      		lsl r12
 2416 0ac0 DD1C      		rol r13
 2417 0ac2 EE1C      		rol r14
 2418 0ac4 FF1C      		rol r15
 2419 0ac6 4A95      		dec r20
 2420 0ac8 01F4      		brne 1b
 2421               	.LVL221:
 2422 0aca 00C0      		rjmp .L136
 2423               	.LVL222:
 2424               	.L135:
3561:ff.c          **** 			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 2425               		.loc 1 3561 0
 2426 0acc 8928      		or r8,r9
 2427 0ace 01F4      		brne .+2
 2428 0ad0 00C0      		rjmp .L130
3562:ff.c          **** 			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 2429               		.loc 1 3562 0
 2430 0ad2 8D8D      		ldd r24,Y+29
 2431 0ad4 9E8D      		ldd r25,Y+30
 2432 0ad6 AF8D      		ldd r26,Y+31
 2433 0ad8 B8A1      		ldd r27,Y+32
 2434 0ada 298D      		ldd r18,Y+25
 2435 0adc 3A8D      		ldd r19,Y+26
 2436 0ade 4B8D      		ldd r20,Y+27
 2437 0ae0 5C8D      		ldd r21,Y+28
 2438 0ae2 820F      		add r24,r18
 2439 0ae4 931F      		adc r25,r19
 2440 0ae6 A41F      		adc r26,r20
 2441 0ae8 B51F      		adc r27,r21
 2442 0aea F801      		movw r30,r16
 2443 0aec 83A3      		std Z+35,r24
 2444 0aee 94A3      		std Z+36,r25
 2445 0af0 A5A3      		std Z+37,r26
 2446 0af2 B6A3      		std Z+38,r27
3564:ff.c          **** 		}
 2447               		.loc 1 3564 0
 2448 0af4 F2E0      		ldi r31,2
 2449 0af6 AF16      		cp r10,r31
 2450 0af8 B104      		cpc r11,__zero_reg__
 2451 0afa 01F4      		brne .L137
3564:ff.c          **** 		}
 2452               		.loc 1 3564 0 is_stmt 0 discriminator 1
 2453 0afc CC0C      		lsl r12
 2454 0afe DD1C      		rol r13
 2455 0b00 EE1C      		rol r14
 2456 0b02 FF1C      		rol r15
 2457               	.LVL223:
 2458 0b04 00C0      		rjmp .L136
 2459               	.LVL224:
 2460               	.L137:
3564:ff.c          **** 		}
 2461               		.loc 1 3564 0 discriminator 2
 2462 0b06 A3E0      		ldi r26,lo8(3)
 2463 0b08 B0E0      		ldi r27,0
 2464 0b0a A701      		movw r20,r14
 2465 0b0c 9601      		movw r18,r12
 2466 0b0e 0E94 0000 		call __muluhisi3
 2467 0b12 DC01      		movw r26,r24
 2468 0b14 CB01      		movw r24,r22
 2469 0b16 B695      		lsr r27
 2470 0b18 A795      		ror r26
 2471 0b1a 9795      		ror r25
 2472 0b1c 8795      		ror r24
 2473 0b1e 21E0      		ldi r18,1
 2474 0b20 C222      		and r12,r18
 2475 0b22 DD24      		clr r13
 2476 0b24 EE24      		clr r14
 2477 0b26 FF24      		clr r15
 2478               	.LVL225:
 2479 0b28 C80E      		add r12,r24
 2480 0b2a D91E      		adc r13,r25
 2481 0b2c EA1E      		adc r14,r26
 2482 0b2e FB1E      		adc r15,r27
 2483               	.LVL226:
 2484               	.L136:
3566:ff.c          **** 
 2485               		.loc 1 3566 0 is_stmt 1
 2486 0b30 3FEF      		ldi r19,-1
 2487 0b32 C30E      		add r12,r19
 2488 0b34 31E0      		ldi r19,1
 2489 0b36 D31E      		adc r13,r19
 2490 0b38 E11C      		adc r14,__zero_reg__
 2491 0b3a F11C      		adc r15,__zero_reg__
 2492               	.LVL227:
 2493 0b3c 89E0      		ldi r24,9
 2494               		1:
 2495 0b3e F694      		lsr r15
 2496 0b40 E794      		ror r14
 2497 0b42 D794      		ror r13
 2498 0b44 C794      		ror r12
 2499 0b46 8A95      		dec r24
 2500 0b48 01F4      		brne 1b
 2501               	.LVL228:
 2502 0b4a 4C14      		cp r4,r12
 2503 0b4c 5D04      		cpc r5,r13
 2504 0b4e 6E04      		cpc r6,r14
 2505 0b50 7F04      		cpc r7,r15
 2506 0b52 00F4      		brsh .+2
 2507 0b54 00C0      		rjmp .L130
3570:ff.c          **** 		fs->fsi_flag = 0x80;
 2508               		.loc 1 3570 0
 2509 0b56 8FEF      		ldi r24,lo8(-1)
 2510 0b58 9FEF      		ldi r25,lo8(-1)
 2511 0b5a DC01      		movw r26,r24
 2512 0b5c F801      		movw r30,r16
 2513 0b5e 8787      		std Z+15,r24
 2514 0b60 908B      		std Z+16,r25
 2515 0b62 A18B      		std Z+17,r26
 2516 0b64 B28B      		std Z+18,r27
 2517 0b66 8387      		std Z+11,r24
 2518 0b68 9487      		std Z+12,r25
 2519 0b6a A587      		std Z+13,r26
 2520 0b6c B687      		std Z+14,r27
3571:ff.c          **** #if (FF_FS_NOFSINFO & 3) != 3
 2521               		.loc 1 3571 0
 2522 0b6e 80E8      		ldi r24,lo8(-128)
 2523 0b70 8483      		std Z+4,r24
3573:ff.c          **** 			&& ld_word(fs->win + BPB_FSInfo32) == 1
 2524               		.loc 1 3573 0
 2525 0b72 F3E0      		ldi r31,3
 2526 0b74 AF16      		cp r10,r31
 2527 0b76 B104      		cpc r11,__zero_reg__
 2528 0b78 01F4      		brne .L139
 2529               	.LBB193:
 2530               	.LBB194:
 615:ff.c          **** 	return rv;
 2531               		.loc 1 615 0
 2532 0b7a F801      		movw r30,r16
 2533 0b7c E15A      		subi r30,-95
 2534 0b7e FF4F      		sbci r31,-1
 2535               	.LBE194:
 2536               	.LBE193:
3574:ff.c          **** 			&& move_window(fs, bsect + 1) == FR_OK)
 2537               		.loc 1 3574 0
 2538 0b80 8081      		ld r24,Z
 2539 0b82 9181      		ldd r25,Z+1
 2540 0b84 0197      		sbiw r24,1
 2541 0b86 01F4      		brne .L139
3575:ff.c          **** 		{
 2542               		.loc 1 3575 0
 2543 0b88 4989      		ldd r20,Y+17
 2544 0b8a 5A89      		ldd r21,Y+18
 2545 0b8c 6B89      		ldd r22,Y+19
 2546 0b8e 7C89      		ldd r23,Y+20
 2547 0b90 4F5F      		subi r20,-1
 2548 0b92 5F4F      		sbci r21,-1
 2549 0b94 6F4F      		sbci r22,-1
 2550 0b96 7F4F      		sbci r23,-1
 2551 0b98 C801      		movw r24,r16
 2552 0b9a 0E94 0000 		call move_window
 2553               	.LVL229:
 2554 0b9e 8111      		cpse r24,__zero_reg__
 2555 0ba0 00C0      		rjmp .L139
3577:ff.c          **** 			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 2556               		.loc 1 3577 0
 2557 0ba2 D801      		movw r26,r16
 2558 0ba4 1496      		adiw r26,4
 2559 0ba6 1C92      		st X,__zero_reg__
 2560               	.LBB195:
 2561               	.LBB196:
 615:ff.c          **** 	return rv;
 2562               		.loc 1 615 0
 2563 0ba8 F801      		movw r30,r16
 2564 0baa E35D      		subi r30,-45
 2565 0bac FD4F      		sbci r31,-3
 2566               	.LBE196:
 2567               	.LBE195:
3578:ff.c          **** 				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 2568               		.loc 1 3578 0
 2569 0bae 8081      		ld r24,Z
 2570 0bb0 9181      		ldd r25,Z+1
 2571 0bb2 8535      		cpi r24,85
 2572 0bb4 9A4A      		sbci r25,-86
 2573 0bb6 01F4      		brne .L139
3579:ff.c          **** 				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 2574               		.loc 1 3579 0
 2575 0bb8 C801      		movw r24,r16
 2576 0bba 8F96      		adiw r24,47
 2577 0bbc 0E94 0000 		call ld_dword
 2578               	.LVL230:
 2579 0bc0 6235      		cpi r22,82
 2580 0bc2 7245      		sbci r23,82
 2581 0bc4 8146      		sbci r24,97
 2582 0bc6 9144      		sbci r25,65
 2583 0bc8 01F4      		brne .L139
3580:ff.c          **** 			{
 2584               		.loc 1 3580 0
 2585 0bca C801      		movw r24,r16
 2586 0bcc 8D5E      		subi r24,-19
 2587 0bce 9D4F      		sbci r25,-3
 2588 0bd0 0E94 0000 		call ld_dword
 2589               	.LVL231:
 2590 0bd4 6237      		cpi r22,114
 2591 0bd6 7247      		sbci r23,114
 2592 0bd8 8144      		sbci r24,65
 2593 0bda 9146      		sbci r25,97
 2594 0bdc 01F4      		brne .L139
3586:ff.c          **** #endif
 2595               		.loc 1 3586 0
 2596 0bde C801      		movw r24,r16
 2597 0be0 855E      		subi r24,-27
 2598 0be2 9D4F      		sbci r25,-3
 2599 0be4 0E94 0000 		call ld_dword
 2600               	.LVL232:
 2601 0be8 D801      		movw r26,r16
 2602 0bea 1B96      		adiw r26,11
 2603 0bec 6D93      		st X+,r22
 2604 0bee 7D93      		st X+,r23
 2605 0bf0 8D93      		st X+,r24
 2606 0bf2 9C93      		st X,r25
 2607 0bf4 1E97      		sbiw r26,11+3
 2608               	.L139:
3594:ff.c          **** 	fs->id = ++Fsid;		/* Volume mount ID */
 2609               		.loc 1 3594 0
 2610 0bf6 F801      		movw r30,r16
 2611 0bf8 A082      		st Z,r10
3595:ff.c          **** #if FF_USE_LFN == 1
 2612               		.loc 1 3595 0
 2613 0bfa 8091 0000 		lds r24,Fsid
 2614 0bfe 9091 0000 		lds r25,Fsid+1
 2615 0c02 0196      		adiw r24,1
 2616 0c04 9093 0000 		sts Fsid+1,r25
 2617 0c08 8093 0000 		sts Fsid,r24
 2618 0c0c 9683      		std Z+6,r25
 2619 0c0e 8583      		std Z+5,r24
 2620 0c10 00C0      		rjmp .L145
 2621               	.LVL233:
 2622               	.L142:
3407:ff.c          **** 
 2623               		.loc 1 3407 0
 2624 0c12 8BE0      		ldi r24,lo8(11)
 2625 0c14 00C0      		rjmp .L171
 2626               	.LVL234:
 2627               	.L143:
3411:ff.c          **** #if FF_FS_REENTRANT
 2628               		.loc 1 3411 0
 2629 0c16 8CE0      		ldi r24,lo8(12)
 2630 0c18 00C0      		rjmp .L171
 2631               	.LVL235:
 2632               	.L145:
3424:ff.c          **** 		}
 2633               		.loc 1 3424 0
 2634 0c1a 80E0      		ldi r24,0
 2635 0c1c 00C0      		rjmp .L171
 2636               	.LVL236:
 2637               	.L146:
3435:ff.c          **** 	}
 2638               		.loc 1 3435 0
 2639 0c1e 83E0      		ldi r24,lo8(3)
 2640               	.LVL237:
 2641 0c20 00C0      		rjmp .L171
 2642               	.LVL238:
 2643               	.L151:
3447:ff.c          **** 	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 2644               		.loc 1 3447 0
 2645 0c22 81E0      		ldi r24,lo8(1)
 2646 0c24 00C0      		rjmp .L171
 2647               	.LVL239:
 2648               	.L148:
 2649               	.LBB197:
 2650               	.LBB182:
3377:ff.c          **** 	} while (part == 0 && fmt >= 2 && ++i < 4);
 2651               		.loc 1 3377 0
 2652 0c26 83E0      		ldi r24,lo8(3)
 2653 0c28 90E0      		ldi r25,0
 2654 0c2a 00C0      		rjmp .L141
 2655               	.LVL240:
 2656               	.L149:
 2657               	.LBB181:
 2658               	.LBB178:
3308:ff.c          **** 	sign = ld_word(fs->win + BS_55AA);
 2659               		.loc 1 3308 0
 2660 0c2c 84E0      		ldi r24,lo8(4)
 2661 0c2e 90E0      		ldi r25,0
 2662               	.LVL241:
 2663 0c30 00C0      		rjmp .L141
 2664               	.LVL242:
 2665               	.L171:
 2666               	/* epilogue start */
 2667               	.LBE178:
 2668               	.LBE181:
 2669               	.LBE182:
 2670               	.LBE197:
3609:ff.c          **** 
 2671               		.loc 1 3609 0
 2672 0c32 A096      		adiw r28,32
 2673 0c34 0FB6      		in __tmp_reg__,__SREG__
 2674 0c36 F894      		cli
 2675 0c38 DEBF      		out __SP_H__,r29
 2676 0c3a 0FBE      		out __SREG__,__tmp_reg__
 2677 0c3c CDBF      		out __SP_L__,r28
 2678 0c3e DF91      		pop r29
 2679 0c40 CF91      		pop r28
 2680 0c42 1F91      		pop r17
 2681 0c44 0F91      		pop r16
 2682 0c46 FF90      		pop r15
 2683               	.LVL243:
 2684 0c48 EF90      		pop r14
 2685 0c4a DF90      		pop r13
 2686 0c4c CF90      		pop r12
 2687 0c4e BF90      		pop r11
 2688 0c50 AF90      		pop r10
 2689 0c52 9F90      		pop r9
 2690 0c54 8F90      		pop r8
 2691 0c56 7F90      		pop r7
 2692 0c58 6F90      		pop r6
 2693 0c5a 5F90      		pop r5
 2694 0c5c 4F90      		pop r4
 2695 0c5e 0895      		ret
 2696               		.cfi_endproc
 2697               	.LFE34:
 2700               	put_fat:
 2701               	.LFB15:
1261:ff.c          **** 	UINT bc;
 2702               		.loc 1 1261 0
 2703               		.cfi_startproc
 2704               	.LVL244:
 2705 0c60 2F92      		push r2
 2706               	.LCFI83:
 2707               		.cfi_def_cfa_offset 3
 2708               		.cfi_offset 2, -2
 2709 0c62 3F92      		push r3
 2710               	.LCFI84:
 2711               		.cfi_def_cfa_offset 4
 2712               		.cfi_offset 3, -3
 2713 0c64 4F92      		push r4
 2714               	.LCFI85:
 2715               		.cfi_def_cfa_offset 5
 2716               		.cfi_offset 4, -4
 2717 0c66 5F92      		push r5
 2718               	.LCFI86:
 2719               		.cfi_def_cfa_offset 6
 2720               		.cfi_offset 5, -5
 2721 0c68 6F92      		push r6
 2722               	.LCFI87:
 2723               		.cfi_def_cfa_offset 7
 2724               		.cfi_offset 6, -6
 2725 0c6a 7F92      		push r7
 2726               	.LCFI88:
 2727               		.cfi_def_cfa_offset 8
 2728               		.cfi_offset 7, -7
 2729 0c6c 8F92      		push r8
 2730               	.LCFI89:
 2731               		.cfi_def_cfa_offset 9
 2732               		.cfi_offset 8, -8
 2733 0c6e 9F92      		push r9
 2734               	.LCFI90:
 2735               		.cfi_def_cfa_offset 10
 2736               		.cfi_offset 9, -9
 2737 0c70 AF92      		push r10
 2738               	.LCFI91:
 2739               		.cfi_def_cfa_offset 11
 2740               		.cfi_offset 10, -10
 2741 0c72 BF92      		push r11
 2742               	.LCFI92:
 2743               		.cfi_def_cfa_offset 12
 2744               		.cfi_offset 11, -11
 2745 0c74 CF92      		push r12
 2746               	.LCFI93:
 2747               		.cfi_def_cfa_offset 13
 2748               		.cfi_offset 12, -12
 2749 0c76 DF92      		push r13
 2750               	.LCFI94:
 2751               		.cfi_def_cfa_offset 14
 2752               		.cfi_offset 13, -13
 2753 0c78 EF92      		push r14
 2754               	.LCFI95:
 2755               		.cfi_def_cfa_offset 15
 2756               		.cfi_offset 14, -14
 2757 0c7a FF92      		push r15
 2758               	.LCFI96:
 2759               		.cfi_def_cfa_offset 16
 2760               		.cfi_offset 15, -15
 2761 0c7c 0F93      		push r16
 2762               	.LCFI97:
 2763               		.cfi_def_cfa_offset 17
 2764               		.cfi_offset 16, -16
 2765 0c7e 1F93      		push r17
 2766               	.LCFI98:
 2767               		.cfi_def_cfa_offset 18
 2768               		.cfi_offset 17, -17
 2769 0c80 CF93      		push r28
 2770               	.LCFI99:
 2771               		.cfi_def_cfa_offset 19
 2772               		.cfi_offset 28, -18
 2773 0c82 DF93      		push r29
 2774               	.LCFI100:
 2775               		.cfi_def_cfa_offset 20
 2776               		.cfi_offset 29, -19
 2777 0c84 00D0      		rcall .
 2778 0c86 00D0      		rcall .
 2779               	.LCFI101:
 2780               		.cfi_def_cfa_offset 24
 2781 0c88 CDB7      		in r28,__SP_L__
 2782 0c8a DEB7      		in r29,__SP_H__
 2783               	.LCFI102:
 2784               		.cfi_def_cfa_register 28
 2785               	/* prologue: function */
 2786               	/* frame size = 4 */
 2787               	/* stack size = 22 */
 2788               	.L__stack_usage = 22
 2789               	.LVL245:
1267:ff.c          **** 		switch (fs->fs_type) {
 2790               		.loc 1 1267 0
 2791 0c8c 4230      		cpi r20,2
 2792 0c8e 5105      		cpc r21,__zero_reg__
 2793 0c90 6105      		cpc r22,__zero_reg__
 2794 0c92 7105      		cpc r23,__zero_reg__
 2795 0c94 00F4      		brsh .+2
 2796 0c96 00C0      		rjmp .L184
1267:ff.c          **** 		switch (fs->fs_type) {
 2797               		.loc 1 1267 0 is_stmt 0 discriminator 1
 2798 0c98 FC01      		movw r30,r24
 2799 0c9a C388      		ldd r12,Z+19
 2800 0c9c D488      		ldd r13,Z+20
 2801 0c9e E588      		ldd r14,Z+21
 2802 0ca0 F688      		ldd r15,Z+22
 2803 0ca2 4C15      		cp r20,r12
 2804 0ca4 5D05      		cpc r21,r13
 2805 0ca6 6E05      		cpc r22,r14
 2806 0ca8 7F05      		cpc r23,r15
 2807 0caa 00F0      		brlo .+2
 2808 0cac 00C0      		rjmp .L184
 2809 0cae 2801      		movw r4,r16
 2810 0cb0 3901      		movw r6,r18
 2811 0cb2 6A01      		movw r12,r20
 2812 0cb4 7B01      		movw r14,r22
 2813 0cb6 9C83      		std Y+4,r25
 2814 0cb8 8B83      		std Y+3,r24
 2815               	.LVL246:
 2816               	.LBB204:
 2817               	.LBB205:
1268:ff.c          **** 		case FS_FAT12:
 2818               		.loc 1 1268 0 is_stmt 1
 2819 0cba 8081      		ld r24,Z
 2820               	.LVL247:
 2821 0cbc 8230      		cpi r24,lo8(2)
 2822 0cbe 01F4      		brne .+2
 2823 0cc0 00C0      		rjmp .L174
 2824 0cc2 8330      		cpi r24,lo8(3)
 2825 0cc4 01F4      		brne .+2
 2826 0cc6 00C0      		rjmp .L175
 2827 0cc8 8130      		cpi r24,lo8(1)
 2828 0cca 01F0      		breq .+2
 2829 0ccc 00C0      		rjmp .L184
 2830               	.LVL248:
1270:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 2831               		.loc 1 1270 0
 2832 0cce 5A01      		movw r10,r20
 2833 0cd0 B694      		lsr r11
 2834 0cd2 A794      		ror r10
 2835 0cd4 A40E      		add r10,r20
 2836 0cd6 B51E      		adc r11,r21
 2837               	.LVL249:
1271:ff.c          **** 			if (res != FR_OK) break;
 2838               		.loc 1 1271 0
 2839 0cd8 C501      		movw r24,r10
 2840 0cda 892F      		mov r24,r25
 2841 0cdc 9927      		clr r25
 2842 0cde 8695      		lsr r24
 2843 0ce0 478D      		ldd r20,Z+31
 2844 0ce2 50A1      		ldd r21,Z+32
 2845 0ce4 61A1      		ldd r22,Z+33
 2846 0ce6 72A1      		ldd r23,Z+34
 2847               	.LVL250:
 2848 0ce8 480F      		add r20,r24
 2849 0cea 591F      		adc r21,r25
 2850 0cec 611D      		adc r22,__zero_reg__
 2851 0cee 711D      		adc r23,__zero_reg__
 2852 0cf0 CF01      		movw r24,r30
 2853 0cf2 0E94 0000 		call move_window
 2854               	.LVL251:
 2855 0cf6 182F      		mov r17,r24
 2856               	.LVL252:
1272:ff.c          **** 			p = fs->win + bc++ % SS(fs);
 2857               		.loc 1 1272 0
 2858 0cf8 8111      		cpse r24,__zero_reg__
 2859 0cfa 00C0      		rjmp .L173
1273:ff.c          **** 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
 2860               		.loc 1 1273 0
 2861 0cfc 2B81      		ldd r18,Y+3
 2862 0cfe 3C81      		ldd r19,Y+4
 2863 0d00 215D      		subi r18,-47
 2864 0d02 3F4F      		sbci r19,-1
 2865 0d04 3A83      		std Y+2,r19
 2866 0d06 2983      		std Y+1,r18
 2867 0d08 1501      		movw r2,r10
 2868 0d0a 3FEF      		ldi r19,-1
 2869 0d0c 231A      		sub r2,r19
 2870 0d0e 330A      		sbc r3,r19
 2871               	.LVL253:
 2872 0d10 81E0      		ldi r24,1
 2873 0d12 B822      		and r11,r24
 2874 0d14 E981      		ldd r30,Y+1
 2875 0d16 FA81      		ldd r31,Y+2
 2876 0d18 EA0D      		add r30,r10
 2877 0d1a FB1D      		adc r31,r11
 2878               	.LVL254:
1274:ff.c          **** 			fs->wflag = 1;
 2879               		.loc 1 1274 0
 2880 0d1c 4601      		movw r8,r12
 2881 0d1e 5701      		movw r10,r14
 2882 0d20 91E0      		ldi r25,1
 2883 0d22 8922      		and r8,r25
 2884 0d24 9924      		clr r9
 2885 0d26 AA24      		clr r10
 2886 0d28 BB24      		clr r11
 2887 0d2a C0FE      		sbrs r12,0
 2888 0d2c 00C0      		rjmp .L177
 2889 0d2e 8081      		ld r24,Z
 2890 0d30 282F      		mov r18,r24
 2891 0d32 2F70      		andi r18,lo8(15)
 2892 0d34 30E1      		ldi r19,lo8(16)
 2893 0d36 439E      		mul r4,r19
 2894 0d38 C001      		movw r24,r0
 2895 0d3a 1124      		clr __zero_reg__
 2896 0d3c 822B      		or r24,r18
 2897 0d3e 00C0      		rjmp .L178
 2898               	.L177:
 2899 0d40 842D      		mov r24,r4
 2900               	.L178:
 2901 0d42 8083      		st Z,r24
1275:ff.c          **** 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 2902               		.loc 1 1275 0
 2903 0d44 81E0      		ldi r24,lo8(1)
 2904 0d46 EB81      		ldd r30,Y+3
 2905 0d48 FC81      		ldd r31,Y+4
 2906               	.LVL255:
 2907 0d4a 8383      		std Z+3,r24
1276:ff.c          **** 			if (res != FR_OK) break;
 2908               		.loc 1 1276 0
 2909 0d4c 478D      		ldd r20,Z+31
 2910 0d4e 50A1      		ldd r21,Z+32
 2911 0d50 61A1      		ldd r22,Z+33
 2912 0d52 72A1      		ldd r23,Z+34
 2913 0d54 C101      		movw r24,r2
 2914 0d56 892F      		mov r24,r25
 2915 0d58 9927      		clr r25
 2916 0d5a 8695      		lsr r24
 2917 0d5c 480F      		add r20,r24
 2918 0d5e 591F      		adc r21,r25
 2919 0d60 611D      		adc r22,__zero_reg__
 2920 0d62 711D      		adc r23,__zero_reg__
 2921 0d64 CF01      		movw r24,r30
 2922 0d66 0E94 0000 		call move_window
 2923               	.LVL256:
 2924 0d6a 182F      		mov r17,r24
 2925               	.LVL257:
1277:ff.c          **** 			p = fs->win + bc % SS(fs);
 2926               		.loc 1 1277 0
 2927 0d6c 8111      		cpse r24,__zero_reg__
 2928 0d6e 00C0      		rjmp .L173
1278:ff.c          **** 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd by
 2929               		.loc 1 1278 0
 2930 0d70 F1E0      		ldi r31,1
 2931 0d72 3F22      		and r3,r31
 2932               	.LVL258:
 2933 0d74 E981      		ldd r30,Y+1
 2934 0d76 FA81      		ldd r31,Y+2
 2935 0d78 E20D      		add r30,r2
 2936 0d7a F31D      		adc r31,r3
 2937               	.LVL259:
1279:ff.c          **** 			fs->wflag = 1;
 2938               		.loc 1 1279 0
 2939 0d7c 8928      		or r8,r9
 2940 0d7e 8A28      		or r8,r10
 2941 0d80 8B28      		or r8,r11
 2942 0d82 01F0      		breq .L179
 2943 0d84 54E0      		ldi r21,4
 2944               		1:
 2945 0d86 7694      		lsr r7
 2946 0d88 6794      		ror r6
 2947 0d8a 5794      		ror r5
 2948 0d8c 4794      		ror r4
 2949 0d8e 5A95      		dec r21
 2950 0d90 01F4      		brne 1b
 2951 0d92 00C0      		rjmp .L180
 2952               	.LVL260:
 2953               	.L179:
 2954 0d94 0081      		ld r16,Z
 2955 0d96 007F      		andi r16,lo8(-16)
 2956 0d98 852D      		mov r24,r5
 2957 0d9a 8F70      		andi r24,lo8(15)
 2958 0d9c 402E      		mov r4,r16
 2959               	.LVL261:
 2960 0d9e 482A      		or r4,r24
 2961               	.L180:
 2962 0da0 4082      		st Z,r4
 2963 0da2 00C0      		rjmp .L185
 2964               	.LVL262:
 2965               	.L174:
1284:ff.c          **** 			if (res != FR_OK) break;
 2966               		.loc 1 1284 0
 2967 0da4 7727      		clr r23
 2968 0da6 6F2D      		mov r22,r15
 2969 0da8 5E2D      		mov r21,r14
 2970 0daa 4D2D      		mov r20,r13
 2971 0dac EB81      		ldd r30,Y+3
 2972 0dae FC81      		ldd r31,Y+4
 2973               	.LVL263:
 2974 0db0 878D      		ldd r24,Z+31
 2975 0db2 90A1      		ldd r25,Z+32
 2976 0db4 A1A1      		ldd r26,Z+33
 2977 0db6 B2A1      		ldd r27,Z+34
 2978 0db8 480F      		add r20,r24
 2979 0dba 591F      		adc r21,r25
 2980 0dbc 6A1F      		adc r22,r26
 2981 0dbe 7B1F      		adc r23,r27
 2982 0dc0 CF01      		movw r24,r30
 2983 0dc2 0E94 0000 		call move_window
 2984               	.LVL264:
 2985 0dc6 182F      		mov r17,r24
 2986               	.LVL265:
1285:ff.c          **** 			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 2987               		.loc 1 1285 0
 2988 0dc8 8111      		cpse r24,__zero_reg__
 2989 0dca 00C0      		rjmp .L173
1286:ff.c          **** 			fs->wflag = 1;
 2990               		.loc 1 1286 0
 2991 0dcc EB81      		ldd r30,Y+3
 2992 0dce FC81      		ldd r31,Y+4
 2993 0dd0 BF96      		adiw r30,47
 2994 0dd2 CC0C      		lsl r12
 2995 0dd4 DD1C      		rol r13
 2996               	.LVL266:
 2997 0dd6 E894      		clt
 2998 0dd8 C0F8      		bld r12,0
 2999 0dda 21E0      		ldi r18,1
 3000 0ddc D222      		and r13,r18
 3001 0dde EC0D      		add r30,r12
 3002 0de0 FD1D      		adc r31,r13
 3003               	.LVL267:
 3004               	.LBB206:
 3005               	.LBB207:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 3006               		.loc 1 650 0
 3007 0de2 4082      		st Z,r4
 3008               	.LVL268:
 651:ff.c          **** }
 3009               		.loc 1 651 0
 3010 0de4 5182      		std Z+1,r5
 3011               	.LVL269:
 3012 0de6 00C0      		rjmp .L185
 3013               	.LVL270:
 3014               	.L175:
 3015               	.LBE207:
 3016               	.LBE206:
1294:ff.c          **** 			if (res != FR_OK) break;
 3017               		.loc 1 1294 0
 3018 0de8 EB81      		ldd r30,Y+3
 3019 0dea FC81      		ldd r31,Y+4
 3020               	.LVL271:
 3021 0dec 878D      		ldd r24,Z+31
 3022 0dee 90A1      		ldd r25,Z+32
 3023 0df0 A1A1      		ldd r26,Z+33
 3024 0df2 B2A1      		ldd r27,Z+34
 3025 0df4 27E0      		ldi r18,7
 3026               		1:
 3027 0df6 7695      		lsr r23
 3028 0df8 6795      		ror r22
 3029 0dfa 5795      		ror r21
 3030 0dfc 4795      		ror r20
 3031 0dfe 2A95      		dec r18
 3032 0e00 01F4      		brne 1b
 3033 0e02 480F      		add r20,r24
 3034 0e04 591F      		adc r21,r25
 3035 0e06 6A1F      		adc r22,r26
 3036 0e08 7B1F      		adc r23,r27
 3037 0e0a CF01      		movw r24,r30
 3038 0e0c 0E94 0000 		call move_window
 3039               	.LVL272:
 3040 0e10 182F      		mov r17,r24
 3041               	.LVL273:
1295:ff.c          **** 			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 3042               		.loc 1 1295 0
 3043 0e12 8111      		cpse r24,__zero_reg__
 3044 0e14 00C0      		rjmp .L173
1297:ff.c          **** 			}
 3045               		.loc 1 1297 0
 3046 0e16 4B81      		ldd r20,Y+3
 3047 0e18 5C81      		ldd r21,Y+4
 3048 0e1a 415D      		subi r20,-47
 3049 0e1c 5F4F      		sbci r21,-1
 3050 0e1e CC0C      		lsl r12
 3051 0e20 DD1C      		rol r13
 3052 0e22 CC0C      		lsl r12
 3053 0e24 DD1C      		rol r13
 3054               	.LVL274:
 3055 0e26 FCEF      		ldi r31,252
 3056 0e28 CF22      		and r12,r31
 3057 0e2a F1E0      		ldi r31,1
 3058 0e2c DF22      		and r13,r31
 3059 0e2e C40E      		add r12,r20
 3060 0e30 D51E      		adc r13,r21
 3061 0e32 C601      		movw r24,r12
 3062 0e34 0E94 0000 		call ld_dword
 3063               	.LVL275:
 3064 0e38 2FE0      		ldi r18,15
 3065 0e3a 7222      		and r7,r18
 3066               	.LVL276:
 3067 0e3c DC01      		movw r26,r24
 3068 0e3e CB01      		movw r24,r22
 3069 0e40 8827      		clr r24
 3070 0e42 9927      		clr r25
 3071 0e44 AA27      		clr r26
 3072 0e46 B07F      		andi r27,240
 3073 0e48 482A      		or r4,r24
 3074 0e4a 592A      		or r5,r25
 3075 0e4c 6A2A      		or r6,r26
 3076 0e4e 7B2A      		or r7,r27
 3077               	.LVL277:
 3078               	.LBB208:
 3079               	.LBB209:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 3080               		.loc 1 656 0
 3081 0e50 F601      		movw r30,r12
 3082 0e52 4082      		st Z,r4
 3083               	.LVL278:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 3084               		.loc 1 657 0
 3085 0e54 5182      		std Z+1,r5
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 3086               		.loc 1 658 0
 3087 0e56 6282      		std Z+2,r6
 659:ff.c          **** }
 3088               		.loc 1 659 0
 3089 0e58 7382      		std Z+3,r7
 3090               	.LVL279:
 3091               	.L185:
 3092               	.LBE209:
 3093               	.LBE208:
1300:ff.c          **** 			break;
 3094               		.loc 1 1300 0
 3095 0e5a 81E0      		ldi r24,lo8(1)
 3096 0e5c EB81      		ldd r30,Y+3
 3097 0e5e FC81      		ldd r31,Y+4
 3098 0e60 8383      		std Z+3,r24
 3099 0e62 00C0      		rjmp .L173
 3100               	.LVL280:
 3101               	.L184:
1264:ff.c          **** 
 3102               		.loc 1 1264 0
 3103 0e64 12E0      		ldi r17,lo8(2)
 3104               	.LVL281:
 3105               	.L173:
 3106               	.LBE205:
 3107               	.LBE204:
1305:ff.c          **** 
 3108               		.loc 1 1305 0
 3109 0e66 812F      		mov r24,r17
 3110               	/* epilogue start */
 3111 0e68 0F90      		pop __tmp_reg__
 3112 0e6a 0F90      		pop __tmp_reg__
 3113 0e6c 0F90      		pop __tmp_reg__
 3114 0e6e 0F90      		pop __tmp_reg__
 3115 0e70 DF91      		pop r29
 3116 0e72 CF91      		pop r28
 3117 0e74 1F91      		pop r17
 3118               	.LVL282:
 3119 0e76 0F91      		pop r16
 3120 0e78 FF90      		pop r15
 3121 0e7a EF90      		pop r14
 3122 0e7c DF90      		pop r13
 3123 0e7e CF90      		pop r12
 3124 0e80 BF90      		pop r11
 3125 0e82 AF90      		pop r10
 3126 0e84 9F90      		pop r9
 3127 0e86 8F90      		pop r8
 3128 0e88 7F90      		pop r7
 3129 0e8a 6F90      		pop r6
 3130 0e8c 5F90      		pop r5
 3131 0e8e 4F90      		pop r4
 3132 0e90 3F90      		pop r3
 3133 0e92 2F90      		pop r2
 3134 0e94 0895      		ret
 3135               		.cfi_endproc
 3136               	.LFE15:
 3139               	create_chain:
 3140               	.LFB17:
1545:ff.c          **** 	DWORD cs, ncl, scl;
 3141               		.loc 1 1545 0
 3142               		.cfi_startproc
 3143               	.LVL283:
 3144 0e96 4F92      		push r4
 3145               	.LCFI103:
 3146               		.cfi_def_cfa_offset 3
 3147               		.cfi_offset 4, -2
 3148 0e98 5F92      		push r5
 3149               	.LCFI104:
 3150               		.cfi_def_cfa_offset 4
 3151               		.cfi_offset 5, -3
 3152 0e9a 6F92      		push r6
 3153               	.LCFI105:
 3154               		.cfi_def_cfa_offset 5
 3155               		.cfi_offset 6, -4
 3156 0e9c 7F92      		push r7
 3157               	.LCFI106:
 3158               		.cfi_def_cfa_offset 6
 3159               		.cfi_offset 7, -5
 3160 0e9e 8F92      		push r8
 3161               	.LCFI107:
 3162               		.cfi_def_cfa_offset 7
 3163               		.cfi_offset 8, -6
 3164 0ea0 9F92      		push r9
 3165               	.LCFI108:
 3166               		.cfi_def_cfa_offset 8
 3167               		.cfi_offset 9, -7
 3168 0ea2 AF92      		push r10
 3169               	.LCFI109:
 3170               		.cfi_def_cfa_offset 9
 3171               		.cfi_offset 10, -8
 3172 0ea4 BF92      		push r11
 3173               	.LCFI110:
 3174               		.cfi_def_cfa_offset 10
 3175               		.cfi_offset 11, -9
 3176 0ea6 CF92      		push r12
 3177               	.LCFI111:
 3178               		.cfi_def_cfa_offset 11
 3179               		.cfi_offset 12, -10
 3180 0ea8 DF92      		push r13
 3181               	.LCFI112:
 3182               		.cfi_def_cfa_offset 12
 3183               		.cfi_offset 13, -11
 3184 0eaa EF92      		push r14
 3185               	.LCFI113:
 3186               		.cfi_def_cfa_offset 13
 3187               		.cfi_offset 14, -12
 3188 0eac FF92      		push r15
 3189               	.LCFI114:
 3190               		.cfi_def_cfa_offset 14
 3191               		.cfi_offset 15, -13
 3192 0eae 0F93      		push r16
 3193               	.LCFI115:
 3194               		.cfi_def_cfa_offset 15
 3195               		.cfi_offset 16, -14
 3196 0eb0 1F93      		push r17
 3197               	.LCFI116:
 3198               		.cfi_def_cfa_offset 16
 3199               		.cfi_offset 17, -15
 3200 0eb2 CF93      		push r28
 3201               	.LCFI117:
 3202               		.cfi_def_cfa_offset 17
 3203               		.cfi_offset 28, -16
 3204 0eb4 DF93      		push r29
 3205               	.LCFI118:
 3206               		.cfi_def_cfa_offset 18
 3207               		.cfi_offset 29, -17
 3208               	/* prologue: function */
 3209               	/* frame size = 0 */
 3210               	/* stack size = 16 */
 3211               	.L__stack_usage = 16
 3212 0eb6 8C01      		movw r16,r24
 3213 0eb8 2A01      		movw r4,r20
 3214 0eba 3B01      		movw r6,r22
1548:ff.c          **** 
 3215               		.loc 1 1548 0
 3216 0ebc FC01      		movw r30,r24
 3217 0ebe C081      		ld r28,Z
 3218 0ec0 D181      		ldd r29,Z+1
 3219               	.LVL284:
1551:ff.c          **** 		scl = fs->last_clst;				/* Suggested cluster to start to find */
 3220               		.loc 1 1551 0
 3221 0ec2 4115      		cp r20,__zero_reg__
 3222 0ec4 5105      		cpc r21,__zero_reg__
 3223 0ec6 6105      		cpc r22,__zero_reg__
 3224 0ec8 7105      		cpc r23,__zero_reg__
 3225 0eca 01F4      		brne .L187
1552:ff.c          **** 		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 3226               		.loc 1 1552 0
 3227 0ecc 8B84      		ldd r8,Y+11
 3228 0ece 9C84      		ldd r9,Y+12
 3229 0ed0 AD84      		ldd r10,Y+13
 3230 0ed2 BE84      		ldd r11,Y+14
 3231               	.LVL285:
1553:ff.c          **** 	}
 3232               		.loc 1 1553 0
 3233 0ed4 8114      		cp r8,__zero_reg__
 3234 0ed6 9104      		cpc r9,__zero_reg__
 3235 0ed8 A104      		cpc r10,__zero_reg__
 3236 0eda B104      		cpc r11,__zero_reg__
 3237 0edc 01F0      		breq .L207
1553:ff.c          **** 	}
 3238               		.loc 1 1553 0 is_stmt 0 discriminator 2
 3239 0ede 8B89      		ldd r24,Y+19
 3240 0ee0 9C89      		ldd r25,Y+20
 3241 0ee2 AD89      		ldd r26,Y+21
 3242 0ee4 BE89      		ldd r27,Y+22
 3243               	.LVL286:
 3244 0ee6 8816      		cp r8,r24
 3245 0ee8 9906      		cpc r9,r25
 3246 0eea AA06      		cpc r10,r26
 3247 0eec BB06      		cpc r11,r27
 3248 0eee 00F0      		brlo .L188
 3249 0ef0 00C0      		rjmp .L207
 3250               	.LVL287:
 3251               	.L187:
1556:ff.c          **** 		if (cs < 2) return 1;				/* Test for insanity */
 3252               		.loc 1 1556 0 is_stmt 1
 3253 0ef2 CE01      		movw r24,r28
 3254 0ef4 0E94 0000 		call get_fat.isra.10
 3255               	.LVL288:
1557:ff.c          **** 		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 3256               		.loc 1 1557 0
 3257 0ef8 6230      		cpi r22,2
 3258 0efa 7105      		cpc r23,__zero_reg__
 3259 0efc 8105      		cpc r24,__zero_reg__
 3260 0efe 9105      		cpc r25,__zero_reg__
 3261 0f00 00F4      		brsh .+2
 3262 0f02 00C0      		rjmp .L189
1558:ff.c          **** 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 3263               		.loc 1 1558 0
 3264 0f04 6F3F      		cpi r22,-1
 3265 0f06 FFEF      		ldi r31,-1
 3266 0f08 7F07      		cpc r23,r31
 3267 0f0a 8F07      		cpc r24,r31
 3268 0f0c 9F07      		cpc r25,r31
 3269 0f0e 01F4      		brne .L190
 3270               	.LVL289:
 3271               	.L195:
1628:ff.c          **** 	}
 3272               		.loc 1 1628 0
 3273 0f10 4FEF      		ldi r20,lo8(-1)
 3274 0f12 3FEF      		ldi r19,lo8(-1)
 3275 0f14 2FEF      		ldi r18,lo8(-1)
 3276 0f16 9FEF      		ldi r25,lo8(-1)
 3277 0f18 00C0      		rjmp .L191
 3278               	.LVL290:
 3279               	.L190:
1559:ff.c          **** 		scl = clst;							/* Cluster to start to find */
 3280               		.loc 1 1559 0
 3281 0f1a CB88      		ldd r12,Y+19
 3282 0f1c DC88      		ldd r13,Y+20
 3283 0f1e ED88      		ldd r14,Y+21
 3284 0f20 FE88      		ldd r15,Y+22
 3285 0f22 6C15      		cp r22,r12
 3286 0f24 7D05      		cpc r23,r13
 3287 0f26 8E05      		cpc r24,r14
 3288 0f28 9F05      		cpc r25,r15
 3289 0f2a 00F4      		brsh .+2
 3290 0f2c 00C0      		rjmp .L208
 3291 0f2e 5301      		movw r10,r6
 3292 0f30 4201      		movw r8,r4
 3293 0f32 00C0      		rjmp .L188
 3294               	.LVL291:
 3295               	.L207:
1553:ff.c          **** 	}
 3296               		.loc 1 1553 0
 3297 0f34 812C      		mov r8,__zero_reg__
 3298 0f36 912C      		mov r9,__zero_reg__
 3299 0f38 5401      		movw r10,r8
 3300 0f3a 8394      		inc r8
 3301               	.LVL292:
 3302               	.L188:
1562:ff.c          **** 
 3303               		.loc 1 1562 0
 3304 0f3c 8F85      		ldd r24,Y+15
 3305 0f3e 9889      		ldd r25,Y+16
 3306 0f40 A989      		ldd r26,Y+17
 3307 0f42 BA89      		ldd r27,Y+18
 3308 0f44 892B      		or r24,r25
 3309 0f46 8A2B      		or r24,r26
 3310 0f48 8B2B      		or r24,r27
 3311 0f4a 01F4      		brne .L192
 3312               	.L199:
 3313 0f4c 40E0      		ldi r20,0
 3314 0f4e 00C0      		rjmp .L230
 3315               	.L192:
 3316               	.LVL293:
1592:ff.c          **** 			ncl = scl + 1;						/* Test if next cluster is free */
 3317               		.loc 1 1592 0
 3318 0f50 8414      		cp r8,r4
 3319 0f52 9504      		cpc r9,r5
 3320 0f54 A604      		cpc r10,r6
 3321 0f56 B704      		cpc r11,r7
 3322 0f58 01F0      		breq .+2
 3323 0f5a 00C0      		rjmp .L206
1593:ff.c          **** 			if (ncl >= fs->n_fatent) ncl = 2;
 3324               		.loc 1 1593 0
 3325 0f5c 7501      		movw r14,r10
 3326 0f5e 6401      		movw r12,r8
 3327 0f60 2FEF      		ldi r18,-1
 3328 0f62 C21A      		sub r12,r18
 3329 0f64 D20A      		sbc r13,r18
 3330 0f66 E20A      		sbc r14,r18
 3331 0f68 F20A      		sbc r15,r18
 3332               	.LVL294:
1594:ff.c          **** 			cs = get_fat(obj, ncl);				/* Get next cluster status */
 3333               		.loc 1 1594 0
 3334 0f6a 8B89      		ldd r24,Y+19
 3335 0f6c 9C89      		ldd r25,Y+20
 3336 0f6e AD89      		ldd r26,Y+21
 3337 0f70 BE89      		ldd r27,Y+22
 3338 0f72 C816      		cp r12,r24
 3339 0f74 D906      		cpc r13,r25
 3340 0f76 EA06      		cpc r14,r26
 3341 0f78 FB06      		cpc r15,r27
 3342 0f7a 00F0      		brlo .L194
 3343 0f7c 92E0      		ldi r25,lo8(2)
 3344 0f7e C92E      		mov r12,r25
 3345 0f80 D12C      		mov r13,__zero_reg__
 3346 0f82 E12C      		mov r14,__zero_reg__
 3347 0f84 F12C      		mov r15,__zero_reg__
 3348               	.LVL295:
 3349               	.L194:
1595:ff.c          **** 			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 3350               		.loc 1 1595 0
 3351 0f86 B701      		movw r22,r14
 3352 0f88 A601      		movw r20,r12
 3353 0f8a F801      		movw r30,r16
 3354 0f8c 8081      		ld r24,Z
 3355 0f8e 9181      		ldd r25,Z+1
 3356 0f90 0E94 0000 		call get_fat.isra.10
 3357               	.LVL296:
1596:ff.c          **** 			if (cs != 0) {						/* Not free? */
 3358               		.loc 1 1596 0
 3359 0f94 6130      		cpi r22,1
 3360 0f96 7105      		cpc r23,__zero_reg__
 3361 0f98 8105      		cpc r24,__zero_reg__
 3362 0f9a 9105      		cpc r25,__zero_reg__
 3363 0f9c 01F4      		brne .+2
 3364 0f9e 00C0      		rjmp .L189
1596:ff.c          **** 			if (cs != 0) {						/* Not free? */
 3365               		.loc 1 1596 0 is_stmt 0 discriminator 2
 3366 0fa0 6F3F      		cpi r22,-1
 3367 0fa2 FFEF      		ldi r31,-1
 3368 0fa4 7F07      		cpc r23,r31
 3369 0fa6 8F07      		cpc r24,r31
 3370 0fa8 9F07      		cpc r25,r31
 3371 0faa 01F4      		brne .+2
 3372 0fac 00C0      		rjmp .L195
1597:ff.c          **** 				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 3373               		.loc 1 1597 0 is_stmt 1
 3374 0fae 672B      		or r22,r23
 3375 0fb0 682B      		or r22,r24
 3376 0fb2 692B      		or r22,r25
 3377 0fb4 01F0      		breq .L196
1598:ff.c          **** 				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 3378               		.loc 1 1598 0
 3379 0fb6 8B85      		ldd r24,Y+11
 3380 0fb8 9C85      		ldd r25,Y+12
 3381 0fba AD85      		ldd r26,Y+13
 3382 0fbc BE85      		ldd r27,Y+14
 3383               	.LVL297:
1599:ff.c          **** 				ncl = 0;
 3384               		.loc 1 1599 0
 3385 0fbe 8230      		cpi r24,2
 3386 0fc0 9105      		cpc r25,__zero_reg__
 3387 0fc2 A105      		cpc r26,__zero_reg__
 3388 0fc4 B105      		cpc r27,__zero_reg__
 3389 0fc6 00F0      		brlo .L206
1599:ff.c          **** 				ncl = 0;
 3390               		.loc 1 1599 0 is_stmt 0 discriminator 1
 3391 0fc8 4B89      		ldd r20,Y+19
 3392 0fca 5C89      		ldd r21,Y+20
 3393 0fcc 6D89      		ldd r22,Y+21
 3394 0fce 7E89      		ldd r23,Y+22
 3395 0fd0 8417      		cp r24,r20
 3396 0fd2 9507      		cpc r25,r21
 3397 0fd4 A607      		cpc r26,r22
 3398 0fd6 B707      		cpc r27,r23
 3399 0fd8 00F4      		brsh .L206
1599:ff.c          **** 				ncl = 0;
 3400               		.loc 1 1599 0
 3401 0fda 4C01      		movw r8,r24
 3402 0fdc 5D01      		movw r10,r26
 3403               	.LVL298:
 3404 0fde 00C0      		rjmp .L206
 3405               	.LVL299:
 3406               	.L196:
1603:ff.c          **** 			ncl = scl;	/* Start cluster */
 3407               		.loc 1 1603 0 is_stmt 1
 3408 0fe0 C114      		cp r12,__zero_reg__
 3409 0fe2 D104      		cpc r13,__zero_reg__
 3410 0fe4 E104      		cpc r14,__zero_reg__
 3411 0fe6 F104      		cpc r15,__zero_reg__
 3412 0fe8 01F4      		brne .L197
 3413               	.LVL300:
 3414               	.L206:
1594:ff.c          **** 			cs = get_fat(obj, ncl);				/* Get next cluster status */
 3415               		.loc 1 1594 0
 3416 0fea 7501      		movw r14,r10
 3417 0fec 6401      		movw r12,r8
 3418               	.L200:
 3419               	.LVL301:
1606:ff.c          **** 				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 3420               		.loc 1 1606 0
 3421 0fee 2FEF      		ldi r18,-1
 3422 0ff0 C21A      		sub r12,r18
 3423 0ff2 D20A      		sbc r13,r18
 3424 0ff4 E20A      		sbc r14,r18
 3425 0ff6 F20A      		sbc r15,r18
 3426               	.LVL302:
1607:ff.c          **** 					ncl = 2;
 3427               		.loc 1 1607 0
 3428 0ff8 8B89      		ldd r24,Y+19
 3429 0ffa 9C89      		ldd r25,Y+20
 3430 0ffc AD89      		ldd r26,Y+21
 3431 0ffe BE89      		ldd r27,Y+22
 3432 1000 C816      		cp r12,r24
 3433 1002 D906      		cpc r13,r25
 3434 1004 EA06      		cpc r14,r26
 3435 1006 FB06      		cpc r15,r27
 3436 1008 00F0      		brlo .L198
 3437               	.LVL303:
1609:ff.c          **** 				}
 3438               		.loc 1 1609 0
 3439 100a 82E0      		ldi r24,2
 3440 100c 8816      		cp r8,r24
 3441 100e 9104      		cpc r9,__zero_reg__
 3442 1010 A104      		cpc r10,__zero_reg__
 3443 1012 B104      		cpc r11,__zero_reg__
 3444 1014 00F4      		brsh .+2
 3445 1016 00C0      		rjmp .L199
1608:ff.c          **** 					if (ncl > scl) return 0;	/* No free cluster found? */
 3446               		.loc 1 1608 0
 3447 1018 82E0      		ldi r24,lo8(2)
 3448 101a C82E      		mov r12,r24
 3449 101c D12C      		mov r13,__zero_reg__
 3450 101e E12C      		mov r14,__zero_reg__
 3451 1020 F12C      		mov r15,__zero_reg__
 3452               	.LVL304:
 3453               	.L198:
1611:ff.c          **** 				if (cs == 0) break;				/* Found a free cluster? */
 3454               		.loc 1 1611 0
 3455 1022 B701      		movw r22,r14
 3456 1024 A601      		movw r20,r12
 3457 1026 F801      		movw r30,r16
 3458 1028 8081      		ld r24,Z
 3459 102a 9181      		ldd r25,Z+1
 3460 102c 0E94 0000 		call get_fat.isra.10
 3461               	.LVL305:
1612:ff.c          **** 				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 3462               		.loc 1 1612 0
 3463 1030 6115      		cp r22,__zero_reg__
 3464 1032 7105      		cpc r23,__zero_reg__
 3465 1034 8105      		cpc r24,__zero_reg__
 3466 1036 9105      		cpc r25,__zero_reg__
 3467 1038 01F0      		breq .L197
1613:ff.c          **** 				if (ncl == scl) return 0;		/* No free cluster found? */
 3468               		.loc 1 1613 0
 3469 103a 6130      		cpi r22,1
 3470 103c 7105      		cpc r23,__zero_reg__
 3471 103e 8105      		cpc r24,__zero_reg__
 3472 1040 9105      		cpc r25,__zero_reg__
 3473 1042 01F4      		brne .+2
 3474 1044 00C0      		rjmp .L189
1613:ff.c          **** 				if (ncl == scl) return 0;		/* No free cluster found? */
 3475               		.loc 1 1613 0 is_stmt 0 discriminator 2
 3476 1046 6F3F      		cpi r22,-1
 3477 1048 7F4F      		sbci r23,-1
 3478 104a 8F4F      		sbci r24,-1
 3479 104c 9F4F      		sbci r25,-1
 3480 104e 01F4      		brne .+2
 3481 1050 00C0      		rjmp .L195
1614:ff.c          **** 			}
 3482               		.loc 1 1614 0 is_stmt 1
 3483 1052 C814      		cp r12,r8
 3484 1054 D904      		cpc r13,r9
 3485 1056 EA04      		cpc r14,r10
 3486 1058 FB04      		cpc r15,r11
 3487 105a 01F4      		brne .L200
 3488 105c 00C0      		rjmp .L199
 3489               	.L197:
1617:ff.c          **** 		if (res == FR_OK && clst != 0) {
 3490               		.loc 1 1617 0
 3491 105e 0FEF      		ldi r16,lo8(-1)
 3492 1060 1FEF      		ldi r17,lo8(-1)
 3493 1062 9801      		movw r18,r16
 3494               	.LVL306:
 3495 1064 B701      		movw r22,r14
 3496 1066 A601      		movw r20,r12
 3497 1068 CE01      		movw r24,r28
 3498 106a 0E94 0000 		call put_fat
 3499               	.LVL307:
1618:ff.c          **** 			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 3500               		.loc 1 1618 0
 3501 106e 8111      		cpse r24,__zero_reg__
 3502 1070 00C0      		rjmp .L201
1618:ff.c          **** 			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 3503               		.loc 1 1618 0 is_stmt 0 discriminator 1
 3504 1072 4114      		cp r4,__zero_reg__
 3505 1074 5104      		cpc r5,__zero_reg__
 3506 1076 6104      		cpc r6,__zero_reg__
 3507 1078 7104      		cpc r7,__zero_reg__
 3508 107a 01F4      		brne .L202
 3509               	.L205:
 3510               	.LVL308:
1624:ff.c          **** 		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 3511               		.loc 1 1624 0 is_stmt 1
 3512 107c CB86      		std Y+11,r12
 3513 107e DC86      		std Y+12,r13
 3514 1080 ED86      		std Y+13,r14
 3515 1082 FE86      		std Y+14,r15
1625:ff.c          **** 		fs->fsi_flag |= 1;
 3516               		.loc 1 1625 0
 3517 1084 8F85      		ldd r24,Y+15
 3518 1086 9889      		ldd r25,Y+16
 3519 1088 A989      		ldd r26,Y+17
 3520 108a BA89      		ldd r27,Y+18
 3521 108c 4B89      		ldd r20,Y+19
 3522 108e 5C89      		ldd r21,Y+20
 3523 1090 6D89      		ldd r22,Y+21
 3524 1092 7E89      		ldd r23,Y+22
 3525 1094 4250      		subi r20,2
 3526 1096 5109      		sbc r21,__zero_reg__
 3527 1098 6109      		sbc r22,__zero_reg__
 3528 109a 7109      		sbc r23,__zero_reg__
 3529 109c 4817      		cp r20,r24
 3530 109e 5907      		cpc r21,r25
 3531 10a0 6A07      		cpc r22,r26
 3532 10a2 7B07      		cpc r23,r27
 3533 10a4 00F0      		brlo .L204
1625:ff.c          **** 		fs->fsi_flag |= 1;
 3534               		.loc 1 1625 0 is_stmt 0 discriminator 1
 3535 10a6 0197      		sbiw r24,1
 3536 10a8 A109      		sbc r26,__zero_reg__
 3537 10aa B109      		sbc r27,__zero_reg__
 3538 10ac 8F87      		std Y+15,r24
 3539 10ae 988B      		std Y+16,r25
 3540 10b0 A98B      		std Y+17,r26
 3541 10b2 BA8B      		std Y+18,r27
 3542 10b4 00C0      		rjmp .L204
 3543               	.LVL309:
 3544               	.L202:
1619:ff.c          **** 		}
 3545               		.loc 1 1619 0 is_stmt 1
 3546 10b6 9701      		movw r18,r14
 3547 10b8 8601      		movw r16,r12
 3548 10ba B301      		movw r22,r6
 3549 10bc A201      		movw r20,r4
 3550 10be CE01      		movw r24,r28
 3551               	.LVL310:
 3552 10c0 0E94 0000 		call put_fat
 3553               	.LVL311:
1623:ff.c          **** 		fs->last_clst = ncl;
 3554               		.loc 1 1623 0
 3555 10c4 8823      		tst r24
 3556 10c6 01F0      		breq .L205
 3557 10c8 00C0      		rjmp .L201
 3558               	.LVL312:
 3559               	.L204:
1626:ff.c          **** 	} else {
 3560               		.loc 1 1626 0
 3561 10ca 8C81      		ldd r24,Y+4
 3562 10cc 8160      		ori r24,lo8(1)
 3563 10ce 8C83      		std Y+4,r24
 3564 10d0 4C2D      		mov r20,r12
 3565 10d2 3D2D      		mov r19,r13
 3566 10d4 2E2D      		mov r18,r14
 3567 10d6 9F2D      		mov r25,r15
 3568 10d8 00C0      		rjmp .L191
 3569               	.LVL313:
 3570               	.L201:
1628:ff.c          **** 	}
 3571               		.loc 1 1628 0
 3572 10da 8130      		cpi r24,lo8(1)
 3573 10dc 01F4      		brne .+2
 3574 10de 00C0      		rjmp .L195
 3575               	.LVL314:
 3576               	.L189:
1628:ff.c          **** 	}
 3577               		.loc 1 1628 0 is_stmt 0 discriminator 2
 3578 10e0 41E0      		ldi r20,lo8(1)
 3579               	.L230:
 3580 10e2 30E0      		ldi r19,0
 3581 10e4 20E0      		ldi r18,0
 3582 10e6 90E0      		ldi r25,0
 3583 10e8 00C0      		rjmp .L191
 3584               	.LVL315:
 3585               	.L208:
 3586 10ea 462F      		mov r20,r22
 3587 10ec 372F      		mov r19,r23
 3588 10ee 282F      		mov r18,r24
 3589               	.LVL316:
 3590               	.L191:
1632:ff.c          **** 
 3591               		.loc 1 1632 0 is_stmt 1
 3592 10f0 642F      		mov r22,r20
 3593 10f2 732F      		mov r23,r19
 3594 10f4 822F      		mov r24,r18
 3595               	/* epilogue start */
 3596 10f6 DF91      		pop r29
 3597 10f8 CF91      		pop r28
 3598               	.LVL317:
 3599 10fa 1F91      		pop r17
 3600 10fc 0F91      		pop r16
 3601 10fe FF90      		pop r15
 3602 1100 EF90      		pop r14
 3603 1102 DF90      		pop r13
 3604 1104 CF90      		pop r12
 3605 1106 BF90      		pop r11
 3606 1108 AF90      		pop r10
 3607 110a 9F90      		pop r9
 3608 110c 8F90      		pop r8
 3609 110e 7F90      		pop r7
 3610 1110 6F90      		pop r6
 3611 1112 5F90      		pop r5
 3612 1114 4F90      		pop r4
 3613               	.LVL318:
 3614 1116 0895      		ret
 3615               		.cfi_endproc
 3616               	.LFE17:
 3619               	dir_next:
 3620               	.LFB20:
1765:ff.c          **** 	DWORD ofs, clst;
 3621               		.loc 1 1765 0
 3622               		.cfi_startproc
 3623               	.LVL319:
 3624 1118 4F92      		push r4
 3625               	.LCFI119:
 3626               		.cfi_def_cfa_offset 3
 3627               		.cfi_offset 4, -2
 3628 111a 5F92      		push r5
 3629               	.LCFI120:
 3630               		.cfi_def_cfa_offset 4
 3631               		.cfi_offset 5, -3
 3632 111c 6F92      		push r6
 3633               	.LCFI121:
 3634               		.cfi_def_cfa_offset 5
 3635               		.cfi_offset 6, -4
 3636 111e 7F92      		push r7
 3637               	.LCFI122:
 3638               		.cfi_def_cfa_offset 6
 3639               		.cfi_offset 7, -5
 3640 1120 AF92      		push r10
 3641               	.LCFI123:
 3642               		.cfi_def_cfa_offset 7
 3643               		.cfi_offset 10, -6
 3644 1122 BF92      		push r11
 3645               	.LCFI124:
 3646               		.cfi_def_cfa_offset 8
 3647               		.cfi_offset 11, -7
 3648 1124 CF92      		push r12
 3649               	.LCFI125:
 3650               		.cfi_def_cfa_offset 9
 3651               		.cfi_offset 12, -8
 3652 1126 DF92      		push r13
 3653               	.LCFI126:
 3654               		.cfi_def_cfa_offset 10
 3655               		.cfi_offset 13, -9
 3656 1128 EF92      		push r14
 3657               	.LCFI127:
 3658               		.cfi_def_cfa_offset 11
 3659               		.cfi_offset 14, -10
 3660 112a FF92      		push r15
 3661               	.LCFI128:
 3662               		.cfi_def_cfa_offset 12
 3663               		.cfi_offset 15, -11
 3664 112c 0F93      		push r16
 3665               	.LCFI129:
 3666               		.cfi_def_cfa_offset 13
 3667               		.cfi_offset 16, -12
 3668 112e 1F93      		push r17
 3669               	.LCFI130:
 3670               		.cfi_def_cfa_offset 14
 3671               		.cfi_offset 17, -13
 3672 1130 CF93      		push r28
 3673               	.LCFI131:
 3674               		.cfi_def_cfa_offset 15
 3675               		.cfi_offset 28, -14
 3676 1132 DF93      		push r29
 3677               	.LCFI132:
 3678               		.cfi_def_cfa_offset 16
 3679               		.cfi_offset 29, -15
 3680               	/* prologue: function */
 3681               	/* frame size = 0 */
 3682               	/* stack size = 14 */
 3683               	.L__stack_usage = 14
 3684 1134 EC01      		movw r28,r24
1767:ff.c          **** 
 3685               		.loc 1 1767 0
 3686 1136 0881      		ld r16,Y
 3687 1138 1981      		ldd r17,Y+1
 3688               	.LVL320:
1770:ff.c          **** 	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;
 3689               		.loc 1 1770 0
 3690 113a CE84      		ldd r12,Y+14
 3691 113c DF84      		ldd r13,Y+15
 3692 113e E888      		ldd r14,Y+16
 3693 1140 F988      		ldd r15,Y+17
 3694 1142 80E2      		ldi r24,32
 3695 1144 C80E      		add r12,r24
 3696 1146 D11C      		adc r13,__zero_reg__
 3697 1148 E11C      		adc r14,__zero_reg__
 3698 114a F11C      		adc r15,__zero_reg__
 3699               	.LVL321:
1771:ff.c          **** 	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 3700               		.loc 1 1771 0
 3701 114c C114      		cp r12,__zero_reg__
 3702 114e D104      		cpc r13,__zero_reg__
 3703 1150 E0E2      		ldi r30,32
 3704 1152 EE06      		cpc r14,r30
 3705 1154 F104      		cpc r15,__zero_reg__
 3706 1156 00F0      		brlo .L232
1771:ff.c          **** 	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 3707               		.loc 1 1771 0 is_stmt 0 discriminator 1
 3708 1158 1E8A      		std Y+22,__zero_reg__
 3709 115a 1F8A      		std Y+23,__zero_reg__
 3710 115c 188E      		std Y+24,__zero_reg__
 3711 115e 198E      		std Y+25,__zero_reg__
 3712               	.L232:
1772:ff.c          **** 
 3713               		.loc 1 1772 0 is_stmt 1
 3714 1160 8E89      		ldd r24,Y+22
 3715 1162 9F89      		ldd r25,Y+23
 3716 1164 A88D      		ldd r26,Y+24
 3717 1166 B98D      		ldd r27,Y+25
 3718 1168 0097      		sbiw r24,0
 3719 116a A105      		cpc r26,__zero_reg__
 3720 116c B105      		cpc r27,__zero_reg__
 3721 116e 01F4      		brne .+2
 3722 1170 00C0      		rjmp .L244
 3723 1172 5B01      		movw r10,r22
1774:ff.c          **** 		dp->sect++;				/* Next sector */
 3724               		.loc 1 1774 0
 3725 1174 B701      		movw r22,r14
 3726 1176 A601      		movw r20,r12
 3727 1178 5170      		andi r21,1
 3728 117a 6627      		clr r22
 3729 117c 7727      		clr r23
 3730 117e 452B      		or r20,r21
 3731 1180 462B      		or r20,r22
 3732 1182 472B      		or r20,r23
 3733 1184 01F0      		breq .+2
 3734 1186 00C0      		rjmp .L235
 3735               	.LVL322:
1775:ff.c          **** 
 3736               		.loc 1 1775 0
 3737 1188 0196      		adiw r24,1
 3738 118a A11D      		adc r26,__zero_reg__
 3739 118c B11D      		adc r27,__zero_reg__
 3740 118e 8E8B      		std Y+22,r24
 3741 1190 9F8B      		std Y+23,r25
 3742 1192 A88F      		std Y+24,r26
 3743 1194 B98F      		std Y+25,r27
1777:ff.c          **** 			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 3744               		.loc 1 1777 0
 3745 1196 4A89      		ldd r20,Y+18
 3746 1198 5B89      		ldd r21,Y+19
 3747 119a 6C89      		ldd r22,Y+20
 3748 119c 7D89      		ldd r23,Y+21
1778:ff.c          **** 				dp->sect = 0; return FR_NO_FILE;
 3749               		.loc 1 1778 0
 3750 119e F801      		movw r30,r16
1777:ff.c          **** 			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 3751               		.loc 1 1777 0
 3752 11a0 4115      		cp r20,__zero_reg__
 3753 11a2 5105      		cpc r21,__zero_reg__
 3754 11a4 6105      		cpc r22,__zero_reg__
 3755 11a6 7105      		cpc r23,__zero_reg__
 3756 11a8 01F4      		brne .L236
1778:ff.c          **** 				dp->sect = 0; return FR_NO_FILE;
 3757               		.loc 1 1778 0
 3758 11aa 8781      		ldd r24,Z+7
 3759 11ac 9085      		ldd r25,Z+8
 3760 11ae A0E0      		ldi r26,0
 3761 11b0 B0E0      		ldi r27,0
 3762 11b2 B701      		movw r22,r14
 3763 11b4 A601      		movw r20,r12
 3764 11b6 35E0      		ldi r19,5
 3765               		1:
 3766 11b8 7695      		lsr r23
 3767 11ba 6795      		ror r22
 3768 11bc 5795      		ror r21
 3769 11be 4795      		ror r20
 3770 11c0 3A95      		dec r19
 3771 11c2 01F4      		brne 1b
 3772 11c4 4817      		cp r20,r24
 3773 11c6 5907      		cpc r21,r25
 3774 11c8 6A07      		cpc r22,r26
 3775 11ca 7B07      		cpc r23,r27
 3776 11cc 00F4      		brsh .+2
 3777 11ce 00C0      		rjmp .L235
 3778               	.L241:
1779:ff.c          **** 			}
 3779               		.loc 1 1779 0
 3780 11d0 1E8A      		std Y+22,__zero_reg__
 3781 11d2 1F8A      		std Y+23,__zero_reg__
 3782 11d4 188E      		std Y+24,__zero_reg__
 3783 11d6 198E      		std Y+25,__zero_reg__
 3784 11d8 00C0      		rjmp .L244
 3785               	.L236:
1783:ff.c          **** 				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 3786               		.loc 1 1783 0
 3787 11da 8185      		ldd r24,Z+9
 3788 11dc 9285      		ldd r25,Z+10
 3789 11de 0197      		sbiw r24,1
 3790 11e0 A0E0      		ldi r26,0
 3791 11e2 B0E0      		ldi r27,0
 3792 11e4 2601      		movw r4,r12
 3793 11e6 3701      		movw r6,r14
 3794 11e8 29E0      		ldi r18,9
 3795               		1:
 3796 11ea 7694      		lsr r7
 3797 11ec 6794      		ror r6
 3798 11ee 5794      		ror r5
 3799 11f0 4794      		ror r4
 3800 11f2 2A95      		dec r18
 3801 11f4 01F4      		brne 1b
 3802 11f6 8421      		and r24,r4
 3803 11f8 9521      		and r25,r5
 3804 11fa A621      		and r26,r6
 3805 11fc B721      		and r27,r7
 3806 11fe 892B      		or r24,r25
 3807 1200 8A2B      		or r24,r26
 3808 1202 8B2B      		or r24,r27
 3809 1204 01F0      		breq .+2
 3810 1206 00C0      		rjmp .L235
1784:ff.c          **** 				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 3811               		.loc 1 1784 0
 3812 1208 C801      		movw r24,r16
 3813 120a 0E94 0000 		call get_fat.isra.10
 3814               	.LVL323:
 3815 120e 2B01      		movw r4,r22
 3816 1210 3C01      		movw r6,r24
 3817               	.LVL324:
1785:ff.c          **** 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 3818               		.loc 1 1785 0
 3819 1212 6230      		cpi r22,2
 3820 1214 7105      		cpc r23,__zero_reg__
 3821 1216 8105      		cpc r24,__zero_reg__
 3822 1218 9105      		cpc r25,__zero_reg__
 3823 121a 00F4      		brsh .L238
 3824               	.L242:
 3825 121c 82E0      		ldi r24,lo8(2)
 3826 121e 00C0      		rjmp .L233
 3827               	.L238:
1786:ff.c          **** 				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 3828               		.loc 1 1786 0
 3829 1220 8FEF      		ldi r24,-1
 3830 1222 4816      		cp r4,r24
 3831 1224 5806      		cpc r5,r24
 3832 1226 6806      		cpc r6,r24
 3833 1228 7806      		cpc r7,r24
 3834 122a 01F4      		brne .L239
 3835               	.L243:
 3836 122c 81E0      		ldi r24,lo8(1)
 3837 122e 00C0      		rjmp .L233
 3838               	.L239:
1787:ff.c          **** #if !FF_FS_READONLY
 3839               		.loc 1 1787 0
 3840 1230 F801      		movw r30,r16
 3841 1232 8389      		ldd r24,Z+19
 3842 1234 9489      		ldd r25,Z+20
 3843 1236 A589      		ldd r26,Z+21
 3844 1238 B689      		ldd r27,Z+22
 3845 123a 4816      		cp r4,r24
 3846 123c 5906      		cpc r5,r25
 3847 123e 6A06      		cpc r6,r26
 3848 1240 7B06      		cpc r7,r27
 3849 1242 00F0      		brlo .L240
1789:ff.c          **** 						dp->sect = 0; return FR_NO_FILE;
 3850               		.loc 1 1789 0
 3851 1244 AB28      		or r10,r11
 3852 1246 01F0      		breq .L241
1792:ff.c          **** 					if (clst == 0) return FR_DENIED;			/* No free cluster */
 3853               		.loc 1 1792 0
 3854 1248 4A89      		ldd r20,Y+18
 3855 124a 5B89      		ldd r21,Y+19
 3856 124c 6C89      		ldd r22,Y+20
 3857 124e 7D89      		ldd r23,Y+21
 3858 1250 CE01      		movw r24,r28
 3859 1252 0E94 0000 		call create_chain
 3860               	.LVL325:
 3861 1256 2B01      		movw r4,r22
 3862 1258 3C01      		movw r6,r24
 3863               	.LVL326:
1793:ff.c          **** 					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 3864               		.loc 1 1793 0
 3865 125a 6115      		cp r22,__zero_reg__
 3866 125c 7105      		cpc r23,__zero_reg__
 3867 125e 8105      		cpc r24,__zero_reg__
 3868 1260 9105      		cpc r25,__zero_reg__
 3869 1262 01F0      		breq .L245
1794:ff.c          **** 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 3870               		.loc 1 1794 0
 3871 1264 6130      		cpi r22,1
 3872 1266 7105      		cpc r23,__zero_reg__
 3873 1268 8105      		cpc r24,__zero_reg__
 3874 126a 9105      		cpc r25,__zero_reg__
 3875 126c 01F0      		breq .L242
1795:ff.c          **** 					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 3876               		.loc 1 1795 0
 3877 126e 8FEF      		ldi r24,-1
 3878 1270 4816      		cp r4,r24
 3879 1272 5806      		cpc r5,r24
 3880 1274 6806      		cpc r6,r24
 3881 1276 7806      		cpc r7,r24
 3882 1278 01F0      		breq .L243
1796:ff.c          **** 					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
 3883               		.loc 1 1796 0
 3884 127a B301      		movw r22,r6
 3885 127c A201      		movw r20,r4
 3886 127e C801      		movw r24,r16
 3887 1280 0E94 0000 		call dir_clear
 3888               	.LVL327:
 3889 1284 8111      		cpse r24,__zero_reg__
 3890 1286 00C0      		rjmp .L243
 3891               	.L240:
1803:ff.c          **** 				dp->sect = clst2sect(fs, clst);
 3892               		.loc 1 1803 0
 3893 1288 4A8A      		std Y+18,r4
 3894 128a 5B8A      		std Y+19,r5
 3895 128c 6C8A      		std Y+20,r6
 3896 128e 7D8A      		std Y+21,r7
1804:ff.c          **** 			}
 3897               		.loc 1 1804 0
 3898 1290 B301      		movw r22,r6
 3899 1292 A201      		movw r20,r4
 3900 1294 C801      		movw r24,r16
 3901 1296 0E94 0000 		call clst2sect
 3902               	.LVL328:
 3903 129a 6E8B      		std Y+22,r22
 3904 129c 7F8B      		std Y+23,r23
 3905 129e 888F      		std Y+24,r24
 3906 12a0 998F      		std Y+25,r25
 3907               	.LVL329:
 3908               	.L235:
1808:ff.c          **** 	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 3909               		.loc 1 1808 0
 3910 12a2 CE86      		std Y+14,r12
 3911 12a4 DF86      		std Y+15,r13
 3912 12a6 E88A      		std Y+16,r14
 3913 12a8 F98A      		std Y+17,r15
1809:ff.c          **** 
 3914               		.loc 1 1809 0
 3915 12aa 015D      		subi r16,-47
 3916 12ac 1F4F      		sbci r17,-1
 3917               	.LVL330:
 3918 12ae E1E0      		ldi r30,1
 3919 12b0 DE22      		and r13,r30
 3920               	.LVL331:
 3921 12b2 C00E      		add r12,r16
 3922 12b4 D11E      		adc r13,r17
 3923 12b6 DB8E      		std Y+27,r13
 3924 12b8 CA8E      		std Y+26,r12
1811:ff.c          **** }
 3925               		.loc 1 1811 0
 3926 12ba 80E0      		ldi r24,0
 3927 12bc 00C0      		rjmp .L233
 3928               	.LVL332:
 3929               	.L244:
1772:ff.c          **** 
 3930               		.loc 1 1772 0
 3931 12be 84E0      		ldi r24,lo8(4)
 3932 12c0 00C0      		rjmp .L233
 3933               	.LVL333:
 3934               	.L245:
1793:ff.c          **** 					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 3935               		.loc 1 1793 0
 3936 12c2 87E0      		ldi r24,lo8(7)
 3937               	.LVL334:
 3938               	.L233:
 3939               	/* epilogue start */
1812:ff.c          **** 
 3940               		.loc 1 1812 0
 3941 12c4 DF91      		pop r29
 3942 12c6 CF91      		pop r28
 3943               	.LVL335:
 3944 12c8 1F91      		pop r17
 3945 12ca 0F91      		pop r16
 3946 12cc FF90      		pop r15
 3947 12ce EF90      		pop r14
 3948 12d0 DF90      		pop r13
 3949 12d2 CF90      		pop r12
 3950 12d4 BF90      		pop r11
 3951 12d6 AF90      		pop r10
 3952 12d8 7F90      		pop r7
 3953 12da 6F90      		pop r6
 3954 12dc 5F90      		pop r5
 3955 12de 4F90      		pop r4
 3956 12e0 0895      		ret
 3957               		.cfi_endproc
 3958               	.LFE20:
 3960               		.section	.rodata.str1.1
 3961               	.LC1:
 3962 0009 222A 2B2C 		.string	"\"*+,:;<=>?[]|\177"
 3962      3A3B 3C3D 
 3962      3E3F 5B5D 
 3962      7C7F 00
 3963               		.text
 3965               	follow_path:
 3966               	.LFB30:
3069:ff.c          **** 	FRESULT res;
 3967               		.loc 1 3069 0
 3968               		.cfi_startproc
 3969               	.LVL336:
 3970 12e2 2F92      		push r2
 3971               	.LCFI133:
 3972               		.cfi_def_cfa_offset 3
 3973               		.cfi_offset 2, -2
 3974 12e4 3F92      		push r3
 3975               	.LCFI134:
 3976               		.cfi_def_cfa_offset 4
 3977               		.cfi_offset 3, -3
 3978 12e6 4F92      		push r4
 3979               	.LCFI135:
 3980               		.cfi_def_cfa_offset 5
 3981               		.cfi_offset 4, -4
 3982 12e8 5F92      		push r5
 3983               	.LCFI136:
 3984               		.cfi_def_cfa_offset 6
 3985               		.cfi_offset 5, -5
 3986 12ea 6F92      		push r6
 3987               	.LCFI137:
 3988               		.cfi_def_cfa_offset 7
 3989               		.cfi_offset 6, -6
 3990 12ec 7F92      		push r7
 3991               	.LCFI138:
 3992               		.cfi_def_cfa_offset 8
 3993               		.cfi_offset 7, -7
 3994 12ee 8F92      		push r8
 3995               	.LCFI139:
 3996               		.cfi_def_cfa_offset 9
 3997               		.cfi_offset 8, -8
 3998 12f0 9F92      		push r9
 3999               	.LCFI140:
 4000               		.cfi_def_cfa_offset 10
 4001               		.cfi_offset 9, -9
 4002 12f2 AF92      		push r10
 4003               	.LCFI141:
 4004               		.cfi_def_cfa_offset 11
 4005               		.cfi_offset 10, -10
 4006 12f4 BF92      		push r11
 4007               	.LCFI142:
 4008               		.cfi_def_cfa_offset 12
 4009               		.cfi_offset 11, -11
 4010 12f6 CF92      		push r12
 4011               	.LCFI143:
 4012               		.cfi_def_cfa_offset 13
 4013               		.cfi_offset 12, -12
 4014 12f8 DF92      		push r13
 4015               	.LCFI144:
 4016               		.cfi_def_cfa_offset 14
 4017               		.cfi_offset 13, -13
 4018 12fa EF92      		push r14
 4019               	.LCFI145:
 4020               		.cfi_def_cfa_offset 15
 4021               		.cfi_offset 14, -14
 4022 12fc FF92      		push r15
 4023               	.LCFI146:
 4024               		.cfi_def_cfa_offset 16
 4025               		.cfi_offset 15, -15
 4026 12fe 0F93      		push r16
 4027               	.LCFI147:
 4028               		.cfi_def_cfa_offset 17
 4029               		.cfi_offset 16, -16
 4030 1300 1F93      		push r17
 4031               	.LCFI148:
 4032               		.cfi_def_cfa_offset 18
 4033               		.cfi_offset 17, -17
 4034 1302 CF93      		push r28
 4035               	.LCFI149:
 4036               		.cfi_def_cfa_offset 19
 4037               		.cfi_offset 28, -18
 4038 1304 DF93      		push r29
 4039               	.LCFI150:
 4040               		.cfi_def_cfa_offset 20
 4041               		.cfi_offset 29, -19
 4042               	/* prologue: function */
 4043               	/* frame size = 0 */
 4044               	/* stack size = 18 */
 4045               	.L__stack_usage = 18
3072:ff.c          **** 
 4046               		.loc 1 3072 0
 4047 1306 FC01      		movw r30,r24
 4048 1308 C080      		ld r12,Z
 4049 130a D180      		ldd r13,Z+1
 4050               	.LVL337:
 4051 130c 9B01      		movw r18,r22
 4052               	.LVL338:
 4053               	.L256:
 4054 130e 8901      		movw r16,r18
 4055               	.LVL339:
3081:ff.c          **** 		dp->obj.sclust = 0;					/* Start from root directory */
 4056               		.loc 1 3081 0 discriminator 1
 4057 1310 F901      		movw r30,r18
 4058 1312 4081      		ld r20,Z
 4059 1314 2F5F      		subi r18,-1
 4060 1316 3F4F      		sbci r19,-1
 4061 1318 4F32      		cpi r20,lo8(47)
 4062 131a 01F0      		breq .L256
3081:ff.c          **** 		dp->obj.sclust = 0;					/* Start from root directory */
 4063               		.loc 1 3081 0 is_stmt 0 discriminator 3
 4064 131c 4C35      		cpi r20,lo8(92)
 4065 131e 01F0      		breq .L256
3082:ff.c          **** 	}
 4066               		.loc 1 3082 0 is_stmt 1
 4067 1320 FC01      		movw r30,r24
 4068 1322 1682      		std Z+6,__zero_reg__
 4069 1324 1782      		std Z+7,__zero_reg__
 4070 1326 1086      		std Z+8,__zero_reg__
 4071 1328 1186      		std Z+9,__zero_reg__
3101:ff.c          **** 		dp->fn[NSFLAG] = NS_NONAME;
 4072               		.loc 1 3101 0
 4073 132a F801      		movw r30,r16
 4074 132c 2081      		ld r18,Z
 4075 132e 2032      		cpi r18,lo8(32)
 4076 1330 00F0      		brlo .L258
 4077 1332 EC01      		movw r28,r24
 4078               	.LBB220:
 4079               	.LBB221:
3000:ff.c          **** 	mem_set(sfn, ' ', 11);
 4080               		.loc 1 3000 0
 4081 1334 7C01      		movw r14,r24
 4082 1336 FCE1      		ldi r31,28
 4083 1338 EF0E      		add r14,r31
 4084 133a F11C      		adc r15,__zero_reg__
 4085 133c 3C01      		movw r6,r24
 4086 133e 87E2      		ldi r24,39
 4087 1340 680E      		add r6,r24
 4088 1342 711C      		adc r7,__zero_reg__
 4089               	.LVL340:
 4090               	.LBB222:
 4091               	.LBB223:
 703:ff.c          **** 	} while (--cnt);
 4092               		.loc 1 703 0
 4093 1344 80E2      		ldi r24,lo8(32)
 4094 1346 382E      		mov r3,r24
 4095               	.LBE223:
 4096               	.LBE222:
3051:ff.c          **** 	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 4097               		.loc 1 3051 0
 4098 1348 95E0      		ldi r25,lo8(5)
 4099 134a 292E      		mov r2,r25
 4100               	.LBE221:
 4101               	.LBE220:
3137:ff.c          **** 			}
 4102               		.loc 1 3137 0
 4103 134c 4601      		movw r8,r12
 4104 134e EFE2      		ldi r30,47
 4105 1350 8E0E      		add r8,r30
 4106 1352 911C      		adc r9,__zero_reg__
 4107 1354 00C0      		rjmp .L259
 4108               	.LVL341:
 4109               	.L258:
3102:ff.c          **** 		res = dir_sdi(dp, 0);
 4110               		.loc 1 3102 0
 4111 1356 20E8      		ldi r18,lo8(-128)
 4112 1358 FC01      		movw r30,r24
 4113 135a 27A3      		std Z+39,r18
 4114               	/* epilogue start */
3143:ff.c          **** 
 4115               		.loc 1 3143 0
 4116 135c DF91      		pop r29
 4117 135e CF91      		pop r28
 4118 1360 1F91      		pop r17
 4119 1362 0F91      		pop r16
 4120               	.LVL342:
 4121 1364 FF90      		pop r15
 4122 1366 EF90      		pop r14
 4123 1368 DF90      		pop r13
 4124 136a CF90      		pop r12
 4125               	.LVL343:
 4126 136c BF90      		pop r11
 4127 136e AF90      		pop r10
 4128 1370 9F90      		pop r9
 4129 1372 8F90      		pop r8
 4130 1374 7F90      		pop r7
 4131 1376 6F90      		pop r6
 4132 1378 5F90      		pop r5
 4133 137a 4F90      		pop r4
 4134 137c 3F90      		pop r3
 4135 137e 2F90      		pop r2
3103:ff.c          **** 
 4136               		.loc 1 3103 0
 4137 1380 0C94 0000 		jmp dir_sdi.constprop.15
 4138               	.LVL344:
 4139               	.L260:
 4140               	.LBB232:
 4141               	.LBB228:
 4142               	.LBB225:
 4143               	.LBB224:
 703:ff.c          **** 	} while (--cnt);
 4144               		.loc 1 703 0
 4145 1384 3192      		st Z+,r3
 4146               	.LVL345:
 704:ff.c          **** }
 4147               		.loc 1 704 0
 4148 1386 E615      		cp r30,r6
 4149 1388 F705      		cpc r31,r7
 4150 138a 01F4      		brne .L260
 4151 138c F801      		movw r30,r16
 4152               	.LVL346:
 4153 138e 80E0      		ldi r24,0
 4154 1390 90E0      		ldi r25,0
 4155 1392 20E0      		ldi r18,0
 4156 1394 30E0      		ldi r19,0
 4157 1396 68E0      		ldi r22,lo8(8)
 4158 1398 70E0      		ldi r23,0
 4159               	.L261:
 4160               	.LVL347:
 4161               	.LBE224:
 4162               	.LBE225:
3017:ff.c          **** 		if (c <= ' ') break; 			/* Break if end of the path name */
 4163               		.loc 1 3017 0
 4164 139a 2F5F      		subi r18,-1
 4165 139c 3F4F      		sbci r19,-1
 4166               	.LVL348:
 4167 139e 5191      		ld r21,Z+
 4168               	.LVL349:
3018:ff.c          **** 		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 4169               		.loc 1 3018 0
 4170 13a0 5132      		cpi r21,lo8(33)
 4171 13a2 00F4      		brsh .L318
 4172               	.L262:
3048:ff.c          **** 	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 4173               		.loc 1 3048 0
 4174 13a4 020F      		add r16,r18
 4175 13a6 131F      		adc r17,r19
 4176               	.LVL350:
3049:ff.c          **** 
 4177               		.loc 1 3049 0
 4178 13a8 892B      		or r24,r25
 4179 13aa 01F4      		brne .+2
 4180 13ac 00C0      		rjmp .L290
3051:ff.c          **** 	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 4181               		.loc 1 3051 0
 4182 13ae 8C8D      		ldd r24,Y+28
 4183               	.LVL351:
 4184 13b0 853E      		cpi r24,lo8(-27)
 4185 13b2 01F4      		brne .L274
 4186 13b4 2C8E      		std Y+28,r2
 4187               	.L274:
3052:ff.c          **** 
 4188               		.loc 1 3052 0
 4189 13b6 5132      		cpi r21,lo8(33)
 4190 13b8 00F4      		brsh .+2
 4191 13ba 00C0      		rjmp .L286
 4192 13bc 80E0      		ldi r24,0
 4193               	.L275:
 4194 13be 8FA3      		std Y+39,r24
 4195               	.LVL352:
 4196               	.LBE228:
 4197               	.LBE232:
 4198               	.LBB233:
 4199               	.LBB234:
2447:ff.c          **** 	BYTE c;
 4200               		.loc 1 2447 0
 4201 13c0 A880      		ld r10,Y
 4202 13c2 B980      		ldd r11,Y+1
 4203               	.LVL353:
2453:ff.c          **** 	if (res != FR_OK) return res;
 4204               		.loc 1 2453 0
 4205 13c4 CE01      		movw r24,r28
 4206 13c6 0E94 0000 		call dir_sdi.constprop.15
 4207               	.LVL354:
 4208               	.L317:
2454:ff.c          **** #if FF_FS_EXFAT
 4209               		.loc 1 2454 0
 4210 13ca 8823      		tst r24
 4211 13cc 01F4      		brne .+2
 4212 13ce 00C0      		rjmp .L319
 4213               	.LVL355:
 4214               	.L276:
 4215               	.LBE234:
 4216               	.LBE233:
3110:ff.c          **** 			if (res != FR_OK) {				/* Failed to find the object */
 4217               		.loc 1 3110 0
 4218 13d0 9FA1      		ldd r25,Y+39
 4219               	.LVL356:
3111:ff.c          **** 				if (res == FR_NO_FILE) {	/* Object is not found */
 4220               		.loc 1 3111 0
 4221 13d2 8111      		cpse r24,__zero_reg__
 4222 13d4 00C0      		rjmp .L320
3123:ff.c          **** 			/* Get into the sub-directory */
 4223               		.loc 1 3123 0
 4224 13d6 92FD      		sbrc r25,2
 4225 13d8 00C0      		rjmp .L299
3125:ff.c          **** 				res = FR_NO_PATH; break;
 4226               		.loc 1 3125 0
 4227 13da 8C81      		ldd r24,Y+4
 4228 13dc 84FF      		sbrs r24,4
 4229 13de 00C0      		rjmp .L289
3137:ff.c          **** 			}
 4230               		.loc 1 3137 0
 4231 13e0 6E85      		ldd r22,Y+14
 4232 13e2 7F85      		ldd r23,Y+15
 4233 13e4 7170      		andi r23,1
 4234 13e6 680D      		add r22,r8
 4235 13e8 791D      		adc r23,r9
 4236 13ea F601      		movw r30,r12
 4237 13ec 8081      		ld r24,Z
 4238 13ee 0E94 0000 		call ld_clust.isra.3
 4239               	.LVL357:
 4240 13f2 6E83      		std Y+6,r22
 4241 13f4 7F83      		std Y+7,r23
 4242 13f6 8887      		std Y+8,r24
 4243 13f8 9987      		std Y+9,r25
 4244               	.LVL358:
 4245               	.L259:
 4246               	.LBB238:
 4247               	.LBB229:
3000:ff.c          **** 	mem_set(sfn, ' ', 11);
 4248               		.loc 1 3000 0
 4249 13fa F701      		movw r30,r14
 4250 13fc 00C0      		rjmp .L260
 4251               	.LVL359:
 4252               	.L318:
3019:ff.c          **** 			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 4253               		.loc 1 3019 0
 4254 13fe 5F32      		cpi r21,lo8(47)
 4255 1400 01F4      		brne .L263
 4256               	.L265:
 4257 1402 F801      		movw r30,r16
 4258 1404 E20F      		add r30,r18
 4259 1406 F31F      		adc r31,r19
 4260 1408 00C0      		rjmp .L264
 4261               	.L263:
 4262 140a 5C35      		cpi r21,lo8(92)
 4263 140c 01F4      		brne .L316
 4264 140e 00C0      		rjmp .L265
 4265               	.L321:
3020:ff.c          **** 			break;
 4266               		.loc 1 3020 0
 4267 1410 4C35      		cpi r20,lo8(92)
 4268 1412 01F4      		brne .L262
 4269               	.L264:
 4270 1414 9F01      		movw r18,r30
 4271               	.LVL360:
 4272 1416 201B      		sub r18,r16
 4273 1418 310B      		sbc r19,r17
 4274               	.LVL361:
 4275 141a 4191      		ld r20,Z+
 4276 141c 4F32      		cpi r20,lo8(47)
 4277 141e 01F4      		brne .L321
 4278 1420 00C0      		rjmp .L264
 4279               	.L316:
3023:ff.c          **** 			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
 4280               		.loc 1 3023 0
 4281 1422 5E32      		cpi r21,lo8(46)
 4282 1424 01F4      		brne .+2
 4283 1426 00C0      		rjmp .L268
 4284 1428 8617      		cp r24,r22
 4285 142a 9707      		cpc r25,r23
 4286 142c 00F0      		brlo .+2
 4287 142e 00C0      		rjmp .L290
3033:ff.c          **** 			c = ExCvt[c & 0x7F];		/* To upper SBC extended character */
 4288               		.loc 1 3033 0
 4289 1430 57FF      		sbrs r21,7
 4290 1432 00C0      		rjmp .L270
3034:ff.c          **** 		}
 4291               		.loc 1 3034 0
 4292 1434 A52F      		mov r26,r21
 4293 1436 AF77      		andi r26,lo8(127)
 4294 1438 B0E0      		ldi r27,0
 4295 143a A050      		subi r26,lo8(-(ExCvt))
 4296 143c B040      		sbci r27,hi8(-(ExCvt))
 4297 143e 5C91      		ld r21,X
 4298               	.LVL362:
 4299               	.L270:
3043:ff.c          **** 			if (IsLower(c)) c -= 0x20;	/* To upper */
 4300               		.loc 1 3043 0
 4301 1440 A52E      		mov r10,r21
 4302 1442 B12C      		mov r11,__zero_reg__
 4303               	.LVL363:
 4304 1444 A0E0      		ldi r26,lo8(.LC1)
 4305 1446 B0E0      		ldi r27,hi8(.LC1)
 4306               	.LVL364:
 4307               	.L272:
 4308               	.LBB226:
 4309               	.LBB227:
 725:ff.c          **** 	return *str;
 4310               		.loc 1 725 0
 4311 1448 4D91      		ld r20,X+
 4312               	.LVL365:
 4313 144a 4423      		tst r20
 4314 144c 01F4      		brne .+2
 4315 144e 00C0      		rjmp .L271
 4316 1450 442E      		mov r4,r20
 4317 1452 512C      		mov r5,__zero_reg__
 4318 1454 A414      		cp r10,r4
 4319 1456 B504      		cpc r11,r5
 4320 1458 01F4      		brne .L272
 4321 145a 00C0      		rjmp .L290
 4322               	.LVL366:
 4323               	.L286:
 4324               	.LBE227:
 4325               	.LBE226:
3052:ff.c          **** 
 4326               		.loc 1 3052 0
 4327 145c 84E0      		ldi r24,lo8(4)
 4328 145e 00C0      		rjmp .L275
 4329               	.LVL367:
 4330               	.L319:
 4331               	.LBE229:
 4332               	.LBE238:
 4333               	.LBB239:
 4334               	.LBB237:
2480:ff.c          **** 		if (res != FR_OK) break;
 4335               		.loc 1 2480 0
 4336 1460 4E89      		ldd r20,Y+22
 4337 1462 5F89      		ldd r21,Y+23
 4338 1464 688D      		ldd r22,Y+24
 4339 1466 798D      		ldd r23,Y+25
 4340 1468 C501      		movw r24,r10
 4341               	.LVL368:
 4342 146a 0E94 0000 		call move_window
 4343               	.LVL369:
2481:ff.c          **** 		c = dp->dir[DIR_Name];
 4344               		.loc 1 2481 0
 4345 146e 8111      		cpse r24,__zero_reg__
 4346 1470 00C0      		rjmp .L276
2482:ff.c          **** 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 4347               		.loc 1 2482 0
 4348 1472 EA8D      		ldd r30,Y+26
 4349 1474 FB8D      		ldd r31,Y+27
 4350               	.LVL370:
2483:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 4351               		.loc 1 2483 0
 4352 1476 9081      		ld r25,Z
 4353 1478 9923      		tst r25
 4354 147a 01F0      		breq .L287
2506:ff.c          **** 		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry
 4355               		.loc 1 2506 0
 4356 147c 9385      		ldd r25,Z+11
 4357 147e 9F73      		andi r25,lo8(63)
 4358 1480 9C83      		std Y+4,r25
 4359               	.LVL371:
2507:ff.c          **** #endif
 4360               		.loc 1 2507 0
 4361 1482 9385      		ldd r25,Z+11
 4362 1484 93FD      		sbrc r25,3
 4363 1486 00C0      		rjmp .L277
 4364 1488 AF01      		movw r20,r30
 4365 148a 455F      		subi r20,-11
 4366 148c 5F4F      		sbci r21,-1
 4367 148e D701      		movw r26,r14
 4368               	.L279:
 4369               	.LVL372:
 4370               	.LBB235:
 4371               	.LBB236:
 715:ff.c          **** 	} while (--cnt && r == 0);
 4372               		.loc 1 715 0
 4373 1490 2191      		ld r18,Z+
 4374               	.LVL373:
 4375 1492 9D91      		ld r25,X+
 4376 1494 30E0      		ldi r19,0
 4377 1496 291B      		sub r18,r25
 4378 1498 3109      		sbc r19,__zero_reg__
 4379               	.LVL374:
 716:ff.c          **** 
 4380               		.loc 1 716 0
 4381 149a 4E17      		cp r20,r30
 4382 149c 5F07      		cpc r21,r31
 4383 149e 01F0      		breq .L278
 4384 14a0 232B      		or r18,r19
 4385 14a2 01F0      		breq .L279
 4386 14a4 00C0      		rjmp .L277
 4387               	.L278:
 4388               	.LVL375:
 4389               	.LBE236:
 4390               	.LBE235:
2507:ff.c          **** #endif
 4391               		.loc 1 2507 0
 4392 14a6 232B      		or r18,r19
 4393 14a8 01F4      		brne .+2
 4394 14aa 00C0      		rjmp .L276
 4395               	.LVL376:
 4396               	.L277:
2509:ff.c          **** 	} while (res == FR_OK);
 4397               		.loc 1 2509 0
 4398 14ac 60E0      		ldi r22,0
 4399 14ae 70E0      		ldi r23,0
 4400 14b0 CE01      		movw r24,r28
 4401               	.LVL377:
 4402 14b2 0E94 0000 		call dir_next
 4403               	.LVL378:
 4404 14b6 00C0      		rjmp .L317
 4405               	.LVL379:
 4406               	.L287:
2483:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 4407               		.loc 1 2483 0
 4408 14b8 84E0      		ldi r24,lo8(4)
 4409               	.LVL380:
 4410 14ba 00C0      		rjmp .L276
 4411               	.LVL381:
 4412               	.L320:
 4413               	.LBE237:
 4414               	.LBE239:
3112:ff.c          **** 					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
 4415               		.loc 1 3112 0
 4416 14bc 8430      		cpi r24,lo8(4)
 4417 14be 01F4      		brne .L299
3118:ff.c          **** 					}
 4418               		.loc 1 3118 0
 4419 14c0 92FD      		sbrc r25,2
 4420 14c2 00C0      		rjmp .L299
 4421               	.L289:
 4422 14c4 85E0      		ldi r24,lo8(5)
 4423 14c6 00C0      		rjmp .L299
 4424               	.LVL382:
 4425               	.L290:
 4426               	.LBB240:
 4427               	.LBB230:
3024:ff.c          **** 			i = 8; ni = 11;				/* Enter file extension field */
 4428               		.loc 1 3024 0
 4429 14c8 86E0      		ldi r24,lo8(6)
 4430               	.LVL383:
 4431               	.LBE230:
 4432               	.LBE240:
3142:ff.c          **** }
 4433               		.loc 1 3142 0
 4434 14ca 00C0      		rjmp .L299
 4435               	.LVL384:
 4436               	.L271:
 4437               	.LBB241:
 4438               	.LBB231:
3044:ff.c          **** 			sfn[i++] = c;
 4439               		.loc 1 3044 0
 4440 14cc 4FE9      		ldi r20,lo8(-97)
 4441 14ce 450F      		add r20,r21
 4442 14d0 4A31      		cpi r20,lo8(26)
 4443 14d2 00F4      		brsh .L283
 4444 14d4 5052      		subi r21,lo8(-(-32))
 4445               	.LVL385:
 4446               	.L283:
3045:ff.c          **** 		}
 4447               		.loc 1 3045 0
 4448 14d6 D701      		movw r26,r14
 4449 14d8 A80F      		add r26,r24
 4450 14da B91F      		adc r27,r25
 4451 14dc 5C93      		st X,r21
 4452 14de 0196      		adiw r24,1
 4453               	.LVL386:
 4454 14e0 00C0      		rjmp .L261
 4455               	.LVL387:
 4456               	.L268:
3024:ff.c          **** 			i = 8; ni = 11;				/* Enter file extension field */
 4457               		.loc 1 3024 0
 4458 14e2 6B30      		cpi r22,11
 4459 14e4 7105      		cpc r23,__zero_reg__
 4460 14e6 01F0      		breq .L290
3025:ff.c          **** 			continue;
 4461               		.loc 1 3025 0
 4462 14e8 88E0      		ldi r24,lo8(8)
 4463 14ea 90E0      		ldi r25,0
 4464               	.LVL388:
 4465 14ec 6BE0      		ldi r22,lo8(11)
 4466 14ee 70E0      		ldi r23,0
 4467               	.LVL389:
 4468 14f0 00C0      		rjmp .L261
 4469               	.LVL390:
 4470               	.L299:
 4471               	/* epilogue start */
 4472               	.LBE231:
 4473               	.LBE241:
3143:ff.c          **** 
 4474               		.loc 1 3143 0
 4475 14f2 DF91      		pop r29
 4476 14f4 CF91      		pop r28
 4477               	.LVL391:
 4478 14f6 1F91      		pop r17
 4479 14f8 0F91      		pop r16
 4480               	.LVL392:
 4481 14fa FF90      		pop r15
 4482 14fc EF90      		pop r14
 4483 14fe DF90      		pop r13
 4484 1500 CF90      		pop r12
 4485               	.LVL393:
 4486 1502 BF90      		pop r11
 4487 1504 AF90      		pop r10
 4488 1506 9F90      		pop r9
 4489 1508 8F90      		pop r8
 4490               	.LVL394:
 4491 150a 7F90      		pop r7
 4492 150c 6F90      		pop r6
 4493               	.LVL395:
 4494 150e 5F90      		pop r5
 4495 1510 4F90      		pop r4
 4496 1512 3F90      		pop r3
 4497 1514 2F90      		pop r2
 4498 1516 0895      		ret
 4499               		.cfi_endproc
 4500               	.LFE30:
 4503               	dir_read.constprop.13:
 4504               	.LFB67:
2364:ff.c          **** 	DIR* dp,		/* Pointer to the directory object */
 4505               		.loc 1 2364 0
 4506               		.cfi_startproc
 4507               	.LVL396:
 4508 1518 0F93      		push r16
 4509               	.LCFI151:
 4510               		.cfi_def_cfa_offset 3
 4511               		.cfi_offset 16, -2
 4512 151a 1F93      		push r17
 4513               	.LCFI152:
 4514               		.cfi_def_cfa_offset 4
 4515               		.cfi_offset 17, -3
 4516 151c CF93      		push r28
 4517               	.LCFI153:
 4518               		.cfi_def_cfa_offset 5
 4519               		.cfi_offset 28, -4
 4520 151e DF93      		push r29
 4521               	.LCFI154:
 4522               		.cfi_def_cfa_offset 6
 4523               		.cfi_offset 29, -5
 4524               	/* prologue: function */
 4525               	/* frame size = 0 */
 4526               	/* stack size = 4 */
 4527               	.L__stack_usage = 4
 4528 1520 EC01      		movw r28,r24
 4529               	.LVL397:
2370:ff.c          **** 	BYTE attr, b;
 4530               		.loc 1 2370 0
 4531 1522 0881      		ld r16,Y
 4532 1524 1981      		ldd r17,Y+1
 4533               	.LVL398:
2369:ff.c          **** 	FATFS *fs = dp->obj.fs;
 4534               		.loc 1 2369 0
 4535 1526 84E0      		ldi r24,lo8(4)
 4536               	.LVL399:
 4537               	.L323:
2376:ff.c          **** 		res = move_window(fs, dp->sect);
 4538               		.loc 1 2376 0
 4539 1528 4E89      		ldd r20,Y+22
 4540 152a 5F89      		ldd r21,Y+23
 4541 152c 688D      		ldd r22,Y+24
 4542 152e 798D      		ldd r23,Y+25
 4543 1530 4115      		cp r20,__zero_reg__
 4544 1532 5105      		cpc r21,__zero_reg__
 4545 1534 6105      		cpc r22,__zero_reg__
 4546 1536 7105      		cpc r23,__zero_reg__
 4547 1538 01F0      		breq .L347
2377:ff.c          **** 		if (res != FR_OK) break;
 4548               		.loc 1 2377 0
 4549 153a C801      		movw r24,r16
 4550               	.LVL400:
 4551 153c 0E94 0000 		call move_window
 4552               	.LVL401:
2378:ff.c          **** 		b = dp->dir[DIR_Name];	/* Test for the entry type */
 4553               		.loc 1 2378 0
 4554 1540 8111      		cpse r24,__zero_reg__
 4555 1542 00C0      		rjmp .L329
2379:ff.c          **** 		if (b == 0) {
 4556               		.loc 1 2379 0
 4557 1544 EA8D      		ldd r30,Y+26
 4558 1546 FB8D      		ldd r31,Y+27
 4559 1548 9081      		ld r25,Z
 4560               	.LVL402:
2380:ff.c          **** 			res = FR_NO_FILE; break; /* Reached to end of the directory */
 4561               		.loc 1 2380 0
 4562 154a 9923      		tst r25
 4563 154c 01F0      		breq .L330
2400:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 4564               		.loc 1 2400 0
 4565 154e 8385      		ldd r24,Z+11
 4566               	.LVL403:
 4567 1550 8F73      		andi r24,lo8(63)
 4568               	.LVL404:
 4569 1552 8C83      		std Y+4,r24
2421:ff.c          **** 				break;
 4570               		.loc 1 2421 0
 4571 1554 953E      		cpi r25,lo8(-27)
 4572 1556 01F0      		breq .L325
 4573 1558 9E32      		cpi r25,lo8(46)
 4574 155a 01F0      		breq .L325
 4575 155c 8F30      		cpi r24,lo8(15)
 4576 155e 01F0      		breq .L325
 4577 1560 8F71      		andi r24,lo8(31)
 4578               	.LVL405:
 4579 1562 8830      		cpi r24,lo8(8)
 4580 1564 01F0      		breq .L325
 4581               	.LVL406:
 4582               	.L328:
2369:ff.c          **** 	FATFS *fs = dp->obj.fs;
 4583               		.loc 1 2369 0
 4584 1566 80E0      		ldi r24,0
 4585 1568 00C0      		rjmp .L346
 4586               	.LVL407:
 4587               	.L325:
2426:ff.c          **** 		if (res != FR_OK) break;
 4588               		.loc 1 2426 0
 4589 156a 60E0      		ldi r22,0
 4590 156c 70E0      		ldi r23,0
 4591 156e CE01      		movw r24,r28
 4592 1570 0E94 0000 		call dir_next
 4593               	.LVL408:
2427:ff.c          **** 	}
 4594               		.loc 1 2427 0
 4595 1574 8823      		tst r24
 4596 1576 01F0      		breq .L323
 4597 1578 00C0      		rjmp .L329
 4598               	.L347:
2430:ff.c          **** 	return res;
 4599               		.loc 1 2430 0
 4600 157a 8823      		tst r24
 4601 157c 01F0      		breq .L328
 4602               	.LVL409:
 4603               	.L329:
 4604 157e 1E8A      		std Y+22,__zero_reg__
 4605 1580 1F8A      		std Y+23,__zero_reg__
 4606 1582 188E      		std Y+24,__zero_reg__
 4607 1584 198E      		std Y+25,__zero_reg__
 4608 1586 00C0      		rjmp .L346
 4609               	.LVL410:
 4610               	.L330:
2381:ff.c          **** 		}
 4611               		.loc 1 2381 0
 4612 1588 84E0      		ldi r24,lo8(4)
 4613               	.LVL411:
 4614 158a 00C0      		rjmp .L329
 4615               	.LVL412:
 4616               	.L346:
 4617               	/* epilogue start */
2432:ff.c          **** 
 4618               		.loc 1 2432 0
 4619 158c DF91      		pop r29
 4620 158e CF91      		pop r28
 4621               	.LVL413:
 4622 1590 1F91      		pop r17
 4623 1592 0F91      		pop r16
 4624               	.LVL414:
 4625 1594 0895      		ret
 4626               		.cfi_endproc
 4627               	.LFE67:
 4630               	dir_register:
 4631               	.LFB26:
2526:ff.c          **** 	FRESULT res;
 4632               		.loc 1 2526 0
 4633               		.cfi_startproc
 4634               	.LVL415:
 4635 1596 EF92      		push r14
 4636               	.LCFI155:
 4637               		.cfi_def_cfa_offset 3
 4638               		.cfi_offset 14, -2
 4639 1598 FF92      		push r15
 4640               	.LCFI156:
 4641               		.cfi_def_cfa_offset 4
 4642               		.cfi_offset 15, -3
 4643 159a 0F93      		push r16
 4644               	.LCFI157:
 4645               		.cfi_def_cfa_offset 5
 4646               		.cfi_offset 16, -4
 4647 159c 1F93      		push r17
 4648               	.LCFI158:
 4649               		.cfi_def_cfa_offset 6
 4650               		.cfi_offset 17, -5
 4651 159e CF93      		push r28
 4652               	.LCFI159:
 4653               		.cfi_def_cfa_offset 7
 4654               		.cfi_offset 28, -6
 4655               	/* prologue: function */
 4656               	/* frame size = 0 */
 4657               	/* stack size = 5 */
 4658               	.L__stack_usage = 5
 4659 15a0 8C01      		movw r16,r24
2528:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 4660               		.loc 1 2528 0
 4661 15a2 DC01      		movw r26,r24
 4662 15a4 ED90      		ld r14,X+
 4663 15a6 FC90      		ld r15,X
 4664               	.LVL416:
 4665               	.LBB248:
 4666               	.LBB249:
1832:ff.c          **** 	if (res == FR_OK) {
 4667               		.loc 1 1832 0
 4668 15a8 0E94 0000 		call dir_sdi.constprop.15
 4669               	.LVL417:
 4670               	.L363:
 4671 15ac C82F      		mov r28,r24
 4672               	.LVL418:
1833:ff.c          **** 		n = 0;
 4673               		.loc 1 1833 0
 4674 15ae 8111      		cpse r24,__zero_reg__
 4675 15b0 00C0      		rjmp .L349
 4676               	.LVL419:
1836:ff.c          **** 			if (res != FR_OK) break;
 4677               		.loc 1 1836 0
 4678 15b2 F801      		movw r30,r16
 4679 15b4 4689      		ldd r20,Z+22
 4680 15b6 5789      		ldd r21,Z+23
 4681 15b8 608D      		ldd r22,Z+24
 4682 15ba 718D      		ldd r23,Z+25
 4683 15bc C701      		movw r24,r14
 4684               	.LVL420:
 4685 15be 0E94 0000 		call move_window
 4686               	.LVL421:
 4687 15c2 C82F      		mov r28,r24
 4688               	.LVL422:
1837:ff.c          **** #if FF_FS_EXFAT
 4689               		.loc 1 1837 0
 4690 15c4 8111      		cpse r24,__zero_reg__
 4691 15c6 00C0      		rjmp .L349
1841:ff.c          **** #endif
 4692               		.loc 1 1841 0
 4693 15c8 D801      		movw r26,r16
 4694 15ca 5A96      		adiw r26,26
 4695 15cc ED91      		ld r30,X+
 4696 15ce FC91      		ld r31,X
 4697 15d0 5B97      		sbiw r26,26+1
 4698 15d2 8081      		ld r24,Z
 4699               	.LVL423:
 4700 15d4 853E      		cpi r24,lo8(-27)
 4701 15d6 01F4      		brne .L350
 4702               	.L353:
 4703               	.LVL424:
 4704               	.LBE249:
 4705               	.LBE248:
2606:ff.c          **** 		if (res == FR_OK) {
 4706               		.loc 1 2606 0
 4707 15d8 F801      		movw r30,r16
 4708 15da 4689      		ldd r20,Z+22
 4709 15dc 5789      		ldd r21,Z+23
 4710 15de 608D      		ldd r22,Z+24
 4711 15e0 718D      		ldd r23,Z+25
 4712 15e2 C701      		movw r24,r14
 4713 15e4 0E94 0000 		call move_window
 4714               	.LVL425:
 4715 15e8 C82F      		mov r28,r24
 4716               	.LVL426:
2607:ff.c          **** 			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 4717               		.loc 1 2607 0
 4718 15ea 8111      		cpse r24,__zero_reg__
 4719 15ec 00C0      		rjmp .L358
2608:ff.c          **** 			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 4720               		.loc 1 2608 0
 4721 15ee D801      		movw r26,r16
 4722 15f0 5A96      		adiw r26,26
 4723 15f2 ED91      		ld r30,X+
 4724 15f4 FC91      		ld r31,X
 4725 15f6 5B97      		sbiw r26,26+1
 4726               	.LVL427:
 4727 15f8 CF01      		movw r24,r30
 4728               	.LVL428:
 4729 15fa 8096      		adiw r24,32
 4730 15fc 00C0      		rjmp .L355
 4731               	.LVL429:
 4732               	.L350:
 4733               	.LBB252:
 4734               	.LBB250:
1841:ff.c          **** #endif
 4735               		.loc 1 1841 0
 4736 15fe 8823      		tst r24
 4737 1600 01F0      		breq .L353
1847:ff.c          **** 		} while (res == FR_OK);
 4738               		.loc 1 1847 0
 4739 1602 61E0      		ldi r22,lo8(1)
 4740 1604 70E0      		ldi r23,0
 4741 1606 C801      		movw r24,r16
 4742 1608 0E94 0000 		call dir_next
 4743               	.LVL430:
 4744 160c 00C0      		rjmp .L363
 4745               	.LVL431:
 4746               	.L355:
 4747               	.LBE250:
 4748               	.LBE252:
 4749               	.LBB253:
 4750               	.LBB254:
 703:ff.c          **** 	} while (--cnt);
 4751               		.loc 1 703 0
 4752 160e 1192      		st Z+,__zero_reg__
 4753               	.LVL432:
 704:ff.c          **** }
 4754               		.loc 1 704 0
 4755 1610 8E17      		cp r24,r30
 4756 1612 9F07      		cpc r25,r31
 4757 1614 01F4      		brne .L355
 4758               	.LVL433:
 4759               	.LBE254:
 4760               	.LBE253:
2609:ff.c          **** #if FF_USE_LFN
 4761               		.loc 1 2609 0
 4762 1616 B801      		movw r22,r16
 4763 1618 645E      		subi r22,-28
 4764 161a 7F4F      		sbci r23,-1
 4765               	.LVL434:
 4766               	.LBB255:
 4767               	.LBB256:
 4768 161c 4BE0      		ldi r20,lo8(11)
 4769 161e 50E0      		ldi r21,0
 4770 1620 F801      		movw r30,r16
 4771               	.LVL435:
 4772 1622 828D      		ldd r24,Z+26
 4773 1624 938D      		ldd r25,Z+27
 4774 1626 0E94 0000 		call mem_cpy.part.0
 4775               	.LVL436:
 4776               	.LBE256:
 4777               	.LBE255:
2613:ff.c          **** 		}
 4778               		.loc 1 2613 0
 4779 162a 81E0      		ldi r24,lo8(1)
 4780 162c D701      		movw r26,r14
 4781 162e 1396      		adiw r26,3
 4782 1630 8C93      		st X,r24
 4783 1632 00C0      		rjmp .L358
 4784               	.LVL437:
 4785               	.L349:
 4786               	.LBB257:
 4787               	.LBB251:
1851:ff.c          **** 	return res;
 4788               		.loc 1 1851 0
 4789 1634 C430      		cpi r28,lo8(4)
 4790 1636 01F4      		brne .L358
 4791 1638 C7E0      		ldi r28,lo8(7)
 4792               	.LVL438:
 4793               	.L358:
 4794               	.LBE251:
 4795               	.LBE257:
2618:ff.c          **** 
 4796               		.loc 1 2618 0
 4797 163a 8C2F      		mov r24,r28
 4798               	/* epilogue start */
 4799 163c CF91      		pop r28
 4800 163e 1F91      		pop r17
 4801 1640 0F91      		pop r16
 4802               	.LVL439:
 4803 1642 FF90      		pop r15
 4804 1644 EF90      		pop r14
 4805               	.LVL440:
 4806 1646 0895      		ret
 4807               		.cfi_endproc
 4808               	.LFE26:
 4811               	remove_chain:
 4812               	.LFB16:
1451:ff.c          **** 	FRESULT res = FR_OK;
 4813               		.loc 1 1451 0
 4814               		.cfi_startproc
 4815               	.LVL441:
 4816 1648 4F92      		push r4
 4817               	.LCFI160:
 4818               		.cfi_def_cfa_offset 3
 4819               		.cfi_offset 4, -2
 4820 164a 5F92      		push r5
 4821               	.LCFI161:
 4822               		.cfi_def_cfa_offset 4
 4823               		.cfi_offset 5, -3
 4824 164c 6F92      		push r6
 4825               	.LCFI162:
 4826               		.cfi_def_cfa_offset 5
 4827               		.cfi_offset 6, -4
 4828 164e 7F92      		push r7
 4829               	.LCFI163:
 4830               		.cfi_def_cfa_offset 6
 4831               		.cfi_offset 7, -5
 4832 1650 8F92      		push r8
 4833               	.LCFI164:
 4834               		.cfi_def_cfa_offset 7
 4835               		.cfi_offset 8, -6
 4836 1652 9F92      		push r9
 4837               	.LCFI165:
 4838               		.cfi_def_cfa_offset 8
 4839               		.cfi_offset 9, -7
 4840 1654 AF92      		push r10
 4841               	.LCFI166:
 4842               		.cfi_def_cfa_offset 9
 4843               		.cfi_offset 10, -8
 4844 1656 BF92      		push r11
 4845               	.LCFI167:
 4846               		.cfi_def_cfa_offset 10
 4847               		.cfi_offset 11, -9
 4848 1658 EF92      		push r14
 4849               	.LCFI168:
 4850               		.cfi_def_cfa_offset 11
 4851               		.cfi_offset 14, -10
 4852 165a FF92      		push r15
 4853               	.LCFI169:
 4854               		.cfi_def_cfa_offset 12
 4855               		.cfi_offset 15, -11
 4856 165c 0F93      		push r16
 4857               	.LCFI170:
 4858               		.cfi_def_cfa_offset 13
 4859               		.cfi_offset 16, -12
 4860 165e 1F93      		push r17
 4861               	.LCFI171:
 4862               		.cfi_def_cfa_offset 14
 4863               		.cfi_offset 17, -13
 4864 1660 CF93      		push r28
 4865               	.LCFI172:
 4866               		.cfi_def_cfa_offset 15
 4867               		.cfi_offset 28, -14
 4868 1662 DF93      		push r29
 4869               	.LCFI173:
 4870               		.cfi_def_cfa_offset 16
 4871               		.cfi_offset 29, -15
 4872               	/* prologue: function */
 4873               	/* frame size = 0 */
 4874               	/* stack size = 14 */
 4875               	.L__stack_usage = 14
 4876 1664 7C01      		movw r14,r24
 4877 1666 4A01      		movw r8,r20
 4878 1668 5B01      		movw r10,r22
 4879 166a B901      		movw r22,r18
 4880 166c A801      		movw r20,r16
 4881               	.LVL442:
1462:ff.c          **** 
 4882               		.loc 1 1462 0
 4883 166e 22E0      		ldi r18,2
 4884 1670 8216      		cp r8,r18
 4885 1672 9104      		cpc r9,__zero_reg__
 4886 1674 A104      		cpc r10,__zero_reg__
 4887 1676 B104      		cpc r11,__zero_reg__
 4888 1678 00F4      		brsh .L365
 4889               	.LVL443:
 4890               	.L367:
 4891 167a 82E0      		ldi r24,lo8(2)
 4892 167c 00C0      		rjmp .L366
 4893               	.LVL444:
 4894               	.L365:
1454:ff.c          **** #if FF_FS_EXFAT || FF_USE_TRIM
 4895               		.loc 1 1454 0 discriminator 2
 4896 167e FC01      		movw r30,r24
 4897 1680 C081      		ld r28,Z
 4898 1682 D181      		ldd r29,Z+1
1462:ff.c          **** 
 4899               		.loc 1 1462 0 discriminator 2
 4900 1684 8B89      		ldd r24,Y+19
 4901 1686 9C89      		ldd r25,Y+20
 4902 1688 AD89      		ldd r26,Y+21
 4903 168a BE89      		ldd r27,Y+22
 4904 168c 8816      		cp r8,r24
 4905 168e 9906      		cpc r9,r25
 4906 1690 AA06      		cpc r10,r26
 4907 1692 BB06      		cpc r11,r27
 4908 1694 00F4      		brsh .L367
1465:ff.c          **** 		res = put_fat(fs, pclst, 0xFFFFFFFF);
 4909               		.loc 1 1465 0
 4910 1696 4115      		cp r20,__zero_reg__
 4911 1698 5105      		cpc r21,__zero_reg__
 4912 169a 6105      		cpc r22,__zero_reg__
 4913 169c 7105      		cpc r23,__zero_reg__
 4914 169e 01F0      		breq .L369
1466:ff.c          **** 		if (res != FR_OK) return res;
 4915               		.loc 1 1466 0
 4916 16a0 0FEF      		ldi r16,lo8(-1)
 4917 16a2 1FEF      		ldi r17,lo8(-1)
 4918 16a4 9801      		movw r18,r16
 4919               	.LVL445:
 4920 16a6 CE01      		movw r24,r28
 4921 16a8 0E94 0000 		call put_fat
 4922               	.LVL446:
1467:ff.c          **** 	}
 4923               		.loc 1 1467 0
 4924 16ac 8111      		cpse r24,__zero_reg__
 4925 16ae 00C0      		rjmp .L366
 4926               	.LVL447:
 4927               	.L369:
1472:ff.c          **** 		if (nxt == 0) break;				/* Empty cluster? */
 4928               		.loc 1 1472 0
 4929 16b0 B501      		movw r22,r10
 4930 16b2 A401      		movw r20,r8
 4931 16b4 F701      		movw r30,r14
 4932 16b6 8081      		ld r24,Z
 4933 16b8 9181      		ldd r25,Z+1
 4934 16ba 0E94 0000 		call get_fat.isra.10
 4935               	.LVL448:
 4936 16be 2B01      		movw r4,r22
 4937 16c0 3C01      		movw r6,r24
 4938               	.LVL449:
1473:ff.c          **** 		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 4939               		.loc 1 1473 0
 4940 16c2 6115      		cp r22,__zero_reg__
 4941 16c4 7105      		cpc r23,__zero_reg__
 4942 16c6 8105      		cpc r24,__zero_reg__
 4943 16c8 9105      		cpc r25,__zero_reg__
 4944 16ca 01F4      		brne .L371
 4945               	.L373:
1531:ff.c          **** }
 4946               		.loc 1 1531 0
 4947 16cc 80E0      		ldi r24,0
 4948 16ce 00C0      		rjmp .L366
 4949               	.L371:
1474:ff.c          **** 		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 4950               		.loc 1 1474 0
 4951 16d0 6130      		cpi r22,1
 4952 16d2 7105      		cpc r23,__zero_reg__
 4953 16d4 8105      		cpc r24,__zero_reg__
 4954 16d6 9105      		cpc r25,__zero_reg__
 4955 16d8 01F0      		breq .L367
1475:ff.c          **** 		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 4956               		.loc 1 1475 0
 4957 16da 6F3F      		cpi r22,-1
 4958 16dc 7F4F      		sbci r23,-1
 4959 16de 8F4F      		sbci r24,-1
 4960 16e0 9F4F      		sbci r25,-1
 4961 16e2 01F0      		breq .L375
1477:ff.c          **** 			if (res != FR_OK) return res;
 4962               		.loc 1 1477 0
 4963 16e4 00E0      		ldi r16,0
 4964 16e6 10E0      		ldi r17,0
 4965 16e8 9801      		movw r18,r16
 4966 16ea B501      		movw r22,r10
 4967 16ec A401      		movw r20,r8
 4968 16ee CE01      		movw r24,r28
 4969 16f0 0E94 0000 		call put_fat
 4970               	.LVL450:
1478:ff.c          **** 		}
 4971               		.loc 1 1478 0
 4972 16f4 8111      		cpse r24,__zero_reg__
 4973 16f6 00C0      		rjmp .L366
1480:ff.c          **** 			fs->free_clst++;
 4974               		.loc 1 1480 0
 4975 16f8 8F85      		ldd r24,Y+15
 4976 16fa 9889      		ldd r25,Y+16
 4977 16fc A989      		ldd r26,Y+17
 4978 16fe BA89      		ldd r27,Y+18
 4979               	.LVL451:
 4980 1700 4B89      		ldd r20,Y+19
 4981 1702 5C89      		ldd r21,Y+20
 4982 1704 6D89      		ldd r22,Y+21
 4983 1706 7E89      		ldd r23,Y+22
 4984 1708 4A01      		movw r8,r20
 4985 170a 5B01      		movw r10,r22
 4986               	.LVL452:
 4987 170c E2E0      		ldi r30,2
 4988 170e 8E1A      		sub r8,r30
 4989 1710 9108      		sbc r9,__zero_reg__
 4990 1712 A108      		sbc r10,__zero_reg__
 4991 1714 B108      		sbc r11,__zero_reg__
 4992 1716 8815      		cp r24,r8
 4993 1718 9905      		cpc r25,r9
 4994 171a AA05      		cpc r26,r10
 4995 171c BB05      		cpc r27,r11
 4996 171e 00F4      		brsh .L372
1481:ff.c          **** 			fs->fsi_flag |= 1;
 4997               		.loc 1 1481 0
 4998 1720 0196      		adiw r24,1
 4999 1722 A11D      		adc r26,__zero_reg__
 5000 1724 B11D      		adc r27,__zero_reg__
 5001 1726 8F87      		std Y+15,r24
 5002 1728 988B      		std Y+16,r25
 5003 172a A98B      		std Y+17,r26
 5004 172c BA8B      		std Y+18,r27
1482:ff.c          **** 		}
 5005               		.loc 1 1482 0
 5006 172e 8C81      		ldd r24,Y+4
 5007 1730 8160      		ori r24,lo8(1)
 5008 1732 8C83      		std Y+4,r24
 5009               	.L372:
 5010               	.LVL453:
 5011 1734 5301      		movw r10,r6
 5012 1736 4201      		movw r8,r4
1503:ff.c          **** 
 5013               		.loc 1 1503 0
 5014 1738 4416      		cp r4,r20
 5015 173a 5506      		cpc r5,r21
 5016 173c 6606      		cpc r6,r22
 5017 173e 7706      		cpc r7,r23
 5018 1740 00F4      		brsh .+2
 5019 1742 00C0      		rjmp .L369
 5020 1744 00C0      		rjmp .L373
 5021               	.LVL454:
 5022               	.L375:
1475:ff.c          **** 		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 5023               		.loc 1 1475 0
 5024 1746 81E0      		ldi r24,lo8(1)
 5025               	.LVL455:
 5026               	.L366:
 5027               	/* epilogue start */
1532:ff.c          **** 
 5028               		.loc 1 1532 0
 5029 1748 DF91      		pop r29
 5030 174a CF91      		pop r28
 5031 174c 1F91      		pop r17
 5032 174e 0F91      		pop r16
 5033 1750 FF90      		pop r15
 5034 1752 EF90      		pop r14
 5035               	.LVL456:
 5036 1754 BF90      		pop r11
 5037 1756 AF90      		pop r10
 5038 1758 9F90      		pop r9
 5039 175a 8F90      		pop r8
 5040               	.LVL457:
 5041 175c 7F90      		pop r7
 5042 175e 6F90      		pop r6
 5043 1760 5F90      		pop r5
 5044 1762 4F90      		pop r4
 5045 1764 0895      		ret
 5046               		.cfi_endproc
 5047               	.LFE16:
 5050               	sync_fs:
 5051               	.LFB12:
1128:ff.c          **** 	FRESULT res;
 5052               		.loc 1 1128 0
 5053               		.cfi_startproc
 5054               	.LVL458:
 5055 1766 0F93      		push r16
 5056               	.LCFI174:
 5057               		.cfi_def_cfa_offset 3
 5058               		.cfi_offset 16, -2
 5059 1768 1F93      		push r17
 5060               	.LCFI175:
 5061               		.cfi_def_cfa_offset 4
 5062               		.cfi_offset 17, -3
 5063 176a CF93      		push r28
 5064               	.LCFI176:
 5065               		.cfi_def_cfa_offset 5
 5066               		.cfi_offset 28, -4
 5067 176c DF93      		push r29
 5068               	.LCFI177:
 5069               		.cfi_def_cfa_offset 6
 5070               		.cfi_offset 29, -5
 5071               	/* prologue: function */
 5072               	/* frame size = 0 */
 5073               	/* stack size = 4 */
 5074               	.L__stack_usage = 4
 5075 176e EC01      		movw r28,r24
1132:ff.c          **** 	if (res == FR_OK) {
 5076               		.loc 1 1132 0
 5077 1770 0E94 0000 		call sync_window
 5078               	.LVL459:
 5079 1774 982F      		mov r25,r24
 5080               	.LVL460:
1133:ff.c          **** 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 5081               		.loc 1 1133 0
 5082 1776 8111      		cpse r24,__zero_reg__
 5083 1778 00C0      		rjmp .L382
1134:ff.c          **** 			/* Create FSInfo structure */
 5084               		.loc 1 1134 0
 5085 177a 8881      		ld r24,Y
 5086               	.LVL461:
 5087 177c 8330      		cpi r24,lo8(3)
 5088 177e 01F0      		breq .+2
 5089 1780 00C0      		rjmp .L383
1134:ff.c          **** 			/* Create FSInfo structure */
 5090               		.loc 1 1134 0 is_stmt 0 discriminator 1
 5091 1782 8C81      		ldd r24,Y+4
 5092 1784 8130      		cpi r24,lo8(1)
 5093 1786 01F0      		breq .+2
 5094 1788 00C0      		rjmp .L383
1136:ff.c          **** 			st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
 5095               		.loc 1 1136 0 is_stmt 1
 5096 178a BE01      		movw r22,r28
 5097 178c 615D      		subi r22,-47
 5098 178e 7F4F      		sbci r23,-1
 5099               	.LVL462:
 5100 1790 FB01      		movw r30,r22
 5101 1792 CE01      		movw r24,r28
 5102 1794 815D      		subi r24,-47
 5103 1796 9D4F      		sbci r25,-3
 5104               	.LVL463:
 5105               	.L384:
 5106               	.LBB270:
 5107               	.LBB271:
 703:ff.c          **** 	} while (--cnt);
 5108               		.loc 1 703 0
 5109 1798 1192      		st Z+,__zero_reg__
 5110               	.LVL464:
 704:ff.c          **** }
 5111               		.loc 1 704 0
 5112 179a E817      		cp r30,r24
 5113 179c F907      		cpc r31,r25
 5114 179e 01F4      		brne .L384
 5115               	.LVL465:
 5116               	.LBE271:
 5117               	.LBE270:
 5118               	.LBB272:
 5119               	.LBB273:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 5120               		.loc 1 650 0
 5121 17a0 85E5      		ldi r24,lo8(85)
 5122 17a2 FE01      		movw r30,r28
 5123               	.LVL466:
 5124 17a4 E35D      		subi r30,-45
 5125 17a6 FD4F      		sbci r31,-3
 5126               	.LVL467:
 5127 17a8 8083      		st Z,r24
 5128               	.LVL468:
 651:ff.c          **** }
 5129               		.loc 1 651 0
 5130 17aa 8AEA      		ldi r24,lo8(-86)
 5131 17ac 3196      		adiw r30,1
 5132               	.LVL469:
 5133 17ae 8083      		st Z,r24
 5134               	.LVL470:
 5135               	.LBE273:
 5136               	.LBE272:
 5137               	.LBB274:
 5138               	.LBB275:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5139               		.loc 1 656 0
 5140 17b0 82E5      		ldi r24,lo8(82)
 5141 17b2 8FA7      		std Y+47,r24
 5142               	.LVL471:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5143               		.loc 1 657 0
 5144 17b4 88AB      		std Y+48,r24
 5145               	.LVL472:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5146               		.loc 1 658 0
 5147 17b6 81E6      		ldi r24,lo8(97)
 5148 17b8 89AB      		std Y+49,r24
 5149               	.LVL473:
 659:ff.c          **** }
 5150               		.loc 1 659 0
 5151 17ba 91E4      		ldi r25,lo8(65)
 5152               	.LVL474:
 5153 17bc 9AAB      		std Y+50,r25
 5154               	.LVL475:
 5155               	.LBE275:
 5156               	.LBE274:
 5157               	.LBB276:
 5158               	.LBB277:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5159               		.loc 1 656 0
 5160 17be 22E7      		ldi r18,lo8(114)
 5161 17c0 7B97      		sbiw r30,27
 5162 17c2 2083      		st Z,r18
 5163               	.LVL476:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5164               		.loc 1 657 0
 5165 17c4 3196      		adiw r30,1
 5166 17c6 2083      		st Z,r18
 5167               	.LVL477:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5168               		.loc 1 658 0
 5169 17c8 3196      		adiw r30,1
 5170 17ca 9083      		st Z,r25
 5171               	.LVL478:
 659:ff.c          **** }
 5172               		.loc 1 659 0
 5173 17cc 3196      		adiw r30,1
 5174 17ce 8083      		st Z,r24
 5175               	.LVL479:
 5176               	.LBE277:
 5177               	.LBE276:
1140:ff.c          **** 			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
 5178               		.loc 1 1140 0
 5179 17d0 3F85      		ldd r19,Y+15
 5180 17d2 2889      		ldd r18,Y+16
 5181 17d4 9989      		ldd r25,Y+17
 5182 17d6 8A89      		ldd r24,Y+18
 5183               	.LVL480:
 5184               	.LBB278:
 5185               	.LBB279:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5186               		.loc 1 656 0
 5187 17d8 3196      		adiw r30,1
 5188 17da 3083      		st Z,r19
 5189               	.LVL481:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5190               		.loc 1 657 0
 5191 17dc 3196      		adiw r30,1
 5192 17de 2083      		st Z,r18
 5193               	.LVL482:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5194               		.loc 1 658 0
 5195 17e0 3196      		adiw r30,1
 5196 17e2 9083      		st Z,r25
 5197               	.LVL483:
 659:ff.c          **** }
 5198               		.loc 1 659 0
 5199 17e4 3196      		adiw r30,1
 5200 17e6 8083      		st Z,r24
 5201               	.LVL484:
 5202               	.LBE279:
 5203               	.LBE278:
1141:ff.c          **** 			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 5204               		.loc 1 1141 0
 5205 17e8 3B85      		ldd r19,Y+11
 5206 17ea 2C85      		ldd r18,Y+12
 5207 17ec 9D85      		ldd r25,Y+13
 5208 17ee 8E85      		ldd r24,Y+14
 5209               	.LVL485:
 5210               	.LBB280:
 5211               	.LBB281:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5212               		.loc 1 656 0
 5213 17f0 3196      		adiw r30,1
 5214 17f2 3083      		st Z,r19
 5215               	.LVL486:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5216               		.loc 1 657 0
 5217 17f4 3196      		adiw r30,1
 5218 17f6 2083      		st Z,r18
 5219               	.LVL487:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5220               		.loc 1 658 0
 5221 17f8 3196      		adiw r30,1
 5222 17fa 9083      		st Z,r25
 5223               	.LVL488:
 659:ff.c          **** }
 5224               		.loc 1 659 0
 5225 17fc 3196      		adiw r30,1
 5226 17fe 8083      		st Z,r24
 5227               	.LVL489:
 5228               	.LBE281:
 5229               	.LBE280:
1142:ff.c          **** 			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 5230               		.loc 1 1142 0
 5231 1800 8B8D      		ldd r24,Y+27
 5232 1802 9C8D      		ldd r25,Y+28
 5233 1804 AD8D      		ldd r26,Y+29
 5234 1806 BE8D      		ldd r27,Y+30
 5235 1808 9C01      		movw r18,r24
 5236 180a AD01      		movw r20,r26
 5237 180c 2F5F      		subi r18,-1
 5238 180e 3F4F      		sbci r19,-1
 5239 1810 4F4F      		sbci r20,-1
 5240 1812 5F4F      		sbci r21,-1
 5241 1814 2BA7      		std Y+43,r18
 5242 1816 3CA7      		std Y+44,r19
 5243 1818 4DA7      		std Y+45,r20
 5244 181a 5EA7      		std Y+46,r21
1143:ff.c          **** 			fs->fsi_flag = 0;
 5245               		.loc 1 1143 0
 5246 181c 01E0      		ldi r16,lo8(1)
 5247 181e 10E0      		ldi r17,0
 5248 1820 8981      		ldd r24,Y+1
 5249 1822 0E94 0000 		call disk_write
 5250               	.LVL490:
1144:ff.c          **** 		}
 5251               		.loc 1 1144 0
 5252 1826 1C82      		std Y+4,__zero_reg__
 5253               	.L383:
1147:ff.c          **** 	}
 5254               		.loc 1 1147 0
 5255 1828 40E0      		ldi r20,0
 5256 182a 50E0      		ldi r21,0
 5257 182c 60E0      		ldi r22,0
 5258 182e 8981      		ldd r24,Y+1
 5259 1830 0E94 0000 		call disk_ioctl
 5260               	.LVL491:
 5261 1834 91E0      		ldi r25,lo8(1)
 5262 1836 8111      		cpse r24,__zero_reg__
 5263 1838 00C0      		rjmp .L382
 5264 183a 90E0      		ldi r25,0
 5265               	.L382:
 5266               	.LVL492:
1151:ff.c          **** 
 5267               		.loc 1 1151 0
 5268 183c 892F      		mov r24,r25
 5269               	/* epilogue start */
 5270 183e DF91      		pop r29
 5271 1840 CF91      		pop r28
 5272               	.LVL493:
 5273 1842 1F91      		pop r17
 5274 1844 0F91      		pop r16
 5275 1846 0895      		ret
 5276               		.cfi_endproc
 5277               	.LFE12:
 5279               	.global	f_mount
 5281               	f_mount:
 5282               	.LFB36:
3646:ff.c          **** 
3647:ff.c          **** 
3648:ff.c          **** 
3649:ff.c          **** 
3650:ff.c          **** /*---------------------------------------------------------------------------
3651:ff.c          **** 
3652:ff.c          ****    Public Functions (FatFs API)
3653:ff.c          **** 
3654:ff.c          **** ----------------------------------------------------------------------------*/
3655:ff.c          **** 
3656:ff.c          **** 
3657:ff.c          **** 
3658:ff.c          **** /*-----------------------------------------------------------------------*/
3659:ff.c          **** /* Mount/Unmount a Logical Drive                                         */
3660:ff.c          **** /*-----------------------------------------------------------------------*/
3661:ff.c          **** 
3662:ff.c          **** FRESULT f_mount (
3663:ff.c          **** 	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
3664:ff.c          **** 	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
3665:ff.c          **** 	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
3666:ff.c          **** )
3667:ff.c          **** {
 5283               		.loc 1 3667 0
 5284               		.cfi_startproc
 5285               	.LVL494:
 5286 1848 1F93      		push r17
 5287               	.LCFI178:
 5288               		.cfi_def_cfa_offset 3
 5289               		.cfi_offset 17, -2
 5290 184a CF93      		push r28
 5291               	.LCFI179:
 5292               		.cfi_def_cfa_offset 4
 5293               		.cfi_offset 28, -3
 5294 184c DF93      		push r29
 5295               	.LCFI180:
 5296               		.cfi_def_cfa_offset 5
 5297               		.cfi_offset 29, -4
 5298 184e 00D0      		rcall .
 5299 1850 00D0      		rcall .
 5300 1852 00D0      		rcall .
 5301               	.LCFI181:
 5302               		.cfi_def_cfa_offset 11
 5303 1854 CDB7      		in r28,__SP_L__
 5304 1856 DEB7      		in r29,__SP_H__
 5305               	.LCFI182:
 5306               		.cfi_def_cfa_register 28
 5307               	/* prologue: function */
 5308               	/* frame size = 6 */
 5309               	/* stack size = 9 */
 5310               	.L__stack_usage = 9
 5311 1858 9C83      		std Y+4,r25
 5312 185a 8B83      		std Y+3,r24
 5313 185c 7E83      		std Y+6,r23
 5314 185e 6D83      		std Y+5,r22
 5315 1860 142F      		mov r17,r20
3668:ff.c          **** 	FATFS *cfs;
3669:ff.c          **** 	int vol;
3670:ff.c          **** 	FRESULT res;
3671:ff.c          **** 	const TCHAR *rp = path;
 5316               		.loc 1 3671 0
 5317 1862 7A83      		std Y+2,r23
 5318 1864 6983      		std Y+1,r22
3672:ff.c          **** 
3673:ff.c          **** 
3674:ff.c          **** 	/* Get logical drive number */
3675:ff.c          **** 	vol = get_ldnumber(&rp);
 5319               		.loc 1 3675 0
 5320 1866 CE01      		movw r24,r28
 5321               	.LVL495:
 5322 1868 0196      		adiw r24,1
 5323 186a 0E94 0000 		call get_ldnumber
 5324               	.LVL496:
3676:ff.c          **** 	if (vol < 0) return FR_INVALID_DRIVE;
 5325               		.loc 1 3676 0
 5326 186e 97FD      		sbrc r25,7
 5327 1870 00C0      		rjmp .L391
3677:ff.c          **** 	cfs = FatFs[vol];					/* Pointer to fs object */
 5328               		.loc 1 3677 0
 5329 1872 880F      		lsl r24
 5330 1874 991F      		rol r25
 5331               	.LVL497:
 5332 1876 FC01      		movw r30,r24
 5333 1878 E050      		subi r30,lo8(-(FatFs))
 5334 187a F040      		sbci r31,hi8(-(FatFs))
 5335 187c 0190      		ld __tmp_reg__,Z+
 5336 187e F081      		ld r31,Z
 5337 1880 E02D      		mov r30,__tmp_reg__
 5338               	.LVL498:
3678:ff.c          **** 
3679:ff.c          **** 	if (cfs) {
 5339               		.loc 1 3679 0
 5340 1882 3097      		sbiw r30,0
 5341 1884 01F0      		breq .L389
3680:ff.c          **** #if FF_FS_LOCK != 0
3681:ff.c          **** 		clear_lock(cfs);
3682:ff.c          **** #endif
3683:ff.c          **** #if FF_FS_REENTRANT						/* Discard sync object of the current volume */
3684:ff.c          **** 		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
3685:ff.c          **** #endif
3686:ff.c          **** 		cfs->fs_type = 0;				/* Clear old fs object */
 5342               		.loc 1 3686 0
 5343 1886 1082      		st Z,__zero_reg__
 5344               	.L389:
3687:ff.c          **** 	}
3688:ff.c          **** 
3689:ff.c          **** 	if (fs) {
 5345               		.loc 1 3689 0
 5346 1888 EB81      		ldd r30,Y+3
 5347 188a FC81      		ldd r31,Y+4
 5348               	.LVL499:
 5349 188c 3097      		sbiw r30,0
 5350 188e 01F0      		breq .L390
3690:ff.c          **** 		fs->fs_type = 0;				/* Clear new fs object */
 5351               		.loc 1 3690 0
 5352 1890 1082      		st Z,__zero_reg__
 5353               	.L390:
3691:ff.c          **** #if FF_FS_REENTRANT						/* Create sync object for the new volume */
3692:ff.c          **** 		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
3693:ff.c          **** #endif
3694:ff.c          **** 	}
3695:ff.c          **** 	FatFs[vol] = fs;					/* Register new fs object */
 5354               		.loc 1 3695 0
 5355 1892 DC01      		movw r26,r24
 5356 1894 A050      		subi r26,lo8(-(FatFs))
 5357 1896 B040      		sbci r27,hi8(-(FatFs))
 5358 1898 ED93      		st X+,r30
 5359 189a FC93      		st X,r31
3696:ff.c          **** 
3697:ff.c          **** 	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 5360               		.loc 1 3697 0
 5361 189c 1123      		tst r17
 5362 189e 01F0      		breq .L392
3698:ff.c          **** 
3699:ff.c          **** 	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
 5363               		.loc 1 3699 0
 5364 18a0 40E0      		ldi r20,0
 5365 18a2 BE01      		movw r22,r28
 5366 18a4 6D5F      		subi r22,-3
 5367 18a6 7F4F      		sbci r23,-1
 5368 18a8 CE01      		movw r24,r28
 5369 18aa 0596      		adiw r24,5
 5370 18ac 0E94 0000 		call mount_volume
 5371               	.LVL500:
3700:ff.c          **** 	LEAVE_FF(fs, res);
 5372               		.loc 1 3700 0
 5373 18b0 00C0      		rjmp .L388
 5374               	.LVL501:
 5375               	.L391:
3676:ff.c          **** 	cfs = FatFs[vol];					/* Pointer to fs object */
 5376               		.loc 1 3676 0
 5377 18b2 8BE0      		ldi r24,lo8(11)
 5378               	.LVL502:
 5379 18b4 00C0      		rjmp .L388
 5380               	.L392:
3697:ff.c          **** 
 5381               		.loc 1 3697 0
 5382 18b6 80E0      		ldi r24,0
 5383               	.L388:
 5384               	/* epilogue start */
3701:ff.c          **** }
 5385               		.loc 1 3701 0
 5386 18b8 2696      		adiw r28,6
 5387               	.LVL503:
 5388 18ba 0FB6      		in __tmp_reg__,__SREG__
 5389 18bc F894      		cli
 5390 18be DEBF      		out __SP_H__,r29
 5391 18c0 0FBE      		out __SREG__,__tmp_reg__
 5392 18c2 CDBF      		out __SP_L__,r28
 5393               	.LVL504:
 5394 18c4 DF91      		pop r29
 5395 18c6 CF91      		pop r28
 5396 18c8 1F91      		pop r17
 5397               	.LVL505:
 5398 18ca 0895      		ret
 5399               		.cfi_endproc
 5400               	.LFE36:
 5402               	.global	f_open
 5404               	f_open:
 5405               	.LFB37:
3702:ff.c          **** 
3703:ff.c          **** 
3704:ff.c          **** 
3705:ff.c          **** 
3706:ff.c          **** /*-----------------------------------------------------------------------*/
3707:ff.c          **** /* Open or Create a File                                                 */
3708:ff.c          **** /*-----------------------------------------------------------------------*/
3709:ff.c          **** 
3710:ff.c          **** FRESULT f_open (
3711:ff.c          **** 	FIL* fp,			/* Pointer to the blank file object */
3712:ff.c          **** 	const TCHAR* path,	/* Pointer to the file name */
3713:ff.c          **** 	BYTE mode			/* Access mode and file open mode flags */
3714:ff.c          **** )
3715:ff.c          **** {
 5406               		.loc 1 3715 0
 5407               		.cfi_startproc
 5408               	.LVL506:
 5409 18cc 4F92      		push r4
 5410               	.LCFI183:
 5411               		.cfi_def_cfa_offset 3
 5412               		.cfi_offset 4, -2
 5413 18ce 5F92      		push r5
 5414               	.LCFI184:
 5415               		.cfi_def_cfa_offset 4
 5416               		.cfi_offset 5, -3
 5417 18d0 6F92      		push r6
 5418               	.LCFI185:
 5419               		.cfi_def_cfa_offset 5
 5420               		.cfi_offset 6, -4
 5421 18d2 7F92      		push r7
 5422               	.LCFI186:
 5423               		.cfi_def_cfa_offset 6
 5424               		.cfi_offset 7, -5
 5425 18d4 8F92      		push r8
 5426               	.LCFI187:
 5427               		.cfi_def_cfa_offset 7
 5428               		.cfi_offset 8, -6
 5429 18d6 9F92      		push r9
 5430               	.LCFI188:
 5431               		.cfi_def_cfa_offset 8
 5432               		.cfi_offset 9, -7
 5433 18d8 AF92      		push r10
 5434               	.LCFI189:
 5435               		.cfi_def_cfa_offset 9
 5436               		.cfi_offset 10, -8
 5437 18da BF92      		push r11
 5438               	.LCFI190:
 5439               		.cfi_def_cfa_offset 10
 5440               		.cfi_offset 11, -9
 5441 18dc CF92      		push r12
 5442               	.LCFI191:
 5443               		.cfi_def_cfa_offset 11
 5444               		.cfi_offset 12, -10
 5445 18de DF92      		push r13
 5446               	.LCFI192:
 5447               		.cfi_def_cfa_offset 12
 5448               		.cfi_offset 13, -11
 5449 18e0 EF92      		push r14
 5450               	.LCFI193:
 5451               		.cfi_def_cfa_offset 13
 5452               		.cfi_offset 14, -12
 5453 18e2 FF92      		push r15
 5454               	.LCFI194:
 5455               		.cfi_def_cfa_offset 14
 5456               		.cfi_offset 15, -13
 5457 18e4 0F93      		push r16
 5458               	.LCFI195:
 5459               		.cfi_def_cfa_offset 15
 5460               		.cfi_offset 16, -14
 5461 18e6 1F93      		push r17
 5462               	.LCFI196:
 5463               		.cfi_def_cfa_offset 16
 5464               		.cfi_offset 17, -15
 5465 18e8 CF93      		push r28
 5466               	.LCFI197:
 5467               		.cfi_def_cfa_offset 17
 5468               		.cfi_offset 28, -16
 5469 18ea DF93      		push r29
 5470               	.LCFI198:
 5471               		.cfi_def_cfa_offset 18
 5472               		.cfi_offset 29, -17
 5473 18ec CDB7      		in r28,__SP_L__
 5474 18ee DEB7      		in r29,__SP_H__
 5475               	.LCFI199:
 5476               		.cfi_def_cfa_register 28
 5477 18f0 E097      		sbiw r28,48
 5478               	.LCFI200:
 5479               		.cfi_def_cfa_offset 66
 5480 18f2 0FB6      		in __tmp_reg__,__SREG__
 5481 18f4 F894      		cli
 5482 18f6 DEBF      		out __SP_H__,r29
 5483 18f8 0FBE      		out __SREG__,__tmp_reg__
 5484 18fa CDBF      		out __SP_L__,r28
 5485               	/* prologue: function */
 5486               	/* frame size = 48 */
 5487               	/* stack size = 64 */
 5488               	.L__stack_usage = 64
 5489 18fc 7CA7      		std Y+44,r23
 5490 18fe 6BA7      		std Y+43,r22
3716:ff.c          **** 	FRESULT res;
3717:ff.c          **** 	DIR dj;
3718:ff.c          **** 	FATFS *fs;
3719:ff.c          **** #if !FF_FS_READONLY
3720:ff.c          **** 	DWORD cl, bcs, clst,  tm;
3721:ff.c          **** 	LBA_t sc;
3722:ff.c          **** 	FSIZE_t ofs;
3723:ff.c          **** #endif
3724:ff.c          **** 	DEF_NAMBUF
3725:ff.c          **** 
3726:ff.c          **** 
3727:ff.c          **** 	if (!fp) return FR_INVALID_OBJECT;
 5491               		.loc 1 3727 0
 5492 1900 0097      		sbiw r24,0
 5493 1902 01F4      		brne .+2
 5494 1904 00C0      		rjmp .L422
 5495 1906 142F      		mov r17,r20
 5496 1908 7C01      		movw r14,r24
3728:ff.c          **** 
3729:ff.c          **** 	/* Get logical drive number */
3730:ff.c          **** 	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN
 5497               		.loc 1 3730 0
 5498 190a 242F      		mov r18,r20
 5499 190c 2F73      		andi r18,lo8(63)
 5500 190e C22E      		mov r12,r18
 5501               	.LVL507:
3731:ff.c          **** 	res = mount_volume(&path, &fs, mode);
 5502               		.loc 1 3731 0
 5503 1910 422F      		mov r20,r18
 5504 1912 BE01      		movw r22,r28
 5505               	.LVL508:
 5506 1914 675D      		subi r22,-41
 5507 1916 7F4F      		sbci r23,-1
 5508 1918 CE01      		movw r24,r28
 5509               	.LVL509:
 5510 191a 8B96      		adiw r24,43
 5511 191c 0E94 0000 		call mount_volume
 5512               	.LVL510:
 5513 1920 D82E      		mov r13,r24
 5514               	.LVL511:
3732:ff.c          **** 	if (res == FR_OK) {
 5515               		.loc 1 3732 0
 5516 1922 8111      		cpse r24,__zero_reg__
 5517 1924 00C0      		rjmp .L401
3733:ff.c          **** 		dj.obj.fs = fs;
 5518               		.loc 1 3733 0
 5519 1926 89A5      		ldd r24,Y+41
 5520 1928 9AA5      		ldd r25,Y+42
 5521 192a 9A83      		std Y+2,r25
 5522 192c 8983      		std Y+1,r24
3734:ff.c          **** 		INIT_NAMBUF(fs);
3735:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 5523               		.loc 1 3735 0
 5524 192e 6BA5      		ldd r22,Y+43
 5525 1930 7CA5      		ldd r23,Y+44
 5526 1932 CE01      		movw r24,r28
 5527 1934 0196      		adiw r24,1
 5528 1936 0E94 0000 		call follow_path
 5529               	.LVL512:
3736:ff.c          **** #if !FF_FS_READONLY	/* Read/Write configuration */
3737:ff.c          **** 		if (res == FR_OK) {
 5530               		.loc 1 3737 0
 5531 193a 8111      		cpse r24,__zero_reg__
 5532 193c 00C0      		rjmp .L402
3738:ff.c          **** 			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 5533               		.loc 1 3738 0
 5534 193e 98A5      		ldd r25,Y+40
 5535 1940 97FD      		sbrc r25,7
3739:ff.c          **** 				res = FR_INVALID_NAME;
 5536               		.loc 1 3739 0
 5537 1942 86E0      		ldi r24,lo8(6)
 5538               	.LVL513:
 5539               	.L402:
3740:ff.c          **** 			}
3741:ff.c          **** #if FF_FS_LOCK != 0
3742:ff.c          **** 			else {
3743:ff.c          **** 				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
3744:ff.c          **** 			}
3745:ff.c          **** #endif
3746:ff.c          **** 		}
3747:ff.c          **** 		/* Create or Open a file */
3748:ff.c          **** 		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 5540               		.loc 1 3748 0
 5541 1944 912F      		mov r25,r17
 5542 1946 9C71      		andi r25,lo8(28)
 5543 1948 01F4      		brne .+2
 5544 194a 00C0      		rjmp .L403
3749:ff.c          **** 			if (res != FR_OK) {					/* No file, create new */
 5545               		.loc 1 3749 0
 5546 194c 8823      		tst r24
 5547 194e 01F0      		breq .L404
3750:ff.c          **** 				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 5548               		.loc 1 3750 0
 5549 1950 8430      		cpi r24,lo8(4)
 5550 1952 01F4      		brne .L405
3751:ff.c          **** #if FF_FS_LOCK != 0
3752:ff.c          **** 					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
3753:ff.c          **** #else
3754:ff.c          **** 					res = dir_register(&dj);
 5551               		.loc 1 3754 0
 5552 1954 CE01      		movw r24,r28
 5553               	.LVL514:
 5554 1956 0196      		adiw r24,1
 5555 1958 0E94 0000 		call dir_register
 5556               	.LVL515:
 5557               	.L405:
3755:ff.c          **** #endif
3756:ff.c          **** 				}
3757:ff.c          **** 				mode |= FA_CREATE_ALWAYS;		/* File is created */
 5558               		.loc 1 3757 0
 5559 195c 3C2D      		mov r19,r12
 5560 195e 3860      		ori r19,lo8(8)
 5561               	.LVL516:
 5562 1960 C32E      		mov r12,r19
3758:ff.c          **** 			}
3759:ff.c          **** 			else {								/* Any object with the same name is already existing */
3760:ff.c          **** 				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
3761:ff.c          **** 					res = FR_DENIED;
3762:ff.c          **** 				} else {
3763:ff.c          **** 					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
3764:ff.c          **** 				}
3765:ff.c          **** 			}
3766:ff.c          **** 			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 5563               		.loc 1 3766 0
 5564 1962 8823      		tst r24
 5565 1964 01F0      		breq .L406
 5566 1966 00C0      		rjmp .L413
 5567               	.LVL517:
 5568               	.L404:
3760:ff.c          **** 					res = FR_DENIED;
 5569               		.loc 1 3760 0
 5570 1968 8D81      		ldd r24,Y+5
 5571               	.LVL518:
 5572 196a 8171      		andi r24,lo8(17)
 5573 196c 01F0      		breq .+2
 5574 196e 00C0      		rjmp .L426
3763:ff.c          **** 				}
 5575               		.loc 1 3763 0
 5576 1970 12FD      		sbrc r17,2
 5577 1972 00C0      		rjmp .L424
 5578               	.L406:
 5579               		.loc 1 3766 0 discriminator 1
 5580 1974 C3FE      		sbrs r12,3
 5581 1976 00C0      		rjmp .L409
 5582               	.LVL519:
3767:ff.c          **** #if FF_FS_EXFAT
3768:ff.c          **** 				if (fs->fs_type == FS_EXFAT) {
3769:ff.c          **** 					/* Get current allocation info */
3770:ff.c          **** 					fp->obj.fs = fs;
3771:ff.c          **** 					init_alloc_info(fs, &fp->obj);
3772:ff.c          **** 					/* Set directory entry block initial state */
3773:ff.c          **** 					mem_set(fs->dirbuf + 2, 0, 30);		/* Clear 85 entry except for NumSec */
3774:ff.c          **** 					mem_set(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
3775:ff.c          **** 					fs->dirbuf[XDIR_Attr] = AM_ARC;
3776:ff.c          **** 					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
3777:ff.c          **** 					fs->dirbuf[XDIR_GenFlags] = 1;
3778:ff.c          **** 					res = store_xdir(&dj);
3779:ff.c          **** 					if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
3780:ff.c          **** 						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
3781:ff.c          **** 						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
3782:ff.c          **** 					}
3783:ff.c          **** 				} else
3784:ff.c          **** #endif
3785:ff.c          **** 				{
3786:ff.c          **** 					/* Set directory entry initial state */
3787:ff.c          **** 					tm = GET_FATTIME();					/* Set created time */
3788:ff.c          **** 					st_dword(dj.dir + DIR_CrtTime, tm);
 5583               		.loc 1 3788 0
 5584 1978 EB8D      		ldd r30,Y+27
 5585 197a FC8D      		ldd r31,Y+28
 5586               	.LVL520:
 5587               	.LBB294:
 5588               	.LBB295:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5589               		.loc 1 656 0
 5590 197c 1686      		std Z+14,__zero_reg__
 5591               	.LVL521:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5592               		.loc 1 657 0
 5593 197e 1786      		std Z+15,__zero_reg__
 5594               	.LVL522:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5595               		.loc 1 658 0
 5596 1980 92E3      		ldi r25,lo8(50)
 5597 1982 908B      		std Z+16,r25
 5598               	.LVL523:
 659:ff.c          **** }
 5599               		.loc 1 659 0
 5600 1984 80E5      		ldi r24,lo8(80)
 5601 1986 818B      		std Z+17,r24
 5602               	.LVL524:
 5603               	.LBE295:
 5604               	.LBE294:
3789:ff.c          **** 					st_dword(dj.dir + DIR_ModTime, tm);
 5605               		.loc 1 3789 0
 5606 1988 EB8D      		ldd r30,Y+27
 5607 198a FC8D      		ldd r31,Y+28
 5608               	.LVL525:
 5609               	.LBB296:
 5610               	.LBB297:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5611               		.loc 1 656 0
 5612 198c 168A      		std Z+22,__zero_reg__
 5613               	.LVL526:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5614               		.loc 1 657 0
 5615 198e 178A      		std Z+23,__zero_reg__
 5616               	.LVL527:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5617               		.loc 1 658 0
 5618 1990 908F      		std Z+24,r25
 5619               	.LVL528:
 659:ff.c          **** }
 5620               		.loc 1 659 0
 5621 1992 818F      		std Z+25,r24
 5622               	.LVL529:
 5623               	.LBE297:
 5624               	.LBE296:
3790:ff.c          **** 					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 5625               		.loc 1 3790 0
 5626 1994 AB8C      		ldd r10,Y+27
 5627 1996 BC8C      		ldd r11,Y+28
 5628 1998 09A5      		ldd r16,Y+41
 5629 199a 1AA5      		ldd r17,Y+42
 5630 199c B501      		movw r22,r10
 5631 199e D801      		movw r26,r16
 5632 19a0 8C91      		ld r24,X
 5633 19a2 0E94 0000 		call ld_clust.isra.3
 5634               	.LVL530:
 5635 19a6 2B01      		movw r4,r22
 5636 19a8 3C01      		movw r6,r24
 5637               	.LVL531:
3791:ff.c          **** 					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 5638               		.loc 1 3791 0
 5639 19aa 80E2      		ldi r24,lo8(32)
 5640 19ac F501      		movw r30,r10
 5641 19ae 8387      		std Z+11,r24
3792:ff.c          **** 					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 5642               		.loc 1 3792 0
 5643 19b0 EB8D      		ldd r30,Y+27
 5644 19b2 FC8D      		ldd r31,Y+28
 5645               	.LVL532:
 5646               	.LBB298:
 5647               	.LBB299:
 5648               	.LBB300:
 5649               	.LBB301:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 5650               		.loc 1 650 0
 5651 19b4 128E      		std Z+26,__zero_reg__
 5652               	.LVL533:
 651:ff.c          **** }
 5653               		.loc 1 651 0
 5654 19b6 138E      		std Z+27,__zero_reg__
 5655               	.LVL534:
 5656               	.LBE301:
 5657               	.LBE300:
1888:ff.c          **** 		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 5658               		.loc 1 1888 0
 5659 19b8 D801      		movw r26,r16
 5660 19ba 8C91      		ld r24,X
 5661 19bc 8330      		cpi r24,lo8(3)
 5662 19be 01F4      		brne .L410
 5663               	.LVL535:
 5664               	.LBB302:
 5665               	.LBB303:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 5666               		.loc 1 650 0
 5667 19c0 148A      		std Z+20,__zero_reg__
 5668               	.LVL536:
 651:ff.c          **** }
 5669               		.loc 1 651 0
 5670 19c2 158A      		std Z+21,__zero_reg__
 5671               	.LVL537:
 5672               	.L410:
 5673               	.LBE303:
 5674               	.LBE302:
 5675               	.LBE299:
 5676               	.LBE298:
3793:ff.c          **** 					st_dword(dj.dir + DIR_FileSize, 0);
 5677               		.loc 1 3793 0
 5678 19c4 EB8D      		ldd r30,Y+27
 5679 19c6 FC8D      		ldd r31,Y+28
 5680               	.LVL538:
 5681               	.LBB304:
 5682               	.LBB305:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5683               		.loc 1 656 0
 5684 19c8 148E      		std Z+28,__zero_reg__
 5685               	.LVL539:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 5686               		.loc 1 657 0
 5687 19ca 158E      		std Z+29,__zero_reg__
 5688               	.LVL540:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 5689               		.loc 1 658 0
 5690 19cc 168E      		std Z+30,__zero_reg__
 5691               	.LVL541:
 659:ff.c          **** }
 5692               		.loc 1 659 0
 5693 19ce 178E      		std Z+31,__zero_reg__
 5694               	.LVL542:
 5695               	.LBE305:
 5696               	.LBE304:
3794:ff.c          **** 					fs->wflag = 1;
 5697               		.loc 1 3794 0
 5698 19d0 81E0      		ldi r24,lo8(1)
 5699 19d2 F801      		movw r30,r16
 5700 19d4 8383      		std Z+3,r24
3795:ff.c          **** 					if (cl != 0) {						/* Remove the cluster chain if exist */
 5701               		.loc 1 3795 0
 5702 19d6 4114      		cp r4,__zero_reg__
 5703 19d8 5104      		cpc r5,__zero_reg__
 5704 19da 6104      		cpc r6,__zero_reg__
 5705 19dc 7104      		cpc r7,__zero_reg__
 5706 19de 01F0      		breq .L411
3796:ff.c          **** 						sc = fs->winsect;
 5707               		.loc 1 3796 0
 5708 19e0 83A4      		ldd r8,Z+43
 5709 19e2 94A4      		ldd r9,Z+44
 5710 19e4 A5A4      		ldd r10,Z+45
 5711 19e6 B6A4      		ldd r11,Z+46
 5712               	.LVL543:
3797:ff.c          **** 						res = remove_chain(&dj.obj, cl, 0);
 5713               		.loc 1 3797 0
 5714 19e8 00E0      		ldi r16,0
 5715 19ea 10E0      		ldi r17,0
 5716 19ec 9801      		movw r18,r16
 5717               	.LVL544:
 5718 19ee B301      		movw r22,r6
 5719 19f0 A201      		movw r20,r4
 5720 19f2 CE01      		movw r24,r28
 5721 19f4 0196      		adiw r24,1
 5722 19f6 0E94 0000 		call remove_chain
 5723               	.LVL545:
3798:ff.c          **** 						if (res == FR_OK) {
 5724               		.loc 1 3798 0
 5725 19fa 8111      		cpse r24,__zero_reg__
 5726 19fc 00C0      		rjmp .L413
3799:ff.c          **** 							res = move_window(fs, sc);
 5727               		.loc 1 3799 0
 5728 19fe B501      		movw r22,r10
 5729 1a00 A401      		movw r20,r8
 5730 1a02 89A5      		ldd r24,Y+41
 5731 1a04 9AA5      		ldd r25,Y+42
 5732               	.LVL546:
 5733 1a06 0E94 0000 		call move_window
 5734               	.LVL547:
3800:ff.c          **** 							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 5735               		.loc 1 3800 0
 5736 1a0a E9A5      		ldd r30,Y+41
 5737 1a0c FAA5      		ldd r31,Y+42
 5738 1a0e 21E0      		ldi r18,1
 5739 1a10 421A      		sub r4,r18
 5740 1a12 5108      		sbc r5,__zero_reg__
 5741 1a14 6108      		sbc r6,__zero_reg__
 5742 1a16 7108      		sbc r7,__zero_reg__
 5743               	.LVL548:
 5744 1a18 4386      		std Z+11,r4
 5745 1a1a 5486      		std Z+12,r5
 5746 1a1c 6586      		std Z+13,r6
 5747 1a1e 7686      		std Z+14,r7
3801:ff.c          **** 						}
3802:ff.c          **** 					}
3803:ff.c          **** 				}
3804:ff.c          **** 			}
3805:ff.c          **** 		}
3806:ff.c          **** 		else {	/* Open an existing file */
3807:ff.c          **** 			if (res == FR_OK) {					/* Is the object exsiting? */
3808:ff.c          **** 				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
3809:ff.c          **** 					res = FR_NO_FILE;
3810:ff.c          **** 				} else {
3811:ff.c          **** 					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
3812:ff.c          **** 						res = FR_DENIED;
3813:ff.c          **** 					}
3814:ff.c          **** 				}
3815:ff.c          **** 			}
3816:ff.c          **** 		}
3817:ff.c          **** 		if (res == FR_OK) {
 5748               		.loc 1 3817 0
 5749 1a20 8823      		tst r24
 5750 1a22 01F0      		breq .L412
 5751 1a24 00C0      		rjmp .L413
 5752               	.LVL549:
 5753               	.L403:
3807:ff.c          **** 				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 5754               		.loc 1 3807 0
 5755 1a26 8111      		cpse r24,__zero_reg__
 5756 1a28 00C0      		rjmp .L413
3808:ff.c          **** 					res = FR_NO_FILE;
 5757               		.loc 1 3808 0
 5758 1a2a 8D81      		ldd r24,Y+5
 5759               	.LVL550:
 5760 1a2c 84FD      		sbrc r24,4
 5761 1a2e 00C0      		rjmp .L425
3811:ff.c          **** 						res = FR_DENIED;
 5762               		.loc 1 3811 0
 5763 1a30 11FF      		sbrs r17,1
 5764 1a32 00C0      		rjmp .L412
3811:ff.c          **** 						res = FR_DENIED;
 5765               		.loc 1 3811 0 is_stmt 0 discriminator 1
 5766 1a34 80FD      		sbrc r24,0
 5767 1a36 00C0      		rjmp .L426
 5768               	.L412:
3818:ff.c          **** 			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwrit
 5769               		.loc 1 3818 0 is_stmt 1
 5770 1a38 C3FE      		sbrs r12,3
 5771 1a3a 00C0      		rjmp .L409
 5772               	.L411:
 5773               	.LVL551:
 5774               		.loc 1 3818 0 is_stmt 0 discriminator 1
 5775 1a3c 3C2D      		mov r19,r12
 5776 1a3e 3064      		ori r19,lo8(64)
 5777               	.LVL552:
 5778 1a40 C32E      		mov r12,r19
 5779               	.LVL553:
 5780               	.L409:
3819:ff.c          **** 			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 5781               		.loc 1 3819 0 is_stmt 1
 5782 1a42 09A5      		ldd r16,Y+41
 5783 1a44 1AA5      		ldd r17,Y+42
 5784 1a46 F801      		movw r30,r16
 5785 1a48 83A5      		ldd r24,Z+43
 5786 1a4a 94A5      		ldd r25,Z+44
 5787 1a4c A5A5      		ldd r26,Z+45
 5788 1a4e B6A5      		ldd r27,Z+46
 5789 1a50 F701      		movw r30,r14
 5790 1a52 848F      		std Z+28,r24
 5791 1a54 958F      		std Z+29,r25
 5792 1a56 A68F      		std Z+30,r26
 5793 1a58 B78F      		std Z+31,r27
3820:ff.c          **** 			fp->dir_ptr = dj.dir;
 5794               		.loc 1 3820 0
 5795 1a5a AB8C      		ldd r10,Y+27
 5796 1a5c BC8C      		ldd r11,Y+28
 5797 1a5e B1A2      		std Z+33,r11
 5798 1a60 A0A2      		std Z+32,r10
3821:ff.c          **** #if FF_FS_LOCK != 0
3822:ff.c          **** 			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);	/* Lock the file for this session */
3823:ff.c          **** 			if (fp->obj.lockid == 0) res = FR_INT_ERR;
3824:ff.c          **** #endif
3825:ff.c          **** 		}
3826:ff.c          **** #else		/* R/O configuration */
3827:ff.c          **** 		if (res == FR_OK) {
3828:ff.c          **** 			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it origin directory itself? */
3829:ff.c          **** 				res = FR_INVALID_NAME;
3830:ff.c          **** 			} else {
3831:ff.c          **** 				if (dj.obj.attr & AM_DIR) {		/* Is it a directory? */
3832:ff.c          **** 					res = FR_NO_FILE;
3833:ff.c          **** 				}
3834:ff.c          **** 			}
3835:ff.c          **** 		}
3836:ff.c          **** #endif
3837:ff.c          **** 
3838:ff.c          **** 		if (res == FR_OK) {
3839:ff.c          **** #if FF_FS_EXFAT
3840:ff.c          **** 			if (fs->fs_type == FS_EXFAT) {
3841:ff.c          **** 				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
3842:ff.c          **** 				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
3843:ff.c          **** 				fp->obj.c_ofs = dj.blk_ofs;
3844:ff.c          **** 				init_alloc_info(fs, &fp->obj);
3845:ff.c          **** 			} else
3846:ff.c          **** #endif
3847:ff.c          **** 			{
3848:ff.c          **** 				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 5799               		.loc 1 3848 0
 5800 1a62 B501      		movw r22,r10
 5801 1a64 D801      		movw r26,r16
 5802 1a66 8C91      		ld r24,X
 5803 1a68 0E94 0000 		call ld_clust.isra.3
 5804               	.LVL554:
 5805 1a6c 2B01      		movw r4,r22
 5806 1a6e 3C01      		movw r6,r24
 5807 1a70 F701      		movw r30,r14
 5808 1a72 6683      		std Z+6,r22
 5809 1a74 7783      		std Z+7,r23
 5810 1a76 8087      		std Z+8,r24
 5811 1a78 9187      		std Z+9,r25
3849:ff.c          **** 				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 5812               		.loc 1 3849 0
 5813 1a7a C501      		movw r24,r10
 5814 1a7c 4C96      		adiw r24,28
 5815 1a7e 0E94 0000 		call ld_dword
 5816               	.LVL555:
 5817 1a82 4B01      		movw r8,r22
 5818 1a84 5C01      		movw r10,r24
 5819 1a86 D701      		movw r26,r14
 5820 1a88 1A96      		adiw r26,10
 5821 1a8a 6D93      		st X+,r22
 5822 1a8c 7D93      		st X+,r23
 5823 1a8e 8D93      		st X+,r24
 5824 1a90 9C93      		st X,r25
 5825 1a92 1D97      		sbiw r26,10+3
3850:ff.c          **** 			}
3851:ff.c          **** #if FF_USE_FASTSEEK
3852:ff.c          **** 			fp->cltbl = 0;			/* Disable fast seek mode */
3853:ff.c          **** #endif
3854:ff.c          **** 			fp->obj.fs = fs;	 	/* Validate the file object */
 5826               		.loc 1 3854 0
 5827 1a94 1196      		adiw r26,1
 5828 1a96 1C93      		st X,r17
 5829 1a98 0E93      		st -X,r16
3855:ff.c          **** 			fp->obj.id = fs->id;
 5830               		.loc 1 3855 0
 5831 1a9a F801      		movw r30,r16
 5832 1a9c 8581      		ldd r24,Z+5
 5833 1a9e 9681      		ldd r25,Z+6
 5834 1aa0 1396      		adiw r26,2+1
 5835 1aa2 9C93      		st X,r25
 5836 1aa4 8E93      		st -X,r24
 5837 1aa6 1297      		sbiw r26,2
3856:ff.c          **** 			fp->flag = mode;		/* Set file access mode */
 5838               		.loc 1 3856 0
 5839 1aa8 1E96      		adiw r26,14
 5840 1aaa CC92      		st X,r12
 5841 1aac 1E97      		sbiw r26,14
3857:ff.c          **** 			fp->err = 0;			/* Clear error flag */
 5842               		.loc 1 3857 0
 5843 1aae 1F96      		adiw r26,15
 5844 1ab0 1C92      		st X,__zero_reg__
 5845 1ab2 1F97      		sbiw r26,15
3858:ff.c          **** 			fp->sect = 0;			/* Invalidate current data sector */
 5846               		.loc 1 3858 0
 5847 1ab4 5896      		adiw r26,24
 5848 1ab6 1D92      		st X+,__zero_reg__
 5849 1ab8 1D92      		st X+,__zero_reg__
 5850 1aba 1D92      		st X+,__zero_reg__
 5851 1abc 1C92      		st X,__zero_reg__
 5852 1abe 5B97      		sbiw r26,24+3
3859:ff.c          **** 			fp->fptr = 0;			/* Set file pointer top of the file */
 5853               		.loc 1 3859 0
 5854 1ac0 F701      		movw r30,r14
 5855 1ac2 108A      		std Z+16,__zero_reg__
 5856 1ac4 118A      		std Z+17,__zero_reg__
 5857 1ac6 128A      		std Z+18,__zero_reg__
 5858 1ac8 138A      		std Z+19,__zero_reg__
3860:ff.c          **** #if !FF_FS_READONLY
3861:ff.c          **** #if !FF_FS_TINY
3862:ff.c          **** 			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
3863:ff.c          **** #endif
3864:ff.c          **** 			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is sp
 5859               		.loc 1 3864 0
 5860 1aca C5FE      		sbrs r12,5
 5861 1acc 00C0      		rjmp .L420
 5862               		.loc 1 3864 0 is_stmt 0 discriminator 1
 5863 1ace 8114      		cp r8,__zero_reg__
 5864 1ad0 9104      		cpc r9,__zero_reg__
 5865 1ad2 A104      		cpc r10,__zero_reg__
 5866 1ad4 B104      		cpc r11,__zero_reg__
 5867 1ad6 01F4      		brne .+2
 5868 1ad8 00C0      		rjmp .L420
3865:ff.c          **** 				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 5869               		.loc 1 3865 0 is_stmt 1
 5870 1ada 5096      		adiw r26,16
 5871 1adc 8D92      		st X+,r8
 5872 1ade 9D92      		st X+,r9
 5873 1ae0 AD92      		st X+,r10
 5874 1ae2 BC92      		st X,r11
 5875 1ae4 5397      		sbiw r26,16+3
3866:ff.c          **** 				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 5876               		.loc 1 3866 0
 5877 1ae6 F801      		movw r30,r16
 5878 1ae8 8185      		ldd r24,Z+9
 5879 1aea 9285      		ldd r25,Z+10
 5880 1aec A0E0      		ldi r26,0
 5881 1aee B0E0      		ldi r27,0
 5882 1af0 9C01      		movw r18,r24
 5883 1af2 AD01      		movw r20,r26
 5884 1af4 69E0      		ldi r22,9
 5885               		1:
 5886 1af6 220F      		lsl r18
 5887 1af8 331F      		rol r19
 5888 1afa 441F      		rol r20
 5889 1afc 551F      		rol r21
 5890 1afe 6A95      		dec r22
 5891 1b00 01F4      		brne 1b
 5892 1b02 2DA7      		std Y+45,r18
 5893 1b04 3EA7      		std Y+46,r19
 5894 1b06 4FA7      		std Y+47,r20
 5895 1b08 58AB      		std Y+48,r21
 5896               	.LVL556:
 5897               	.L415:
3867:ff.c          **** 				clst = fp->obj.sclust;				/* Follow the cluster chain */
3868:ff.c          **** 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 5898               		.loc 1 3868 0 discriminator 3
 5899 1b0a 8DA5      		ldd r24,Y+45
 5900 1b0c 9EA5      		ldd r25,Y+46
 5901 1b0e AFA5      		ldd r26,Y+47
 5902 1b10 B8A9      		ldd r27,Y+48
 5903 1b12 8815      		cp r24,r8
 5904 1b14 9905      		cpc r25,r9
 5905 1b16 AA05      		cpc r26,r10
 5906 1b18 BB05      		cpc r27,r11
 5907 1b1a 00F4      		brsh .L418
3869:ff.c          **** 					clst = get_fat(&fp->obj, clst);
 5908               		.loc 1 3869 0
 5909 1b1c B301      		movw r22,r6
 5910 1b1e A201      		movw r20,r4
 5911 1b20 D701      		movw r26,r14
 5912 1b22 8D91      		ld r24,X+
 5913 1b24 9C91      		ld r25,X
 5914 1b26 0E94 0000 		call get_fat.isra.10
 5915               	.LVL557:
 5916 1b2a 2B01      		movw r4,r22
 5917 1b2c 3C01      		movw r6,r24
 5918               	.LVL558:
 5919 1b2e 2DA5      		ldd r18,Y+45
 5920 1b30 3EA5      		ldd r19,Y+46
 5921 1b32 4FA5      		ldd r20,Y+47
 5922 1b34 58A9      		ldd r21,Y+48
 5923 1b36 821A      		sub r8,r18
 5924 1b38 930A      		sbc r9,r19
 5925 1b3a A40A      		sbc r10,r20
 5926 1b3c B50A      		sbc r11,r21
 5927               	.LVL559:
3870:ff.c          **** 					if (clst <= 1) res = FR_INT_ERR;
 5928               		.loc 1 3870 0
 5929 1b3e 6230      		cpi r22,2
 5930 1b40 7105      		cpc r23,__zero_reg__
 5931 1b42 8105      		cpc r24,__zero_reg__
 5932 1b44 9105      		cpc r25,__zero_reg__
 5933 1b46 00F0      		brlo .L416
3871:ff.c          **** 					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 5934               		.loc 1 3871 0
 5935 1b48 6F3F      		cpi r22,-1
 5936 1b4a 7F4F      		sbci r23,-1
 5937 1b4c 8F4F      		sbci r24,-1
 5938 1b4e 9F4F      		sbci r25,-1
 5939 1b50 01F4      		brne .L415
 5940               	.LVL560:
 5941 1b52 DD24      		clr r13
 5942 1b54 D394      		inc r13
 5943               	.LVL561:
 5944 1b56 00C0      		rjmp .L418
 5945               	.LVL562:
 5946               	.L416:
3870:ff.c          **** 					if (clst <= 1) res = FR_INT_ERR;
 5947               		.loc 1 3870 0
 5948 1b58 82E0      		ldi r24,lo8(2)
 5949 1b5a D82E      		mov r13,r24
 5950               	.LVL563:
 5951               	.L418:
3872:ff.c          **** 				}
3873:ff.c          **** 				fp->clust = clst;
 5952               		.loc 1 3873 0
 5953 1b5c D701      		movw r26,r14
 5954 1b5e 5496      		adiw r26,20
 5955 1b60 4D92      		st X+,r4
 5956 1b62 5D92      		st X+,r5
 5957 1b64 6D92      		st X+,r6
 5958 1b66 7C92      		st X,r7
 5959 1b68 5797      		sbiw r26,20+3
3874:ff.c          **** 				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 5960               		.loc 1 3874 0
 5961 1b6a D110      		cpse r13,__zero_reg__
 5962 1b6c 00C0      		rjmp .L401
 5963               		.loc 1 3874 0 is_stmt 0 discriminator 1
 5964 1b6e D501      		movw r26,r10
 5965 1b70 C401      		movw r24,r8
 5966 1b72 9170      		andi r25,1
 5967 1b74 AA27      		clr r26
 5968 1b76 BB27      		clr r27
 5969 1b78 892B      		or r24,r25
 5970 1b7a 8A2B      		or r24,r26
 5971 1b7c 8B2B      		or r24,r27
 5972 1b7e 01F0      		breq .L420
3875:ff.c          **** 					sc = clst2sect(fs, clst);
 5973               		.loc 1 3875 0 is_stmt 1
 5974 1b80 B301      		movw r22,r6
 5975 1b82 A201      		movw r20,r4
 5976 1b84 89A5      		ldd r24,Y+41
 5977 1b86 9AA5      		ldd r25,Y+42
 5978 1b88 0E94 0000 		call clst2sect
 5979               	.LVL564:
3876:ff.c          **** 					if (sc == 0) {
 5980               		.loc 1 3876 0
 5981 1b8c 6115      		cp r22,__zero_reg__
 5982 1b8e 7105      		cpc r23,__zero_reg__
 5983 1b90 8105      		cpc r24,__zero_reg__
 5984 1b92 9105      		cpc r25,__zero_reg__
 5985 1b94 01F0      		breq .L427
3877:ff.c          **** 						res = FR_INT_ERR;
3878:ff.c          **** 					} else {
3879:ff.c          **** 						fp->sect = sc + (DWORD)(ofs / SS(fs));
 5986               		.loc 1 3879 0
 5987 1b96 29E0      		ldi r18,9
 5988               		1:
 5989 1b98 B694      		lsr r11
 5990 1b9a A794      		ror r10
 5991 1b9c 9794      		ror r9
 5992 1b9e 8794      		ror r8
 5993 1ba0 2A95      		dec r18
 5994 1ba2 01F4      		brne 1b
 5995 1ba4 DC01      		movw r26,r24
 5996 1ba6 CB01      		movw r24,r22
 5997 1ba8 880D      		add r24,r8
 5998 1baa 991D      		adc r25,r9
 5999 1bac AA1D      		adc r26,r10
 6000 1bae BB1D      		adc r27,r11
 6001 1bb0 F701      		movw r30,r14
 6002 1bb2 808F      		std Z+24,r24
 6003 1bb4 918F      		std Z+25,r25
 6004 1bb6 A28F      		std Z+26,r26
 6005 1bb8 B38F      		std Z+27,r27
 6006 1bba 00C0      		rjmp .L420
 6007               	.LVL565:
 6008               	.L422:
3727:ff.c          **** 
 6009               		.loc 1 3727 0
 6010 1bbc 89E0      		ldi r24,lo8(9)
 6011               	.LVL566:
 6012 1bbe 00C0      		rjmp .L455
 6013               	.LVL567:
 6014               	.L424:
3763:ff.c          **** 				}
 6015               		.loc 1 3763 0
 6016 1bc0 88E0      		ldi r24,lo8(8)
 6017               	.LVL568:
 6018 1bc2 00C0      		rjmp .L413
 6019               	.LVL569:
 6020               	.L425:
3809:ff.c          **** 				} else {
 6021               		.loc 1 3809 0
 6022 1bc4 84E0      		ldi r24,lo8(4)
 6023 1bc6 00C0      		rjmp .L413
 6024               	.L426:
3812:ff.c          **** 					}
 6025               		.loc 1 3812 0
 6026 1bc8 87E0      		ldi r24,lo8(7)
 6027               	.LVL570:
 6028               	.L413:
3877:ff.c          **** 					} else {
 6029               		.loc 1 3877 0
 6030 1bca D82E      		mov r13,r24
 6031 1bcc 00C0      		rjmp .L401
 6032               	.LVL571:
 6033               	.L420:
3880:ff.c          **** #if !FF_FS_TINY
3881:ff.c          **** 						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
3882:ff.c          **** #endif
3883:ff.c          **** 					}
3884:ff.c          **** 				}
3885:ff.c          **** 			}
3886:ff.c          **** #endif
3887:ff.c          **** 		}
3888:ff.c          **** 
3889:ff.c          **** 		FREE_NAMBUF();
3890:ff.c          **** 	}
3891:ff.c          **** 
3892:ff.c          **** 	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 6034               		.loc 1 3892 0
 6035 1bce 80E0      		ldi r24,0
 6036 1bd0 00C0      		rjmp .L455
 6037               	.LVL572:
 6038               	.L427:
3877:ff.c          **** 					} else {
 6039               		.loc 1 3877 0
 6040 1bd2 92E0      		ldi r25,lo8(2)
 6041 1bd4 D92E      		mov r13,r25
 6042               	.LVL573:
 6043               	.L401:
 6044               		.loc 1 3892 0
 6045 1bd6 D701      		movw r26,r14
 6046 1bd8 1D92      		st X+,__zero_reg__
 6047 1bda 1C92      		st X,__zero_reg__
 6048 1bdc 8D2D      		mov r24,r13
 6049               	.LVL574:
 6050               	.L455:
 6051               	/* epilogue start */
3893:ff.c          **** 
3894:ff.c          **** 	LEAVE_FF(fs, res);
3895:ff.c          **** }
 6052               		.loc 1 3895 0
 6053 1bde E096      		adiw r28,48
 6054 1be0 0FB6      		in __tmp_reg__,__SREG__
 6055 1be2 F894      		cli
 6056 1be4 DEBF      		out __SP_H__,r29
 6057 1be6 0FBE      		out __SREG__,__tmp_reg__
 6058 1be8 CDBF      		out __SP_L__,r28
 6059 1bea DF91      		pop r29
 6060 1bec CF91      		pop r28
 6061 1bee 1F91      		pop r17
 6062 1bf0 0F91      		pop r16
 6063 1bf2 FF90      		pop r15
 6064 1bf4 EF90      		pop r14
 6065 1bf6 DF90      		pop r13
 6066 1bf8 CF90      		pop r12
 6067 1bfa BF90      		pop r11
 6068 1bfc AF90      		pop r10
 6069 1bfe 9F90      		pop r9
 6070 1c00 8F90      		pop r8
 6071 1c02 7F90      		pop r7
 6072 1c04 6F90      		pop r6
 6073 1c06 5F90      		pop r5
 6074 1c08 4F90      		pop r4
 6075 1c0a 0895      		ret
 6076               		.cfi_endproc
 6077               	.LFE37:
 6079               	.global	f_read
 6081               	f_read:
 6082               	.LFB38:
3896:ff.c          **** 
3897:ff.c          **** 
3898:ff.c          **** 
3899:ff.c          **** 
3900:ff.c          **** /*-----------------------------------------------------------------------*/
3901:ff.c          **** /* Read File                                                             */
3902:ff.c          **** /*-----------------------------------------------------------------------*/
3903:ff.c          **** 
3904:ff.c          **** FRESULT f_read (
3905:ff.c          **** 	FIL* fp, 	/* Pointer to the file object */
3906:ff.c          **** 	void* buff,	/* Pointer to data buffer */
3907:ff.c          **** 	UINT btr,	/* Number of bytes to read */
3908:ff.c          **** 	UINT* br	/* Pointer to number of bytes read */
3909:ff.c          **** )
3910:ff.c          **** {
 6083               		.loc 1 3910 0
 6084               		.cfi_startproc
 6085               	.LVL575:
 6086 1c0c 2F92      		push r2
 6087               	.LCFI201:
 6088               		.cfi_def_cfa_offset 3
 6089               		.cfi_offset 2, -2
 6090 1c0e 3F92      		push r3
 6091               	.LCFI202:
 6092               		.cfi_def_cfa_offset 4
 6093               		.cfi_offset 3, -3
 6094 1c10 4F92      		push r4
 6095               	.LCFI203:
 6096               		.cfi_def_cfa_offset 5
 6097               		.cfi_offset 4, -4
 6098 1c12 5F92      		push r5
 6099               	.LCFI204:
 6100               		.cfi_def_cfa_offset 6
 6101               		.cfi_offset 5, -5
 6102 1c14 6F92      		push r6
 6103               	.LCFI205:
 6104               		.cfi_def_cfa_offset 7
 6105               		.cfi_offset 6, -6
 6106 1c16 7F92      		push r7
 6107               	.LCFI206:
 6108               		.cfi_def_cfa_offset 8
 6109               		.cfi_offset 7, -7
 6110 1c18 8F92      		push r8
 6111               	.LCFI207:
 6112               		.cfi_def_cfa_offset 9
 6113               		.cfi_offset 8, -8
 6114 1c1a 9F92      		push r9
 6115               	.LCFI208:
 6116               		.cfi_def_cfa_offset 10
 6117               		.cfi_offset 9, -9
 6118 1c1c AF92      		push r10
 6119               	.LCFI209:
 6120               		.cfi_def_cfa_offset 11
 6121               		.cfi_offset 10, -10
 6122 1c1e BF92      		push r11
 6123               	.LCFI210:
 6124               		.cfi_def_cfa_offset 12
 6125               		.cfi_offset 11, -11
 6126 1c20 CF92      		push r12
 6127               	.LCFI211:
 6128               		.cfi_def_cfa_offset 13
 6129               		.cfi_offset 12, -12
 6130 1c22 DF92      		push r13
 6131               	.LCFI212:
 6132               		.cfi_def_cfa_offset 14
 6133               		.cfi_offset 13, -13
 6134 1c24 EF92      		push r14
 6135               	.LCFI213:
 6136               		.cfi_def_cfa_offset 15
 6137               		.cfi_offset 14, -14
 6138 1c26 FF92      		push r15
 6139               	.LCFI214:
 6140               		.cfi_def_cfa_offset 16
 6141               		.cfi_offset 15, -15
 6142 1c28 0F93      		push r16
 6143               	.LCFI215:
 6144               		.cfi_def_cfa_offset 17
 6145               		.cfi_offset 16, -16
 6146 1c2a 1F93      		push r17
 6147               	.LCFI216:
 6148               		.cfi_def_cfa_offset 18
 6149               		.cfi_offset 17, -17
 6150 1c2c CF93      		push r28
 6151               	.LCFI217:
 6152               		.cfi_def_cfa_offset 19
 6153               		.cfi_offset 28, -18
 6154 1c2e DF93      		push r29
 6155               	.LCFI218:
 6156               		.cfi_def_cfa_offset 20
 6157               		.cfi_offset 29, -19
 6158 1c30 00D0      		rcall .
 6159 1c32 00D0      		rcall .
 6160               	.LCFI219:
 6161               		.cfi_def_cfa_offset 24
 6162 1c34 CDB7      		in r28,__SP_L__
 6163 1c36 DEB7      		in r29,__SP_H__
 6164               	.LCFI220:
 6165               		.cfi_def_cfa_register 28
 6166               	/* prologue: function */
 6167               	/* frame size = 4 */
 6168               	/* stack size = 22 */
 6169               	.L__stack_usage = 22
 6170 1c38 7C01      		movw r14,r24
 6171 1c3a 4B01      		movw r8,r22
 6172 1c3c 5A01      		movw r10,r20
 6173 1c3e 3C83      		std Y+4,r19
 6174 1c40 2B83      		std Y+3,r18
 6175               	.LVL576:
3911:ff.c          **** 	FRESULT res;
3912:ff.c          **** 	FATFS *fs;
3913:ff.c          **** 	DWORD clst;
3914:ff.c          **** 	LBA_t sect;
3915:ff.c          **** 	FSIZE_t remain;
3916:ff.c          **** 	UINT rcnt, cc, csect;
3917:ff.c          **** 	BYTE *rbuff = (BYTE*)buff;
3918:ff.c          **** 
3919:ff.c          **** 
3920:ff.c          **** 	*br = 0;	/* Clear read byte counter */
 6176               		.loc 1 3920 0
 6177 1c42 F901      		movw r30,r18
 6178 1c44 1182      		std Z+1,__zero_reg__
 6179 1c46 1082      		st Z,__zero_reg__
3921:ff.c          **** 	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 6180               		.loc 1 3921 0
 6181 1c48 BE01      		movw r22,r28
 6182               	.LVL577:
 6183 1c4a 6F5F      		subi r22,-1
 6184 1c4c 7F4F      		sbci r23,-1
 6185 1c4e 0E94 0000 		call validate
 6186               	.LVL578:
3922:ff.c          **** 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 6187               		.loc 1 3922 0
 6188 1c52 8111      		cpse r24,__zero_reg__
 6189 1c54 00C0      		rjmp .L457
 6190               		.loc 1 3922 0 is_stmt 0 discriminator 2
 6191 1c56 F701      		movw r30,r14
 6192 1c58 8785      		ldd r24,Z+15
 6193               	.LVL579:
 6194 1c5a 8111      		cpse r24,__zero_reg__
 6195 1c5c 00C0      		rjmp .L457
3923:ff.c          **** 	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 6196               		.loc 1 3923 0 is_stmt 1
 6197 1c5e 8685      		ldd r24,Z+14
 6198               	.LVL580:
 6199 1c60 80FF      		sbrs r24,0
 6200 1c62 00C0      		rjmp .L476
3924:ff.c          **** 	remain = fp->obj.objsize - fp->fptr;
 6201               		.loc 1 3924 0
 6202 1c64 8285      		ldd r24,Z+10
 6203 1c66 9385      		ldd r25,Z+11
 6204 1c68 A485      		ldd r26,Z+12
 6205 1c6a B585      		ldd r27,Z+13
 6206 1c6c 4089      		ldd r20,Z+16
 6207 1c6e 5189      		ldd r21,Z+17
 6208 1c70 6289      		ldd r22,Z+18
 6209 1c72 7389      		ldd r23,Z+19
 6210 1c74 841B      		sub r24,r20
 6211 1c76 950B      		sbc r25,r21
 6212 1c78 A60B      		sbc r26,r22
 6213 1c7a B70B      		sbc r27,r23
 6214               	.LVL581:
3925:ff.c          **** 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 6215               		.loc 1 3925 0
 6216 1c7c A501      		movw r20,r10
 6217 1c7e 60E0      		ldi r22,0
 6218 1c80 70E0      		ldi r23,0
 6219 1c82 8417      		cp r24,r20
 6220 1c84 9507      		cpc r25,r21
 6221 1c86 A607      		cpc r26,r22
 6222 1c88 B707      		cpc r27,r23
 6223 1c8a 00F0      		brlo .+2
 6224 1c8c 00C0      		rjmp .L459
 6225               		.loc 1 3925 0 is_stmt 0 discriminator 1
 6226 1c8e 5C01      		movw r10,r24
 6227               	.LVL582:
 6228 1c90 00C0      		rjmp .L459
 6229               	.LVL583:
 6230               	.L473:
3926:ff.c          **** 
3927:ff.c          **** 	for ( ;  btr;								/* Repeat until btr bytes read */
3928:ff.c          **** 		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
3929:ff.c          **** 		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 6231               		.loc 1 3929 0 is_stmt 1
 6232 1c92 F701      		movw r30,r14
 6233 1c94 8089      		ldd r24,Z+16
 6234 1c96 9189      		ldd r25,Z+17
 6235 1c98 A289      		ldd r26,Z+18
 6236 1c9a B389      		ldd r27,Z+19
 6237 1c9c AC01      		movw r20,r24
 6238 1c9e BD01      		movw r22,r26
 6239 1ca0 5170      		andi r21,1
 6240 1ca2 6627      		clr r22
 6241 1ca4 7727      		clr r23
 6242 1ca6 452B      		or r20,r21
 6243 1ca8 462B      		or r20,r22
 6244 1caa 472B      		or r20,r23
 6245 1cac 01F0      		breq .+2
 6246 1cae 00C0      		rjmp .L460
3930:ff.c          **** 			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 6247               		.loc 1 3930 0
 6248 1cb0 E981      		ldd r30,Y+1
 6249 1cb2 FA81      		ldd r31,Y+2
 6250 1cb4 0185      		ldd r16,Z+9
 6251 1cb6 1285      		ldd r17,Z+10
 6252 1cb8 0150      		subi r16,1
 6253 1cba 1109      		sbc r17,__zero_reg__
 6254 1cbc AC01      		movw r20,r24
 6255 1cbe BD01      		movw r22,r26
 6256 1cc0 E9E0      		ldi r30,9
 6257               		1:
 6258 1cc2 7695      		lsr r23
 6259 1cc4 6795      		ror r22
 6260 1cc6 5795      		ror r21
 6261 1cc8 4795      		ror r20
 6262 1cca EA95      		dec r30
 6263 1ccc 01F4      		brne 1b
 6264 1cce 0423      		and r16,r20
 6265 1cd0 1523      		and r17,r21
 6266               	.LVL584:
3931:ff.c          **** 			if (csect == 0) {					/* On the cluster boundary? */
 6267               		.loc 1 3931 0
 6268 1cd2 0115      		cp r16,__zero_reg__
 6269 1cd4 1105      		cpc r17,__zero_reg__
 6270 1cd6 01F4      		brne .+2
 6271 1cd8 00C0      		rjmp .L484
 6272               	.L461:
3932:ff.c          **** 				if (fp->fptr == 0) {			/* On the top of the file? */
3933:ff.c          **** 					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
3934:ff.c          **** 				} else {						/* Middle or end of the file */
3935:ff.c          **** #if FF_USE_FASTSEEK
3936:ff.c          **** 					if (fp->cltbl) {
3937:ff.c          **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
3938:ff.c          **** 					} else
3939:ff.c          **** #endif
3940:ff.c          **** 					{
3941:ff.c          **** 						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
3942:ff.c          **** 					}
3943:ff.c          **** 				}
3944:ff.c          **** 				if (clst < 2) ABORT(fs, FR_INT_ERR);
3945:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
3946:ff.c          **** 				fp->clust = clst;				/* Update current cluster */
3947:ff.c          **** 			}
3948:ff.c          **** 			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 6273               		.loc 1 3948 0
 6274 1cda 2980      		ldd r2,Y+1
 6275 1cdc 3A80      		ldd r3,Y+2
 6276 1cde F701      		movw r30,r14
 6277 1ce0 4489      		ldd r20,Z+20
 6278 1ce2 5589      		ldd r21,Z+21
 6279 1ce4 6689      		ldd r22,Z+22
 6280 1ce6 7789      		ldd r23,Z+23
 6281 1ce8 C101      		movw r24,r2
 6282 1cea 0E94 0000 		call clst2sect
 6283               	.LVL585:
3949:ff.c          **** 			if (sect == 0) ABORT(fs, FR_INT_ERR);
 6284               		.loc 1 3949 0
 6285 1cee 6115      		cp r22,__zero_reg__
 6286 1cf0 7105      		cpc r23,__zero_reg__
 6287 1cf2 8105      		cpc r24,__zero_reg__
 6288 1cf4 9105      		cpc r25,__zero_reg__
 6289 1cf6 01F4      		brne .+2
 6290 1cf8 00C0      		rjmp .L466
3950:ff.c          **** 			sect += csect;
 6291               		.loc 1 3950 0
 6292 1cfa 2B01      		movw r4,r22
 6293 1cfc 3C01      		movw r6,r24
 6294 1cfe 400E      		add r4,r16
 6295 1d00 511E      		adc r5,r17
 6296 1d02 611C      		adc r6,__zero_reg__
 6297 1d04 711C      		adc r7,__zero_reg__
 6298               	.LVL586:
3951:ff.c          **** 			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 6299               		.loc 1 3951 0
 6300 1d06 6501      		movw r12,r10
 6301 1d08 CD2C      		mov r12,r13
 6302 1d0a DD24      		clr r13
 6303 1d0c C694      		lsr r12
 6304               	.LVL587:
3952:ff.c          **** 			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 6305               		.loc 1 3952 0
 6306 1d0e C114      		cp r12,__zero_reg__
 6307 1d10 D104      		cpc r13,__zero_reg__
 6308 1d12 01F4      		brne .+2
 6309 1d14 00C0      		rjmp .L467
3953:ff.c          **** 				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 6310               		.loc 1 3953 0
 6311 1d16 F101      		movw r30,r2
 6312 1d18 8185      		ldd r24,Z+9
 6313 1d1a 9285      		ldd r25,Z+10
 6314 1d1c 9801      		movw r18,r16
 6315 1d1e 2C0D      		add r18,r12
 6316 1d20 3D1D      		adc r19,r13
 6317 1d22 8217      		cp r24,r18
 6318 1d24 9307      		cpc r25,r19
 6319 1d26 00F4      		brsh .L468
3954:ff.c          **** 					cc = fs->csize - csect;
 6320               		.loc 1 3954 0
 6321 1d28 6C01      		movw r12,r24
 6322               	.LVL588:
 6323 1d2a C01A      		sub r12,r16
 6324 1d2c D10A      		sbc r13,r17
 6325               	.LVL589:
 6326               	.L468:
3955:ff.c          **** 				}
3956:ff.c          **** 				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 6327               		.loc 1 3956 0
 6328 1d2e 8601      		movw r16,r12
 6329               	.LVL590:
 6330 1d30 A301      		movw r20,r6
 6331 1d32 9201      		movw r18,r4
 6332 1d34 B401      		movw r22,r8
 6333 1d36 F101      		movw r30,r2
 6334 1d38 8181      		ldd r24,Z+1
 6335 1d3a 0E94 0000 		call disk_read
 6336               	.LVL591:
 6337 1d3e 8111      		cpse r24,__zero_reg__
 6338 1d40 00C0      		rjmp .L469
3957:ff.c          **** #if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2		/* Replace one of the read sectors with cached data if 
3958:ff.c          **** #if FF_FS_TINY
3959:ff.c          **** 				if (fs->wflag && fs->winsect - sect < cc) {
 6339               		.loc 1 3959 0
 6340 1d42 E981      		ldd r30,Y+1
 6341 1d44 FA81      		ldd r31,Y+2
 6342 1d46 8381      		ldd r24,Z+3
 6343 1d48 8111      		cpse r24,__zero_reg__
 6344 1d4a 00C0      		rjmp .L485
 6345               	.L470:
3960:ff.c          **** 					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
3961:ff.c          **** 				}
3962:ff.c          **** #else
3963:ff.c          **** 				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
3964:ff.c          **** 					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
3965:ff.c          **** 				}
3966:ff.c          **** #endif
3967:ff.c          **** #endif
3968:ff.c          **** 				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 6346               		.loc 1 3968 0
 6347 1d4c DC2C      		mov r13,r12
 6348 1d4e CC24      		clr r12
 6349 1d50 DD0C      		lsl r13
 6350               	.LVL592:
 6351               	.L471:
3928:ff.c          **** 		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 6352               		.loc 1 3928 0
 6353 1d52 AC18      		sub r10,r12
 6354 1d54 BD08      		sbc r11,r13
 6355               	.LVL593:
 6356 1d56 EB81      		ldd r30,Y+3
 6357 1d58 FC81      		ldd r31,Y+4
 6358 1d5a 8081      		ld r24,Z
 6359 1d5c 9181      		ldd r25,Z+1
 6360 1d5e 8C0D      		add r24,r12
 6361 1d60 9D1D      		adc r25,r13
 6362 1d62 9183      		std Z+1,r25
 6363 1d64 8083      		st Z,r24
 6364 1d66 8C0C      		add r8,r12
 6365 1d68 9D1C      		adc r9,r13
 6366               	.LVL594:
 6367 1d6a F701      		movw r30,r14
 6368 1d6c 8089      		ldd r24,Z+16
 6369 1d6e 9189      		ldd r25,Z+17
 6370 1d70 A289      		ldd r26,Z+18
 6371 1d72 B389      		ldd r27,Z+19
 6372 1d74 8C0D      		add r24,r12
 6373 1d76 9D1D      		adc r25,r13
 6374 1d78 A11D      		adc r26,__zero_reg__
 6375 1d7a B11D      		adc r27,__zero_reg__
 6376 1d7c 808B      		std Z+16,r24
 6377 1d7e 918B      		std Z+17,r25
 6378 1d80 A28B      		std Z+18,r26
 6379 1d82 B38B      		std Z+19,r27
 6380               	.LVL595:
 6381               	.L459:
3927:ff.c          **** 		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 6382               		.loc 1 3927 0
 6383 1d84 A114      		cp r10,__zero_reg__
 6384 1d86 B104      		cpc r11,__zero_reg__
 6385 1d88 01F0      		breq .+2
 6386 1d8a 00C0      		rjmp .L473
 6387 1d8c 00C0      		rjmp .L486
 6388               	.LVL596:
 6389               	.L484:
3933:ff.c          **** 				} else {						/* Middle or end of the file */
 6390               		.loc 1 3933 0
 6391 1d8e F701      		movw r30,r14
3932:ff.c          **** 					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 6392               		.loc 1 3932 0
 6393 1d90 892B      		or r24,r25
 6394 1d92 8A2B      		or r24,r26
 6395 1d94 8B2B      		or r24,r27
 6396 1d96 01F4      		brne .L462
3933:ff.c          **** 				} else {						/* Middle or end of the file */
 6397               		.loc 1 3933 0
 6398 1d98 6681      		ldd r22,Z+6
 6399 1d9a 7781      		ldd r23,Z+7
 6400 1d9c 8085      		ldd r24,Z+8
 6401 1d9e 9185      		ldd r25,Z+9
 6402               	.LVL597:
 6403 1da0 00C0      		rjmp .L463
 6404               	.LVL598:
 6405               	.L462:
3941:ff.c          **** 					}
 6406               		.loc 1 3941 0
 6407 1da2 4489      		ldd r20,Z+20
 6408 1da4 5589      		ldd r21,Z+21
 6409 1da6 6689      		ldd r22,Z+22
 6410 1da8 7789      		ldd r23,Z+23
 6411 1daa 8081      		ld r24,Z
 6412 1dac 9181      		ldd r25,Z+1
 6413 1dae 0E94 0000 		call get_fat.isra.10
 6414               	.LVL599:
 6415               	.L463:
3944:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 6416               		.loc 1 3944 0
 6417 1db2 6230      		cpi r22,2
 6418 1db4 7105      		cpc r23,__zero_reg__
 6419 1db6 8105      		cpc r24,__zero_reg__
 6420 1db8 9105      		cpc r25,__zero_reg__
 6421 1dba 00F4      		brsh .L464
 6422               	.LVL600:
 6423               	.L466:
3944:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 6424               		.loc 1 3944 0 is_stmt 0 discriminator 1
 6425 1dbc 82E0      		ldi r24,lo8(2)
 6426 1dbe 00C0      		rjmp .L483
 6427               	.LVL601:
 6428               	.L464:
3945:ff.c          **** 				fp->clust = clst;				/* Update current cluster */
 6429               		.loc 1 3945 0 is_stmt 1
 6430 1dc0 6F3F      		cpi r22,-1
 6431 1dc2 FFEF      		ldi r31,-1
 6432 1dc4 7F07      		cpc r23,r31
 6433 1dc6 8F07      		cpc r24,r31
 6434 1dc8 9F07      		cpc r25,r31
 6435 1dca 01F4      		brne .L465
 6436               	.LVL602:
 6437               	.L469:
3945:ff.c          **** 				fp->clust = clst;				/* Update current cluster */
 6438               		.loc 1 3945 0 is_stmt 0 discriminator 1
 6439 1dcc 81E0      		ldi r24,lo8(1)
 6440               	.L483:
 6441 1dce F701      		movw r30,r14
 6442 1dd0 8787      		std Z+15,r24
 6443 1dd2 00C0      		rjmp .L457
 6444               	.LVL603:
 6445               	.L465:
3946:ff.c          **** 			}
 6446               		.loc 1 3946 0 is_stmt 1
 6447 1dd4 F701      		movw r30,r14
 6448 1dd6 648B      		std Z+20,r22
 6449 1dd8 758B      		std Z+21,r23
 6450 1dda 868B      		std Z+22,r24
 6451 1ddc 978B      		std Z+23,r25
 6452 1dde 00C0      		rjmp .L461
 6453               	.LVL604:
 6454               	.L485:
3959:ff.c          **** 					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
 6455               		.loc 1 3959 0 discriminator 1
 6456 1de0 83A5      		ldd r24,Z+43
 6457 1de2 94A5      		ldd r25,Z+44
 6458 1de4 A5A5      		ldd r26,Z+45
 6459 1de6 B6A5      		ldd r27,Z+46
 6460 1de8 8419      		sub r24,r4
 6461 1dea 9509      		sbc r25,r5
 6462 1dec A609      		sbc r26,r6
 6463 1dee B709      		sbc r27,r7
 6464 1df0 A601      		movw r20,r12
 6465 1df2 60E0      		ldi r22,0
 6466 1df4 70E0      		ldi r23,0
 6467 1df6 8417      		cp r24,r20
 6468 1df8 9507      		cpc r25,r21
 6469 1dfa A607      		cpc r26,r22
 6470 1dfc B707      		cpc r27,r23
 6471 1dfe 00F0      		brlo .+2
 6472 1e00 00C0      		rjmp .L470
 6473               	.LVL605:
3960:ff.c          **** 				}
 6474               		.loc 1 3960 0
 6475 1e02 BF01      		movw r22,r30
 6476 1e04 615D      		subi r22,-47
 6477 1e06 7F4F      		sbci r23,-1
 6478               	.LVL606:
 6479               	.LBB310:
 6480               	.LBB311:
 6481 1e08 982F      		mov r25,r24
 6482 1e0a 8827      		clr r24
 6483 1e0c 990F      		lsl r25
 6484               	.LVL607:
 6485 1e0e 40E0      		ldi r20,0
 6486 1e10 52E0      		ldi r21,lo8(2)
 6487 1e12 880D      		add r24,r8
 6488 1e14 991D      		adc r25,r9
 6489 1e16 0E94 0000 		call mem_cpy.part.0
 6490               	.LVL608:
 6491 1e1a 00C0      		rjmp .L470
 6492               	.LVL609:
 6493               	.L467:
 6494               	.LBE311:
 6495               	.LBE310:
3969:ff.c          **** 				continue;
3970:ff.c          **** 			}
3971:ff.c          **** #if !FF_FS_TINY
3972:ff.c          **** 			if (fp->sect != sect) {			/* Load data sector if not in cache */
3973:ff.c          **** #if !FF_FS_READONLY
3974:ff.c          **** 				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
3975:ff.c          **** 					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
3976:ff.c          **** 					fp->flag &= (BYTE)~FA_DIRTY;
3977:ff.c          **** 				}
3978:ff.c          **** #endif
3979:ff.c          **** 				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cac
3980:ff.c          **** 			}
3981:ff.c          **** #endif
3982:ff.c          **** 			fp->sect = sect;
 6496               		.loc 1 3982 0
 6497 1e1c F701      		movw r30,r14
 6498 1e1e 408E      		std Z+24,r4
 6499 1e20 518E      		std Z+25,r5
 6500 1e22 628E      		std Z+26,r6
 6501 1e24 738E      		std Z+27,r7
 6502               	.LVL610:
 6503               	.L460:
3983:ff.c          **** 		}
3984:ff.c          **** 		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 6504               		.loc 1 3984 0
 6505 1e26 F701      		movw r30,r14
 6506 1e28 8089      		ldd r24,Z+16
 6507 1e2a 9189      		ldd r25,Z+17
 6508 1e2c 9170      		andi r25,1
 6509 1e2e 20E0      		ldi r18,0
 6510 1e30 32E0      		ldi r19,lo8(2)
 6511 1e32 281B      		sub r18,r24
 6512 1e34 390B      		sbc r19,r25
 6513               	.LVL611:
 6514 1e36 6501      		movw r12,r10
 6515 1e38 2A15      		cp r18,r10
 6516 1e3a 3B05      		cpc r19,r11
 6517 1e3c 00F4      		brsh .L472
 6518 1e3e 6901      		movw r12,r18
 6519               	.L472:
 6520               	.LVL612:
3985:ff.c          **** 		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
3986:ff.c          **** #if FF_FS_TINY
3987:ff.c          **** 		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 6521               		.loc 1 3987 0
 6522 1e40 F701      		movw r30,r14
 6523 1e42 408D      		ldd r20,Z+24
 6524 1e44 518D      		ldd r21,Z+25
 6525 1e46 628D      		ldd r22,Z+26
 6526 1e48 738D      		ldd r23,Z+27
 6527 1e4a 8981      		ldd r24,Y+1
 6528 1e4c 9A81      		ldd r25,Y+2
 6529 1e4e 0E94 0000 		call move_window
 6530               	.LVL613:
 6531 1e52 8111      		cpse r24,__zero_reg__
 6532 1e54 00C0      		rjmp .L469
 6533               	.LVL614:
3988:ff.c          **** 		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 6534               		.loc 1 3988 0
 6535 1e56 6981      		ldd r22,Y+1
 6536 1e58 7A81      		ldd r23,Y+2
 6537 1e5a 615D      		subi r22,-47
 6538 1e5c 7F4F      		sbci r23,-1
 6539               	.LBB312:
 6540               	.LBB313:
 6541 1e5e F701      		movw r30,r14
 6542 1e60 8089      		ldd r24,Z+16
 6543 1e62 9189      		ldd r25,Z+17
 6544 1e64 9170      		andi r25,1
 6545 1e66 680F      		add r22,r24
 6546 1e68 791F      		adc r23,r25
 6547 1e6a A601      		movw r20,r12
 6548 1e6c C401      		movw r24,r8
 6549 1e6e 0E94 0000 		call mem_cpy.part.0
 6550               	.LVL615:
 6551 1e72 00C0      		rjmp .L471
 6552               	.LVL616:
 6553               	.L486:
 6554               	.LBE313:
 6555               	.LBE312:
3989:ff.c          **** #else
3990:ff.c          **** 		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
3991:ff.c          **** #endif
3992:ff.c          **** 	}
3993:ff.c          **** 
3994:ff.c          **** 	LEAVE_FF(fs, FR_OK);
 6556               		.loc 1 3994 0
 6557 1e74 80E0      		ldi r24,0
 6558 1e76 00C0      		rjmp .L457
 6559               	.LVL617:
 6560               	.L476:
3923:ff.c          **** 	remain = fp->obj.objsize - fp->fptr;
 6561               		.loc 1 3923 0
 6562 1e78 87E0      		ldi r24,lo8(7)
 6563               	.LVL618:
 6564               	.L457:
 6565               	/* epilogue start */
3995:ff.c          **** }
 6566               		.loc 1 3995 0
 6567 1e7a 0F90      		pop __tmp_reg__
 6568 1e7c 0F90      		pop __tmp_reg__
 6569 1e7e 0F90      		pop __tmp_reg__
 6570 1e80 0F90      		pop __tmp_reg__
 6571 1e82 DF91      		pop r29
 6572 1e84 CF91      		pop r28
 6573               	.LVL619:
 6574 1e86 1F91      		pop r17
 6575               	.LVL620:
 6576 1e88 0F91      		pop r16
 6577               	.LVL621:
 6578 1e8a FF90      		pop r15
 6579               	.LVL622:
 6580 1e8c EF90      		pop r14
 6581               	.LVL623:
 6582 1e8e DF90      		pop r13
 6583               	.LVL624:
 6584 1e90 CF90      		pop r12
 6585               	.LVL625:
 6586 1e92 BF90      		pop r11
 6587               	.LVL626:
 6588 1e94 AF90      		pop r10
 6589               	.LVL627:
 6590 1e96 9F90      		pop r9
 6591               	.LVL628:
 6592 1e98 8F90      		pop r8
 6593               	.LVL629:
 6594 1e9a 7F90      		pop r7
 6595               	.LVL630:
 6596 1e9c 6F90      		pop r6
 6597               	.LVL631:
 6598 1e9e 5F90      		pop r5
 6599               	.LVL632:
 6600 1ea0 4F90      		pop r4
 6601               	.LVL633:
 6602 1ea2 3F90      		pop r3
 6603               	.LVL634:
 6604 1ea4 2F90      		pop r2
 6605               	.LVL635:
 6606 1ea6 0895      		ret
 6607               		.cfi_endproc
 6608               	.LFE38:
 6610               	.global	f_write
 6612               	f_write:
 6613               	.LFB39:
3996:ff.c          **** 
3997:ff.c          **** 
3998:ff.c          **** 
3999:ff.c          **** 
4000:ff.c          **** #if !FF_FS_READONLY
4001:ff.c          **** /*-----------------------------------------------------------------------*/
4002:ff.c          **** /* Write File                                                            */
4003:ff.c          **** /*-----------------------------------------------------------------------*/
4004:ff.c          **** 
4005:ff.c          **** FRESULT f_write (
4006:ff.c          **** 	FIL* fp,			/* Pointer to the file object */
4007:ff.c          **** 	const void* buff,	/* Pointer to the data to be written */
4008:ff.c          **** 	UINT btw,			/* Number of bytes to write */
4009:ff.c          **** 	UINT* bw			/* Pointer to number of bytes written */
4010:ff.c          **** )
4011:ff.c          **** {
 6614               		.loc 1 4011 0
 6615               		.cfi_startproc
 6616               	.LVL636:
 6617 1ea8 2F92      		push r2
 6618               	.LCFI221:
 6619               		.cfi_def_cfa_offset 3
 6620               		.cfi_offset 2, -2
 6621 1eaa 3F92      		push r3
 6622               	.LCFI222:
 6623               		.cfi_def_cfa_offset 4
 6624               		.cfi_offset 3, -3
 6625 1eac 4F92      		push r4
 6626               	.LCFI223:
 6627               		.cfi_def_cfa_offset 5
 6628               		.cfi_offset 4, -4
 6629 1eae 5F92      		push r5
 6630               	.LCFI224:
 6631               		.cfi_def_cfa_offset 6
 6632               		.cfi_offset 5, -5
 6633 1eb0 6F92      		push r6
 6634               	.LCFI225:
 6635               		.cfi_def_cfa_offset 7
 6636               		.cfi_offset 6, -6
 6637 1eb2 7F92      		push r7
 6638               	.LCFI226:
 6639               		.cfi_def_cfa_offset 8
 6640               		.cfi_offset 7, -7
 6641 1eb4 8F92      		push r8
 6642               	.LCFI227:
 6643               		.cfi_def_cfa_offset 9
 6644               		.cfi_offset 8, -8
 6645 1eb6 9F92      		push r9
 6646               	.LCFI228:
 6647               		.cfi_def_cfa_offset 10
 6648               		.cfi_offset 9, -9
 6649 1eb8 AF92      		push r10
 6650               	.LCFI229:
 6651               		.cfi_def_cfa_offset 11
 6652               		.cfi_offset 10, -10
 6653 1eba BF92      		push r11
 6654               	.LCFI230:
 6655               		.cfi_def_cfa_offset 12
 6656               		.cfi_offset 11, -11
 6657 1ebc CF92      		push r12
 6658               	.LCFI231:
 6659               		.cfi_def_cfa_offset 13
 6660               		.cfi_offset 12, -12
 6661 1ebe DF92      		push r13
 6662               	.LCFI232:
 6663               		.cfi_def_cfa_offset 14
 6664               		.cfi_offset 13, -13
 6665 1ec0 EF92      		push r14
 6666               	.LCFI233:
 6667               		.cfi_def_cfa_offset 15
 6668               		.cfi_offset 14, -14
 6669 1ec2 FF92      		push r15
 6670               	.LCFI234:
 6671               		.cfi_def_cfa_offset 16
 6672               		.cfi_offset 15, -15
 6673 1ec4 0F93      		push r16
 6674               	.LCFI235:
 6675               		.cfi_def_cfa_offset 17
 6676               		.cfi_offset 16, -16
 6677 1ec6 1F93      		push r17
 6678               	.LCFI236:
 6679               		.cfi_def_cfa_offset 18
 6680               		.cfi_offset 17, -17
 6681 1ec8 CF93      		push r28
 6682               	.LCFI237:
 6683               		.cfi_def_cfa_offset 19
 6684               		.cfi_offset 28, -18
 6685 1eca DF93      		push r29
 6686               	.LCFI238:
 6687               		.cfi_def_cfa_offset 20
 6688               		.cfi_offset 29, -19
 6689 1ecc 00D0      		rcall .
 6690 1ece 00D0      		rcall .
 6691               	.LCFI239:
 6692               		.cfi_def_cfa_offset 24
 6693 1ed0 CDB7      		in r28,__SP_L__
 6694 1ed2 DEB7      		in r29,__SP_H__
 6695               	.LCFI240:
 6696               		.cfi_def_cfa_register 28
 6697               	/* prologue: function */
 6698               	/* frame size = 4 */
 6699               	/* stack size = 22 */
 6700               	.L__stack_usage = 22
 6701 1ed4 7C01      		movw r14,r24
 6702 1ed6 4B01      		movw r8,r22
 6703 1ed8 5A01      		movw r10,r20
 6704 1eda 3C83      		std Y+4,r19
 6705 1edc 2B83      		std Y+3,r18
 6706               	.LVL637:
4012:ff.c          **** 	FRESULT res;
4013:ff.c          **** 	FATFS *fs;
4014:ff.c          **** 	DWORD clst;
4015:ff.c          **** 	LBA_t sect;
4016:ff.c          **** 	UINT wcnt, cc, csect;
4017:ff.c          **** 	const BYTE *wbuff = (const BYTE*)buff;
4018:ff.c          **** 
4019:ff.c          **** 
4020:ff.c          **** 	*bw = 0;	/* Clear write byte counter */
 6707               		.loc 1 4020 0
 6708 1ede F901      		movw r30,r18
 6709 1ee0 1182      		std Z+1,__zero_reg__
 6710 1ee2 1082      		st Z,__zero_reg__
4021:ff.c          **** 	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 6711               		.loc 1 4021 0
 6712 1ee4 BE01      		movw r22,r28
 6713               	.LVL638:
 6714 1ee6 6F5F      		subi r22,-1
 6715 1ee8 7F4F      		sbci r23,-1
 6716 1eea 0E94 0000 		call validate
 6717               	.LVL639:
4022:ff.c          **** 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 6718               		.loc 1 4022 0
 6719 1eee 8111      		cpse r24,__zero_reg__
 6720 1ef0 00C0      		rjmp .L488
 6721               		.loc 1 4022 0 is_stmt 0 discriminator 2
 6722 1ef2 F701      		movw r30,r14
 6723 1ef4 8785      		ldd r24,Z+15
 6724               	.LVL640:
 6725 1ef6 8111      		cpse r24,__zero_reg__
 6726 1ef8 00C0      		rjmp .L488
4023:ff.c          **** 	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 6727               		.loc 1 4023 0 is_stmt 1
 6728 1efa 8685      		ldd r24,Z+14
 6729               	.LVL641:
 6730 1efc 81FF      		sbrs r24,1
 6731 1efe 00C0      		rjmp .L514
4024:ff.c          **** 
4025:ff.c          **** 	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
4026:ff.c          **** 	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 6732               		.loc 1 4026 0
 6733 1f00 8089      		ldd r24,Z+16
 6734 1f02 9189      		ldd r25,Z+17
 6735 1f04 A289      		ldd r26,Z+18
 6736 1f06 B389      		ldd r27,Z+19
 6737 1f08 AC01      		movw r20,r24
 6738 1f0a BD01      		movw r22,r26
 6739 1f0c 4A0D      		add r20,r10
 6740 1f0e 5B1D      		adc r21,r11
 6741 1f10 611D      		adc r22,__zero_reg__
 6742 1f12 711D      		adc r23,__zero_reg__
 6743 1f14 4817      		cp r20,r24
 6744 1f16 5907      		cpc r21,r25
 6745 1f18 6A07      		cpc r22,r26
 6746 1f1a 7B07      		cpc r23,r27
 6747 1f1c 00F0      		brlo .+2
 6748 1f1e 00C0      		rjmp .L490
4027:ff.c          **** 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 6749               		.loc 1 4027 0
 6750 1f20 5C01      		movw r10,r24
 6751               	.LVL642:
 6752 1f22 A094      		com r10
 6753 1f24 B094      		com r11
 6754               	.LVL643:
 6755 1f26 00C0      		rjmp .L490
 6756               	.LVL644:
 6757               	.L510:
4028:ff.c          **** 	}
4029:ff.c          **** 
4030:ff.c          **** 	for ( ;  btw;							/* Repeat until all data written */
4031:ff.c          **** 		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.
4032:ff.c          **** 		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 6758               		.loc 1 4032 0
 6759 1f28 F701      		movw r30,r14
 6760 1f2a 8089      		ldd r24,Z+16
 6761 1f2c 9189      		ldd r25,Z+17
 6762 1f2e A289      		ldd r26,Z+18
 6763 1f30 B389      		ldd r27,Z+19
 6764 1f32 AC01      		movw r20,r24
 6765 1f34 BD01      		movw r22,r26
 6766 1f36 5170      		andi r21,1
 6767 1f38 6627      		clr r22
 6768 1f3a 7727      		clr r23
 6769 1f3c 452B      		or r20,r21
 6770 1f3e 462B      		or r20,r22
 6771 1f40 472B      		or r20,r23
 6772 1f42 01F0      		breq .+2
 6773 1f44 00C0      		rjmp .L491
4033:ff.c          **** 			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 6774               		.loc 1 4033 0
 6775 1f46 E981      		ldd r30,Y+1
 6776 1f48 FA81      		ldd r31,Y+2
 6777 1f4a 0185      		ldd r16,Z+9
 6778 1f4c 1285      		ldd r17,Z+10
 6779 1f4e 0150      		subi r16,1
 6780 1f50 1109      		sbc r17,__zero_reg__
 6781 1f52 AC01      		movw r20,r24
 6782 1f54 BD01      		movw r22,r26
 6783 1f56 E9E0      		ldi r30,9
 6784               		1:
 6785 1f58 7695      		lsr r23
 6786 1f5a 6795      		ror r22
 6787 1f5c 5795      		ror r21
 6788 1f5e 4795      		ror r20
 6789 1f60 EA95      		dec r30
 6790 1f62 01F4      		brne 1b
 6791 1f64 0423      		and r16,r20
 6792 1f66 1523      		and r17,r21
 6793               	.LVL645:
4034:ff.c          **** 			if (csect == 0) {				/* On the cluster boundary? */
 6794               		.loc 1 4034 0
 6795 1f68 0115      		cp r16,__zero_reg__
 6796 1f6a 1105      		cpc r17,__zero_reg__
 6797 1f6c 01F4      		brne .+2
 6798 1f6e 00C0      		rjmp .L520
 6799               	.L493:
4035:ff.c          **** 				if (fp->fptr == 0) {		/* On the top of the file? */
4036:ff.c          **** 					clst = fp->obj.sclust;	/* Follow from the origin */
4037:ff.c          **** 					if (clst == 0) {		/* If no cluster is allocated, */
4038:ff.c          **** 						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
4039:ff.c          **** 					}
4040:ff.c          **** 				} else {					/* On the middle or end of the file */
4041:ff.c          **** #if FF_USE_FASTSEEK
4042:ff.c          **** 					if (fp->cltbl) {
4043:ff.c          **** 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
4044:ff.c          **** 					} else
4045:ff.c          **** #endif
4046:ff.c          **** 					{
4047:ff.c          **** 						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
4048:ff.c          **** 					}
4049:ff.c          **** 				}
4050:ff.c          **** 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
4051:ff.c          **** 				if (clst == 1) ABORT(fs, FR_INT_ERR);
4052:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
4053:ff.c          **** 				fp->clust = clst;			/* Update current cluster */
4054:ff.c          **** 				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
4055:ff.c          **** 			}
4056:ff.c          **** #if FF_FS_TINY
4057:ff.c          **** 			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back s
 6800               		.loc 1 4057 0
 6801 1f70 8981      		ldd r24,Y+1
 6802 1f72 9A81      		ldd r25,Y+2
 6803 1f74 FC01      		movw r30,r24
 6804 1f76 43A4      		ldd r4,Z+43
 6805 1f78 54A4      		ldd r5,Z+44
 6806 1f7a 65A4      		ldd r6,Z+45
 6807 1f7c 76A4      		ldd r7,Z+46
 6808 1f7e F701      		movw r30,r14
 6809 1f80 408D      		ldd r20,Z+24
 6810 1f82 518D      		ldd r21,Z+25
 6811 1f84 628D      		ldd r22,Z+26
 6812 1f86 738D      		ldd r23,Z+27
 6813 1f88 4416      		cp r4,r20
 6814 1f8a 5506      		cpc r5,r21
 6815 1f8c 6606      		cpc r6,r22
 6816 1f8e 7706      		cpc r7,r23
 6817 1f90 01F4      		brne .+2
 6818 1f92 00C0      		rjmp .L521
 6819               	.L500:
4058:ff.c          **** #else
4059:ff.c          **** 			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
4060:ff.c          **** 				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
4061:ff.c          **** 				fp->flag &= (BYTE)~FA_DIRTY;
4062:ff.c          **** 			}
4063:ff.c          **** #endif
4064:ff.c          **** 			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 6820               		.loc 1 4064 0
 6821 1f94 6980      		ldd r6,Y+1
 6822 1f96 7A80      		ldd r7,Y+2
 6823 1f98 F701      		movw r30,r14
 6824 1f9a 4489      		ldd r20,Z+20
 6825 1f9c 5589      		ldd r21,Z+21
 6826 1f9e 6689      		ldd r22,Z+22
 6827 1fa0 7789      		ldd r23,Z+23
 6828 1fa2 C301      		movw r24,r6
 6829 1fa4 0E94 0000 		call clst2sect
 6830               	.LVL646:
4065:ff.c          **** 			if (sect == 0) ABORT(fs, FR_INT_ERR);
 6831               		.loc 1 4065 0
 6832 1fa8 6115      		cp r22,__zero_reg__
 6833 1faa 7105      		cpc r23,__zero_reg__
 6834 1fac 8105      		cpc r24,__zero_reg__
 6835 1fae 9105      		cpc r25,__zero_reg__
 6836 1fb0 01F4      		brne .+2
 6837 1fb2 00C0      		rjmp .L502
4066:ff.c          **** 			sect += csect;
 6838               		.loc 1 4066 0
 6839 1fb4 1B01      		movw r2,r22
 6840 1fb6 2C01      		movw r4,r24
 6841 1fb8 200E      		add r2,r16
 6842 1fba 311E      		adc r3,r17
 6843 1fbc 411C      		adc r4,__zero_reg__
 6844 1fbe 511C      		adc r5,__zero_reg__
 6845               	.LVL647:
4067:ff.c          **** 			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 6846               		.loc 1 4067 0
 6847 1fc0 6501      		movw r12,r10
 6848 1fc2 CD2C      		mov r12,r13
 6849 1fc4 DD24      		clr r13
 6850 1fc6 C694      		lsr r12
 6851               	.LVL648:
4068:ff.c          **** 			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 6852               		.loc 1 4068 0
 6853 1fc8 C114      		cp r12,__zero_reg__
 6854 1fca D104      		cpc r13,__zero_reg__
 6855 1fcc 01F4      		brne .+2
 6856 1fce 00C0      		rjmp .L503
4069:ff.c          **** 				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 6857               		.loc 1 4069 0
 6858 1fd0 F301      		movw r30,r6
 6859 1fd2 8185      		ldd r24,Z+9
 6860 1fd4 9285      		ldd r25,Z+10
 6861 1fd6 9801      		movw r18,r16
 6862 1fd8 2C0D      		add r18,r12
 6863 1fda 3D1D      		adc r19,r13
 6864 1fdc 8217      		cp r24,r18
 6865 1fde 9307      		cpc r25,r19
 6866 1fe0 00F4      		brsh .L504
4070:ff.c          **** 					cc = fs->csize - csect;
 6867               		.loc 1 4070 0
 6868 1fe2 6C01      		movw r12,r24
 6869               	.LVL649:
 6870 1fe4 C01A      		sub r12,r16
 6871 1fe6 D10A      		sbc r13,r17
 6872               	.LVL650:
 6873               	.L504:
4071:ff.c          **** 				}
4072:ff.c          **** 				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 6874               		.loc 1 4072 0
 6875 1fe8 8601      		movw r16,r12
 6876               	.LVL651:
 6877 1fea A201      		movw r20,r4
 6878 1fec 9101      		movw r18,r2
 6879 1fee B401      		movw r22,r8
 6880 1ff0 F301      		movw r30,r6
 6881 1ff2 8181      		ldd r24,Z+1
 6882 1ff4 0E94 0000 		call disk_write
 6883               	.LVL652:
 6884 1ff8 8111      		cpse r24,__zero_reg__
 6885 1ffa 00C0      		rjmp .L501
4073:ff.c          **** #if FF_FS_MINIMIZE <= 2
4074:ff.c          **** #if FF_FS_TINY
4075:ff.c          **** 				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct writ
 6886               		.loc 1 4075 0
 6887 1ffc 8981      		ldd r24,Y+1
 6888 1ffe 9A81      		ldd r25,Y+2
 6889 2000 FC01      		movw r30,r24
 6890 2002 43A5      		ldd r20,Z+43
 6891 2004 54A5      		ldd r21,Z+44
 6892 2006 65A5      		ldd r22,Z+45
 6893 2008 76A5      		ldd r23,Z+46
 6894 200a 4219      		sub r20,r2
 6895 200c 5309      		sbc r21,r3
 6896 200e 6409      		sbc r22,r4
 6897 2010 7509      		sbc r23,r5
 6898 2012 8601      		movw r16,r12
 6899 2014 20E0      		ldi r18,0
 6900 2016 30E0      		ldi r19,0
 6901 2018 4017      		cp r20,r16
 6902 201a 5107      		cpc r21,r17
 6903 201c 6207      		cpc r22,r18
 6904 201e 7307      		cpc r23,r19
 6905 2020 00F4      		brsh .L505
 6906               	.LVL653:
 6907               	.LBB318:
 6908               	.LBB319:
 6909 2022 542F      		mov r21,r20
 6910 2024 4427      		clr r20
 6911 2026 550F      		lsl r21
 6912               	.LVL654:
 6913 2028 B401      		movw r22,r8
 6914 202a 640F      		add r22,r20
 6915 202c 751F      		adc r23,r21
 6916 202e 40E0      		ldi r20,0
 6917 2030 52E0      		ldi r21,lo8(2)
 6918 2032 8F96      		adiw r24,47
 6919               	.LVL655:
 6920 2034 0E94 0000 		call mem_cpy.part.0
 6921               	.LVL656:
 6922               	.LBE319:
 6923               	.LBE318:
4076:ff.c          **** 					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
4077:ff.c          **** 					fs->wflag = 0;
 6924               		.loc 1 4077 0
 6925 2038 E981      		ldd r30,Y+1
 6926 203a FA81      		ldd r31,Y+2
 6927 203c 1382      		std Z+3,__zero_reg__
 6928               	.L505:
4078:ff.c          **** 				}
4079:ff.c          **** #else
4080:ff.c          **** 				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write *
4081:ff.c          **** 					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
4082:ff.c          **** 					fp->flag &= (BYTE)~FA_DIRTY;
4083:ff.c          **** 				}
4084:ff.c          **** #endif
4085:ff.c          **** #endif
4086:ff.c          **** 				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 6929               		.loc 1 4086 0
 6930 203e DC2C      		mov r13,r12
 6931 2040 CC24      		clr r12
 6932 2042 DD0C      		lsl r13
 6933               	.LVL657:
 6934               	.L506:
4031:ff.c          **** 		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 6935               		.loc 1 4031 0
 6936 2044 AC18      		sub r10,r12
 6937 2046 BD08      		sbc r11,r13
 6938               	.LVL658:
 6939 2048 EB81      		ldd r30,Y+3
 6940 204a FC81      		ldd r31,Y+4
 6941 204c 8081      		ld r24,Z
 6942 204e 9181      		ldd r25,Z+1
 6943 2050 8C0D      		add r24,r12
 6944 2052 9D1D      		adc r25,r13
 6945 2054 9183      		std Z+1,r25
 6946 2056 8083      		st Z,r24
 6947 2058 8C0C      		add r8,r12
 6948 205a 9D1C      		adc r9,r13
 6949               	.LVL659:
 6950 205c F701      		movw r30,r14
 6951 205e 8089      		ldd r24,Z+16
 6952 2060 9189      		ldd r25,Z+17
 6953 2062 A289      		ldd r26,Z+18
 6954 2064 B389      		ldd r27,Z+19
 6955 2066 8C0D      		add r24,r12
 6956 2068 9D1D      		adc r25,r13
 6957 206a A11D      		adc r26,__zero_reg__
 6958 206c B11D      		adc r27,__zero_reg__
 6959 206e 808B      		std Z+16,r24
 6960 2070 918B      		std Z+17,r25
 6961 2072 A28B      		std Z+18,r26
 6962 2074 B38B      		std Z+19,r27
 6963 2076 4285      		ldd r20,Z+10
 6964 2078 5385      		ldd r21,Z+11
 6965 207a 6485      		ldd r22,Z+12
 6966 207c 7585      		ldd r23,Z+13
 6967 207e 4817      		cp r20,r24
 6968 2080 5907      		cpc r21,r25
 6969 2082 6A07      		cpc r22,r26
 6970 2084 7B07      		cpc r23,r27
 6971 2086 00F4      		brsh .L509
 6972 2088 AC01      		movw r20,r24
 6973 208a BD01      		movw r22,r26
 6974               	.L509:
 6975 208c F701      		movw r30,r14
 6976 208e 4287      		std Z+10,r20
 6977 2090 5387      		std Z+11,r21
 6978 2092 6487      		std Z+12,r22
 6979 2094 7587      		std Z+13,r23
 6980               	.LVL660:
 6981               	.L490:
4030:ff.c          **** 		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.
 6982               		.loc 1 4030 0
 6983 2096 A114      		cp r10,__zero_reg__
 6984 2098 B104      		cpc r11,__zero_reg__
 6985 209a 01F0      		breq .+2
 6986 209c 00C0      		rjmp .L510
 6987 209e 00C0      		rjmp .L511
 6988               	.LVL661:
 6989               	.L520:
4036:ff.c          **** 					if (clst == 0) {		/* If no cluster is allocated, */
 6990               		.loc 1 4036 0
 6991 20a0 F701      		movw r30,r14
4035:ff.c          **** 					clst = fp->obj.sclust;	/* Follow from the origin */
 6992               		.loc 1 4035 0
 6993 20a2 892B      		or r24,r25
 6994 20a4 8A2B      		or r24,r26
 6995 20a6 8B2B      		or r24,r27
 6996 20a8 01F4      		brne .L494
4036:ff.c          **** 					if (clst == 0) {		/* If no cluster is allocated, */
 6997               		.loc 1 4036 0
 6998 20aa 6681      		ldd r22,Z+6
 6999 20ac 7781      		ldd r23,Z+7
 7000 20ae 8085      		ldd r24,Z+8
 7001 20b0 9185      		ldd r25,Z+9
 7002               	.LVL662:
4037:ff.c          **** 						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 7003               		.loc 1 4037 0
 7004 20b2 6115      		cp r22,__zero_reg__
 7005 20b4 7105      		cpc r23,__zero_reg__
 7006 20b6 8105      		cpc r24,__zero_reg__
 7007 20b8 9105      		cpc r25,__zero_reg__
 7008 20ba 01F4      		brne .L495
4038:ff.c          **** 					}
 7009               		.loc 1 4038 0
 7010 20bc 40E0      		ldi r20,0
 7011 20be 50E0      		ldi r21,0
 7012 20c0 BA01      		movw r22,r20
 7013 20c2 00C0      		rjmp .L518
 7014               	.LVL663:
 7015               	.L494:
4047:ff.c          **** 					}
 7016               		.loc 1 4047 0
 7017 20c4 4489      		ldd r20,Z+20
 7018 20c6 5589      		ldd r21,Z+21
 7019 20c8 6689      		ldd r22,Z+22
 7020 20ca 7789      		ldd r23,Z+23
 7021               	.L518:
 7022 20cc C701      		movw r24,r14
 7023 20ce 0E94 0000 		call create_chain
 7024               	.LVL664:
4050:ff.c          **** 				if (clst == 1) ABORT(fs, FR_INT_ERR);
 7025               		.loc 1 4050 0
 7026 20d2 6115      		cp r22,__zero_reg__
 7027 20d4 7105      		cpc r23,__zero_reg__
 7028 20d6 8105      		cpc r24,__zero_reg__
 7029 20d8 9105      		cpc r25,__zero_reg__
 7030 20da 01F4      		brne .L495
 7031               	.LVL665:
 7032               	.L511:
4087:ff.c          **** 				continue;
4088:ff.c          **** 			}
4089:ff.c          **** #if FF_FS_TINY
4090:ff.c          **** 			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
4091:ff.c          **** 				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
4092:ff.c          **** 				fs->winsect = sect;
4093:ff.c          **** 			}
4094:ff.c          **** #else
4095:ff.c          **** 			if (fp->sect != sect && 		/* Fill sector cache with file data */
4096:ff.c          **** 				fp->fptr < fp->obj.objsize &&
4097:ff.c          **** 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
4098:ff.c          **** 					ABORT(fs, FR_DISK_ERR);
4099:ff.c          **** 			}
4100:ff.c          **** #endif
4101:ff.c          **** 			fp->sect = sect;
4102:ff.c          **** 		}
4103:ff.c          **** 		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
4104:ff.c          **** 		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
4105:ff.c          **** #if FF_FS_TINY
4106:ff.c          **** 		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
4107:ff.c          **** 		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
4108:ff.c          **** 		fs->wflag = 1;
4109:ff.c          **** #else
4110:ff.c          **** 		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
4111:ff.c          **** 		fp->flag |= FA_DIRTY;
4112:ff.c          **** #endif
4113:ff.c          **** 	}
4114:ff.c          **** 
4115:ff.c          **** 	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 7033               		.loc 1 4115 0
 7034 20dc F701      		movw r30,r14
 7035 20de 8685      		ldd r24,Z+14
 7036 20e0 8064      		ori r24,lo8(64)
 7037 20e2 8687      		std Z+14,r24
4116:ff.c          **** 
4117:ff.c          **** 	LEAVE_FF(fs, FR_OK);
 7038               		.loc 1 4117 0
 7039 20e4 80E0      		ldi r24,0
 7040 20e6 00C0      		rjmp .L488
 7041               	.LVL666:
 7042               	.L495:
4051:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 7043               		.loc 1 4051 0
 7044 20e8 6130      		cpi r22,1
 7045 20ea 7105      		cpc r23,__zero_reg__
 7046 20ec 8105      		cpc r24,__zero_reg__
 7047 20ee 9105      		cpc r25,__zero_reg__
 7048 20f0 01F4      		brne .L497
 7049               	.LVL667:
 7050               	.L502:
4051:ff.c          **** 				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 7051               		.loc 1 4051 0 is_stmt 0 discriminator 1
 7052 20f2 82E0      		ldi r24,lo8(2)
 7053 20f4 00C0      		rjmp .L519
 7054               	.LVL668:
 7055               	.L497:
4052:ff.c          **** 				fp->clust = clst;			/* Update current cluster */
 7056               		.loc 1 4052 0 is_stmt 1
 7057 20f6 6F3F      		cpi r22,-1
 7058 20f8 FFEF      		ldi r31,-1
 7059 20fa 7F07      		cpc r23,r31
 7060 20fc 8F07      		cpc r24,r31
 7061 20fe 9F07      		cpc r25,r31
 7062 2100 01F4      		brne .L498
 7063               	.LVL669:
 7064               	.L501:
4052:ff.c          **** 				fp->clust = clst;			/* Update current cluster */
 7065               		.loc 1 4052 0 is_stmt 0 discriminator 1
 7066 2102 81E0      		ldi r24,lo8(1)
 7067               	.L519:
 7068 2104 F701      		movw r30,r14
 7069 2106 8787      		std Z+15,r24
 7070 2108 00C0      		rjmp .L488
 7071               	.LVL670:
 7072               	.L498:
4053:ff.c          **** 				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 7073               		.loc 1 4053 0 is_stmt 1
 7074 210a F701      		movw r30,r14
 7075 210c 648B      		std Z+20,r22
 7076 210e 758B      		std Z+21,r23
 7077 2110 868B      		std Z+22,r24
 7078 2112 978B      		std Z+23,r25
4054:ff.c          **** 			}
 7079               		.loc 1 4054 0
 7080 2114 4680      		ldd r4,Z+6
 7081 2116 5780      		ldd r5,Z+7
 7082 2118 6084      		ldd r6,Z+8
 7083 211a 7184      		ldd r7,Z+9
 7084 211c 4528      		or r4,r5
 7085 211e 4628      		or r4,r6
 7086 2120 4728      		or r4,r7
 7087 2122 01F0      		breq .+2
 7088 2124 00C0      		rjmp .L493
4054:ff.c          **** 			}
 7089               		.loc 1 4054 0 is_stmt 0 discriminator 1
 7090 2126 6683      		std Z+6,r22
 7091 2128 7783      		std Z+7,r23
 7092 212a 8087      		std Z+8,r24
 7093 212c 9187      		std Z+9,r25
 7094 212e 00C0      		rjmp .L493
 7095               	.LVL671:
 7096               	.L521:
4057:ff.c          **** #else
 7097               		.loc 1 4057 0 is_stmt 1 discriminator 1
 7098 2130 0E94 0000 		call sync_window
 7099               	.LVL672:
 7100 2134 8823      		tst r24
 7101 2136 01F4      		brne .+2
 7102 2138 00C0      		rjmp .L500
 7103 213a 00C0      		rjmp .L501
 7104               	.LVL673:
 7105               	.L503:
4090:ff.c          **** 				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
 7106               		.loc 1 4090 0
 7107 213c F701      		movw r30,r14
 7108 213e 4089      		ldd r20,Z+16
 7109 2140 5189      		ldd r21,Z+17
 7110 2142 6289      		ldd r22,Z+18
 7111 2144 7389      		ldd r23,Z+19
 7112 2146 8285      		ldd r24,Z+10
 7113 2148 9385      		ldd r25,Z+11
 7114 214a A485      		ldd r26,Z+12
 7115 214c B585      		ldd r27,Z+13
 7116 214e 4817      		cp r20,r24
 7117 2150 5907      		cpc r21,r25
 7118 2152 6A07      		cpc r22,r26
 7119 2154 7B07      		cpc r23,r27
 7120 2156 00F0      		brlo .L507
4091:ff.c          **** 				fs->winsect = sect;
 7121               		.loc 1 4091 0
 7122 2158 C301      		movw r24,r6
 7123 215a 0E94 0000 		call sync_window
 7124               	.LVL674:
 7125 215e 8111      		cpse r24,__zero_reg__
 7126 2160 00C0      		rjmp .L501
4092:ff.c          **** 			}
 7127               		.loc 1 4092 0
 7128 2162 E981      		ldd r30,Y+1
 7129 2164 FA81      		ldd r31,Y+2
 7130 2166 23A6      		std Z+43,r2
 7131 2168 34A6      		std Z+44,r3
 7132 216a 45A6      		std Z+45,r4
 7133 216c 56A6      		std Z+46,r5
 7134               	.L507:
4101:ff.c          **** 		}
 7135               		.loc 1 4101 0
 7136 216e F701      		movw r30,r14
 7137 2170 208E      		std Z+24,r2
 7138 2172 318E      		std Z+25,r3
 7139 2174 428E      		std Z+26,r4
 7140 2176 538E      		std Z+27,r5
 7141               	.LVL675:
 7142               	.L491:
4103:ff.c          **** 		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 7143               		.loc 1 4103 0
 7144 2178 F701      		movw r30,r14
 7145 217a 8089      		ldd r24,Z+16
 7146 217c 9189      		ldd r25,Z+17
 7147 217e 9170      		andi r25,1
 7148 2180 20E0      		ldi r18,0
 7149 2182 32E0      		ldi r19,lo8(2)
 7150 2184 281B      		sub r18,r24
 7151 2186 390B      		sbc r19,r25
 7152               	.LVL676:
 7153 2188 6501      		movw r12,r10
 7154 218a 2A15      		cp r18,r10
 7155 218c 3B05      		cpc r19,r11
 7156 218e 00F4      		brsh .L508
 7157 2190 6901      		movw r12,r18
 7158               	.L508:
 7159               	.LVL677:
4106:ff.c          **** 		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 7160               		.loc 1 4106 0
 7161 2192 F701      		movw r30,r14
 7162 2194 408D      		ldd r20,Z+24
 7163 2196 518D      		ldd r21,Z+25
 7164 2198 628D      		ldd r22,Z+26
 7165 219a 738D      		ldd r23,Z+27
 7166 219c 8981      		ldd r24,Y+1
 7167 219e 9A81      		ldd r25,Y+2
 7168 21a0 0E94 0000 		call move_window
 7169               	.LVL678:
 7170 21a4 8111      		cpse r24,__zero_reg__
 7171 21a6 00C0      		rjmp .L501
 7172               	.LVL679:
4107:ff.c          **** 		fs->wflag = 1;
 7173               		.loc 1 4107 0
 7174 21a8 2981      		ldd r18,Y+1
 7175 21aa 3A81      		ldd r19,Y+2
 7176 21ac 215D      		subi r18,-47
 7177 21ae 3F4F      		sbci r19,-1
 7178               	.LBB320:
 7179               	.LBB321:
 7180 21b0 F701      		movw r30,r14
 7181 21b2 8089      		ldd r24,Z+16
 7182 21b4 9189      		ldd r25,Z+17
 7183 21b6 9170      		andi r25,1
 7184 21b8 A601      		movw r20,r12
 7185 21ba B401      		movw r22,r8
 7186 21bc 820F      		add r24,r18
 7187 21be 931F      		adc r25,r19
 7188 21c0 0E94 0000 		call mem_cpy.part.0
 7189               	.LVL680:
 7190               	.LBE321:
 7191               	.LBE320:
4108:ff.c          **** #else
 7192               		.loc 1 4108 0
 7193 21c4 E981      		ldd r30,Y+1
 7194 21c6 FA81      		ldd r31,Y+2
 7195 21c8 21E0      		ldi r18,lo8(1)
 7196 21ca 2383      		std Z+3,r18
 7197 21cc 00C0      		rjmp .L506
 7198               	.LVL681:
 7199               	.L514:
4023:ff.c          **** 
 7200               		.loc 1 4023 0
 7201 21ce 87E0      		ldi r24,lo8(7)
 7202               	.LVL682:
 7203               	.L488:
 7204               	/* epilogue start */
4118:ff.c          **** }
 7205               		.loc 1 4118 0
 7206 21d0 0F90      		pop __tmp_reg__
 7207 21d2 0F90      		pop __tmp_reg__
 7208 21d4 0F90      		pop __tmp_reg__
 7209 21d6 0F90      		pop __tmp_reg__
 7210 21d8 DF91      		pop r29
 7211 21da CF91      		pop r28
 7212               	.LVL683:
 7213 21dc 1F91      		pop r17
 7214               	.LVL684:
 7215 21de 0F91      		pop r16
 7216               	.LVL685:
 7217 21e0 FF90      		pop r15
 7218               	.LVL686:
 7219 21e2 EF90      		pop r14
 7220               	.LVL687:
 7221 21e4 DF90      		pop r13
 7222               	.LVL688:
 7223 21e6 CF90      		pop r12
 7224               	.LVL689:
 7225 21e8 BF90      		pop r11
 7226               	.LVL690:
 7227 21ea AF90      		pop r10
 7228               	.LVL691:
 7229 21ec 9F90      		pop r9
 7230               	.LVL692:
 7231 21ee 8F90      		pop r8
 7232               	.LVL693:
 7233 21f0 7F90      		pop r7
 7234               	.LVL694:
 7235 21f2 6F90      		pop r6
 7236               	.LVL695:
 7237 21f4 5F90      		pop r5
 7238               	.LVL696:
 7239 21f6 4F90      		pop r4
 7240               	.LVL697:
 7241 21f8 3F90      		pop r3
 7242               	.LVL698:
 7243 21fa 2F90      		pop r2
 7244               	.LVL699:
 7245 21fc 0895      		ret
 7246               		.cfi_endproc
 7247               	.LFE39:
 7249               	.global	f_sync
 7251               	f_sync:
 7252               	.LFB40:
4119:ff.c          **** 
4120:ff.c          **** 
4121:ff.c          **** 
4122:ff.c          **** 
4123:ff.c          **** /*-----------------------------------------------------------------------*/
4124:ff.c          **** /* Synchronize the File                                                  */
4125:ff.c          **** /*-----------------------------------------------------------------------*/
4126:ff.c          **** 
4127:ff.c          **** FRESULT f_sync (
4128:ff.c          **** 	FIL* fp		/* Pointer to the file object */
4129:ff.c          **** )
4130:ff.c          **** {
 7253               		.loc 1 4130 0
 7254               		.cfi_startproc
 7255               	.LVL700:
 7256 21fe EF92      		push r14
 7257               	.LCFI241:
 7258               		.cfi_def_cfa_offset 3
 7259               		.cfi_offset 14, -2
 7260 2200 FF92      		push r15
 7261               	.LCFI242:
 7262               		.cfi_def_cfa_offset 4
 7263               		.cfi_offset 15, -3
 7264 2202 0F93      		push r16
 7265               	.LCFI243:
 7266               		.cfi_def_cfa_offset 5
 7267               		.cfi_offset 16, -4
 7268 2204 1F93      		push r17
 7269               	.LCFI244:
 7270               		.cfi_def_cfa_offset 6
 7271               		.cfi_offset 17, -5
 7272 2206 CF93      		push r28
 7273               	.LCFI245:
 7274               		.cfi_def_cfa_offset 7
 7275               		.cfi_offset 28, -6
 7276 2208 DF93      		push r29
 7277               	.LCFI246:
 7278               		.cfi_def_cfa_offset 8
 7279               		.cfi_offset 29, -7
 7280 220a 00D0      		rcall .
 7281               	.LCFI247:
 7282               		.cfi_def_cfa_offset 10
 7283 220c CDB7      		in r28,__SP_L__
 7284 220e DEB7      		in r29,__SP_H__
 7285               	.LCFI248:
 7286               		.cfi_def_cfa_register 28
 7287               	/* prologue: function */
 7288               	/* frame size = 2 */
 7289               	/* stack size = 8 */
 7290               	.L__stack_usage = 8
 7291 2210 7C01      		movw r14,r24
4131:ff.c          **** 	FRESULT res;
4132:ff.c          **** 	FATFS *fs;
4133:ff.c          **** 	DWORD tm;
4134:ff.c          **** 	BYTE *dir;
4135:ff.c          **** 
4136:ff.c          **** 
4137:ff.c          **** 	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 7292               		.loc 1 4137 0
 7293 2212 BE01      		movw r22,r28
 7294 2214 6F5F      		subi r22,-1
 7295 2216 7F4F      		sbci r23,-1
 7296 2218 0E94 0000 		call validate
 7297               	.LVL701:
4138:ff.c          **** 	if (res == FR_OK) {
 7298               		.loc 1 4138 0
 7299 221c 8111      		cpse r24,__zero_reg__
 7300 221e 00C0      		rjmp .L523
4139:ff.c          **** 		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 7301               		.loc 1 4139 0
 7302 2220 F701      		movw r30,r14
 7303 2222 9685      		ldd r25,Z+14
 7304 2224 96FF      		sbrs r25,6
 7305 2226 00C0      		rjmp .L523
 7306               	.LVL702:
4140:ff.c          **** #if !FF_FS_TINY
4141:ff.c          **** 			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
4142:ff.c          **** 				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
4143:ff.c          **** 				fp->flag &= (BYTE)~FA_DIRTY;
4144:ff.c          **** 			}
4145:ff.c          **** #endif
4146:ff.c          **** 			/* Update the directory entry */
4147:ff.c          **** 			tm = GET_FATTIME();				/* Modified time */
4148:ff.c          **** #if FF_FS_EXFAT
4149:ff.c          **** 			if (fs->fs_type == FS_EXFAT) {
4150:ff.c          **** 				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
4151:ff.c          **** 				if (res == FR_OK) {
4152:ff.c          **** 					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if nee
4153:ff.c          **** 				}
4154:ff.c          **** 				if (res == FR_OK) {
4155:ff.c          **** 					DIR dj;
4156:ff.c          **** 					DEF_NAMBUF
4157:ff.c          **** 
4158:ff.c          **** 					INIT_NAMBUF(fs);
4159:ff.c          **** 					res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
4160:ff.c          **** 					if (res == FR_OK) {
4161:ff.c          **** 						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has be
4162:ff.c          **** 						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
4163:ff.c          **** 						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);		/* Update start cluster */
4164:ff.c          **** 						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
4165:ff.c          **** 						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid 
4166:ff.c          **** 						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
4167:ff.c          **** 						fs->dirbuf[XDIR_ModTime10] = 0;
4168:ff.c          **** 						st_dword(fs->dirbuf + XDIR_AccTime, 0);
4169:ff.c          **** 						res = store_xdir(&dj);	/* Restore it to the directory */
4170:ff.c          **** 						if (res == FR_OK) {
4171:ff.c          **** 							res = sync_fs(fs);
4172:ff.c          **** 							fp->flag &= (BYTE)~FA_MODIFIED;
4173:ff.c          **** 						}
4174:ff.c          **** 					}
4175:ff.c          **** 					FREE_NAMBUF();
4176:ff.c          **** 				}
4177:ff.c          **** 			} else
4178:ff.c          **** #endif
4179:ff.c          **** 			{
4180:ff.c          **** 				res = move_window(fs, fp->dir_sect);
 7307               		.loc 1 4180 0
 7308 2228 448D      		ldd r20,Z+28
 7309 222a 558D      		ldd r21,Z+29
 7310 222c 668D      		ldd r22,Z+30
 7311 222e 778D      		ldd r23,Z+31
 7312 2230 8981      		ldd r24,Y+1
 7313 2232 9A81      		ldd r25,Y+2
 7314               	.LVL703:
 7315 2234 0E94 0000 		call move_window
 7316               	.LVL704:
4181:ff.c          **** 				if (res == FR_OK) {
 7317               		.loc 1 4181 0
 7318 2238 8111      		cpse r24,__zero_reg__
 7319 223a 00C0      		rjmp .L523
4182:ff.c          **** 					dir = fp->dir_ptr;
 7320               		.loc 1 4182 0
 7321 223c F701      		movw r30,r14
 7322 223e 00A1      		ldd r16,Z+32
 7323 2240 11A1      		ldd r17,Z+33
 7324               	.LVL705:
4183:ff.c          **** 					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been chan
 7325               		.loc 1 4183 0
 7326 2242 F801      		movw r30,r16
 7327 2244 8385      		ldd r24,Z+11
 7328               	.LVL706:
 7329 2246 8062      		ori r24,lo8(32)
 7330 2248 8387      		std Z+11,r24
4184:ff.c          **** 					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 7331               		.loc 1 4184 0
 7332 224a F701      		movw r30,r14
 7333 224c 2681      		ldd r18,Z+6
 7334 224e 3781      		ldd r19,Z+7
 7335 2250 4085      		ldd r20,Z+8
 7336 2252 5185      		ldd r21,Z+9
 7337 2254 B801      		movw r22,r16
 7338 2256 8081      		ld r24,Z
 7339 2258 9181      		ldd r25,Z+1
 7340 225a 0E94 0000 		call st_clust.isra.4
 7341               	.LVL707:
4185:ff.c          **** 					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 7342               		.loc 1 4185 0
 7343 225e F701      		movw r30,r14
 7344 2260 3285      		ldd r19,Z+10
 7345 2262 2385      		ldd r18,Z+11
 7346 2264 9485      		ldd r25,Z+12
 7347 2266 8585      		ldd r24,Z+13
 7348               	.LVL708:
 7349               	.LBB328:
 7350               	.LBB329:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 7351               		.loc 1 656 0
 7352 2268 F801      		movw r30,r16
 7353 226a 348F      		std Z+28,r19
 7354               	.LVL709:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 7355               		.loc 1 657 0
 7356 226c 258F      		std Z+29,r18
 7357               	.LVL710:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 7358               		.loc 1 658 0
 7359 226e 968F      		std Z+30,r25
 7360               	.LVL711:
 659:ff.c          **** }
 7361               		.loc 1 659 0
 7362 2270 878F      		std Z+31,r24
 7363               	.LVL712:
 7364               	.LBE329:
 7365               	.LBE328:
 7366               	.LBB330:
 7367               	.LBB331:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 7368               		.loc 1 656 0
 7369 2272 168A      		std Z+22,__zero_reg__
 7370               	.LVL713:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 7371               		.loc 1 657 0
 7372 2274 178A      		std Z+23,__zero_reg__
 7373               	.LVL714:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 7374               		.loc 1 658 0
 7375 2276 82E3      		ldi r24,lo8(50)
 7376 2278 808F      		std Z+24,r24
 7377               	.LVL715:
 659:ff.c          **** }
 7378               		.loc 1 659 0
 7379 227a 80E5      		ldi r24,lo8(80)
 7380 227c 818F      		std Z+25,r24
 7381               	.LVL716:
 7382               	.LBE331:
 7383               	.LBE330:
 7384               	.LBB332:
 7385               	.LBB333:
 650:ff.c          **** 	*ptr++ = (BYTE)val;
 7386               		.loc 1 650 0
 7387 227e 128A      		std Z+18,__zero_reg__
 651:ff.c          **** }
 7388               		.loc 1 651 0
 7389 2280 138A      		std Z+19,__zero_reg__
 7390               	.LVL717:
 7391               	.LBE333:
 7392               	.LBE332:
4186:ff.c          **** 					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
4187:ff.c          **** 					st_word(dir + DIR_LstAccDate, 0);
4188:ff.c          **** 					fs->wflag = 1;
 7393               		.loc 1 4188 0
 7394 2282 8981      		ldd r24,Y+1
 7395 2284 9A81      		ldd r25,Y+2
 7396 2286 21E0      		ldi r18,lo8(1)
 7397 2288 FC01      		movw r30,r24
 7398 228a 2383      		std Z+3,r18
4189:ff.c          **** 					res = sync_fs(fs);					/* Restore it to the directory */
 7399               		.loc 1 4189 0
 7400 228c 0E94 0000 		call sync_fs
 7401               	.LVL718:
4190:ff.c          **** 					fp->flag &= (BYTE)~FA_MODIFIED;
 7402               		.loc 1 4190 0
 7403 2290 F701      		movw r30,r14
 7404 2292 9685      		ldd r25,Z+14
 7405 2294 9F7B      		andi r25,lo8(-65)
 7406 2296 9687      		std Z+14,r25
 7407               	.LVL719:
 7408               	.L523:
 7409               	/* epilogue start */
4191:ff.c          **** 				}
4192:ff.c          **** 			}
4193:ff.c          **** 		}
4194:ff.c          **** 	}
4195:ff.c          **** 
4196:ff.c          **** 	LEAVE_FF(fs, res);
4197:ff.c          **** }
 7410               		.loc 1 4197 0
 7411 2298 0F90      		pop __tmp_reg__
 7412 229a 0F90      		pop __tmp_reg__
 7413 229c DF91      		pop r29
 7414 229e CF91      		pop r28
 7415 22a0 1F91      		pop r17
 7416 22a2 0F91      		pop r16
 7417 22a4 FF90      		pop r15
 7418 22a6 EF90      		pop r14
 7419               	.LVL720:
 7420 22a8 0895      		ret
 7421               		.cfi_endproc
 7422               	.LFE40:
 7424               	.global	f_close
 7426               	f_close:
 7427               	.LFB41:
4198:ff.c          **** 
4199:ff.c          **** #endif /* !FF_FS_READONLY */
4200:ff.c          **** 
4201:ff.c          **** 
4202:ff.c          **** 
4203:ff.c          **** 
4204:ff.c          **** /*-----------------------------------------------------------------------*/
4205:ff.c          **** /* Close File                                                            */
4206:ff.c          **** /*-----------------------------------------------------------------------*/
4207:ff.c          **** 
4208:ff.c          **** FRESULT f_close (
4209:ff.c          **** 	FIL* fp		/* Pointer to the file object to be closed */
4210:ff.c          **** )
4211:ff.c          **** {
 7428               		.loc 1 4211 0
 7429               		.cfi_startproc
 7430               	.LVL721:
 7431 22aa 0F93      		push r16
 7432               	.LCFI249:
 7433               		.cfi_def_cfa_offset 3
 7434               		.cfi_offset 16, -2
 7435 22ac 1F93      		push r17
 7436               	.LCFI250:
 7437               		.cfi_def_cfa_offset 4
 7438               		.cfi_offset 17, -3
 7439 22ae CF93      		push r28
 7440               	.LCFI251:
 7441               		.cfi_def_cfa_offset 5
 7442               		.cfi_offset 28, -4
 7443 22b0 DF93      		push r29
 7444               	.LCFI252:
 7445               		.cfi_def_cfa_offset 6
 7446               		.cfi_offset 29, -5
 7447 22b2 00D0      		rcall .
 7448               	.LCFI253:
 7449               		.cfi_def_cfa_offset 8
 7450 22b4 CDB7      		in r28,__SP_L__
 7451 22b6 DEB7      		in r29,__SP_H__
 7452               	.LCFI254:
 7453               		.cfi_def_cfa_register 28
 7454               	/* prologue: function */
 7455               	/* frame size = 2 */
 7456               	/* stack size = 6 */
 7457               	.L__stack_usage = 6
 7458 22b8 8C01      		movw r16,r24
4212:ff.c          **** 	FRESULT res;
4213:ff.c          **** 	FATFS *fs;
4214:ff.c          **** 
4215:ff.c          **** #if !FF_FS_READONLY
4216:ff.c          **** 	res = f_sync(fp);					/* Flush cached data */
 7459               		.loc 1 4216 0
 7460 22ba 0E94 0000 		call f_sync
 7461               	.LVL722:
4217:ff.c          **** 	if (res == FR_OK)
 7462               		.loc 1 4217 0
 7463 22be 8111      		cpse r24,__zero_reg__
 7464 22c0 00C0      		rjmp .L528
4218:ff.c          **** #endif
4219:ff.c          **** 	{
4220:ff.c          **** 		res = validate(&fp->obj, &fs);	/* Lock volume */
 7465               		.loc 1 4220 0
 7466 22c2 BE01      		movw r22,r28
 7467 22c4 6F5F      		subi r22,-1
 7468 22c6 7F4F      		sbci r23,-1
 7469 22c8 C801      		movw r24,r16
 7470               	.LVL723:
 7471 22ca 0E94 0000 		call validate
 7472               	.LVL724:
4221:ff.c          **** 		if (res == FR_OK) {
 7473               		.loc 1 4221 0
 7474 22ce 8111      		cpse r24,__zero_reg__
 7475 22d0 00C0      		rjmp .L528
4222:ff.c          **** #if FF_FS_LOCK != 0
4223:ff.c          **** 			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
4224:ff.c          **** 			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
4225:ff.c          **** #else
4226:ff.c          **** 			fp->obj.fs = 0;	/* Invalidate file object */
 7476               		.loc 1 4226 0
 7477 22d2 F801      		movw r30,r16
 7478 22d4 1182      		std Z+1,__zero_reg__
 7479 22d6 1082      		st Z,__zero_reg__
 7480               	.L528:
 7481               	/* epilogue start */
4227:ff.c          **** #endif
4228:ff.c          **** #if FF_FS_REENTRANT
4229:ff.c          **** 			unlock_fs(fs, FR_OK);		/* Unlock volume */
4230:ff.c          **** #endif
4231:ff.c          **** 		}
4232:ff.c          **** 	}
4233:ff.c          **** 	return res;
4234:ff.c          **** }
 7482               		.loc 1 4234 0
 7483 22d8 0F90      		pop __tmp_reg__
 7484 22da 0F90      		pop __tmp_reg__
 7485 22dc DF91      		pop r29
 7486 22de CF91      		pop r28
 7487 22e0 1F91      		pop r17
 7488 22e2 0F91      		pop r16
 7489               	.LVL725:
 7490 22e4 0895      		ret
 7491               		.cfi_endproc
 7492               	.LFE41:
 7494               	.global	f_lseek
 7496               	f_lseek:
 7497               	.LFB42:
4235:ff.c          **** 
4236:ff.c          **** 
4237:ff.c          **** 
4238:ff.c          **** 
4239:ff.c          **** #if FF_FS_RPATH >= 1
4240:ff.c          **** /*-----------------------------------------------------------------------*/
4241:ff.c          **** /* Change Current Directory or Current Drive, Get Current Directory      */
4242:ff.c          **** /*-----------------------------------------------------------------------*/
4243:ff.c          **** 
4244:ff.c          **** FRESULT f_chdrive (
4245:ff.c          **** 	const TCHAR* path		/* Drive number to set */
4246:ff.c          **** )
4247:ff.c          **** {
4248:ff.c          **** 	int vol;
4249:ff.c          **** 
4250:ff.c          **** 
4251:ff.c          **** 	/* Get logical drive number */
4252:ff.c          **** 	vol = get_ldnumber(&path);
4253:ff.c          **** 	if (vol < 0) return FR_INVALID_DRIVE;
4254:ff.c          **** 	CurrVol = (BYTE)vol;	/* Set it as current volume */
4255:ff.c          **** 
4256:ff.c          **** 	return FR_OK;
4257:ff.c          **** }
4258:ff.c          **** 
4259:ff.c          **** 
4260:ff.c          **** 
4261:ff.c          **** FRESULT f_chdir (
4262:ff.c          **** 	const TCHAR* path	/* Pointer to the directory path */
4263:ff.c          **** )
4264:ff.c          **** {
4265:ff.c          **** #if FF_STR_VOLUME_ID == 2
4266:ff.c          **** 	UINT i;
4267:ff.c          **** #endif
4268:ff.c          **** 	FRESULT res;
4269:ff.c          **** 	DIR dj;
4270:ff.c          **** 	FATFS *fs;
4271:ff.c          **** 	DEF_NAMBUF
4272:ff.c          **** 
4273:ff.c          **** 
4274:ff.c          **** 	/* Get logical drive */
4275:ff.c          **** 	res = mount_volume(&path, &fs, 0);
4276:ff.c          **** 	if (res == FR_OK) {
4277:ff.c          **** 		dj.obj.fs = fs;
4278:ff.c          **** 		INIT_NAMBUF(fs);
4279:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the path */
4280:ff.c          **** 		if (res == FR_OK) {					/* Follow completed */
4281:ff.c          **** 			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
4282:ff.c          **** 				fs->cdir = dj.obj.sclust;
4283:ff.c          **** #if FF_FS_EXFAT
4284:ff.c          **** 				if (fs->fs_type == FS_EXFAT) {
4285:ff.c          **** 					fs->cdc_scl = dj.obj.c_scl;
4286:ff.c          **** 					fs->cdc_size = dj.obj.c_size;
4287:ff.c          **** 					fs->cdc_ofs = dj.obj.c_ofs;
4288:ff.c          **** 				}
4289:ff.c          **** #endif
4290:ff.c          **** 			} else {
4291:ff.c          **** 				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
4292:ff.c          **** #if FF_FS_EXFAT
4293:ff.c          **** 					if (fs->fs_type == FS_EXFAT) {
4294:ff.c          **** 						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
4295:ff.c          **** 						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
4296:ff.c          **** 						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
4297:ff.c          **** 						fs->cdc_ofs = dj.blk_ofs;
4298:ff.c          **** 					} else
4299:ff.c          **** #endif
4300:ff.c          **** 					{
4301:ff.c          **** 						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
4302:ff.c          **** 					}
4303:ff.c          **** 				} else {
4304:ff.c          **** 					res = FR_NO_PATH;		/* Reached but a file */
4305:ff.c          **** 				}
4306:ff.c          **** 			}
4307:ff.c          **** 		}
4308:ff.c          **** 		FREE_NAMBUF();
4309:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
4310:ff.c          **** #if FF_STR_VOLUME_ID == 2	/* Also current drive is changed at Unix style volume ID */
4311:ff.c          **** 		if (res == FR_OK) {
4312:ff.c          **** 			for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;	/* Set current drive */
4313:ff.c          **** 			CurrVol = (BYTE)i;
4314:ff.c          **** 		}
4315:ff.c          **** #endif
4316:ff.c          **** 	}
4317:ff.c          **** 
4318:ff.c          **** 	LEAVE_FF(fs, res);
4319:ff.c          **** }
4320:ff.c          **** 
4321:ff.c          **** 
4322:ff.c          **** #if FF_FS_RPATH >= 2
4323:ff.c          **** FRESULT f_getcwd (
4324:ff.c          **** 	TCHAR* buff,	/* Pointer to the directory path */
4325:ff.c          **** 	UINT len		/* Size of buff in unit of TCHAR */
4326:ff.c          **** )
4327:ff.c          **** {
4328:ff.c          **** 	FRESULT res;
4329:ff.c          **** 	DIR dj;
4330:ff.c          **** 	FATFS *fs;
4331:ff.c          **** 	UINT i, n;
4332:ff.c          **** 	DWORD ccl;
4333:ff.c          **** 	TCHAR *tp = buff;
4334:ff.c          **** #if FF_VOLUMES >= 2
4335:ff.c          **** 	UINT vl;
4336:ff.c          **** #if FF_STR_VOLUME_ID
4337:ff.c          **** 	const char *vp;
4338:ff.c          **** #endif
4339:ff.c          **** #endif
4340:ff.c          **** 	FILINFO fno;
4341:ff.c          **** 	DEF_NAMBUF
4342:ff.c          **** 
4343:ff.c          **** 
4344:ff.c          **** 	/* Get logical drive */
4345:ff.c          **** 	buff[0] = 0;	/* Set null string to get current volume */
4346:ff.c          **** 	res = mount_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
4347:ff.c          **** 	if (res == FR_OK) {
4348:ff.c          **** 		dj.obj.fs = fs;
4349:ff.c          **** 		INIT_NAMBUF(fs);
4350:ff.c          **** 
4351:ff.c          **** 		/* Follow parent directories and create the path */
4352:ff.c          **** 		i = len;			/* Bottom of buffer (directory stack base) */
4353:ff.c          **** 		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root pat
4354:ff.c          **** 			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
4355:ff.c          **** 			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
4356:ff.c          **** 				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
4357:ff.c          **** 				if (res != FR_OK) break;
4358:ff.c          **** 				res = move_window(fs, dj.sect);
4359:ff.c          **** 				if (res != FR_OK) break;
4360:ff.c          **** 				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
4361:ff.c          **** 				res = dir_sdi(&dj, 0);
4362:ff.c          **** 				if (res != FR_OK) break;
4363:ff.c          **** 				do {							/* Find the entry links to the child directory */
4364:ff.c          **** 					res = DIR_READ_FILE(&dj);
4365:ff.c          **** 					if (res != FR_OK) break;
4366:ff.c          **** 					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
4367:ff.c          **** 					res = dir_next(&dj, 0);
4368:ff.c          **** 				} while (res == FR_OK);
4369:ff.c          **** 				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
4370:ff.c          **** 				if (res != FR_OK) break;
4371:ff.c          **** 				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
4372:ff.c          **** 				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
4373:ff.c          **** 				if (i < n + 1) {	/* Insufficient space to store the path name? */
4374:ff.c          **** 					res = FR_NOT_ENOUGH_CORE; break;
4375:ff.c          **** 				}
4376:ff.c          **** 				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
4377:ff.c          **** 				buff[--i] = '/';
4378:ff.c          **** 			}
4379:ff.c          **** 		}
4380:ff.c          **** 		if (res == FR_OK) {
4381:ff.c          **** 			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
4382:ff.c          **** #if FF_VOLUMES >= 2			/* Put drive prefix */
4383:ff.c          **** 			vl = 0;
4384:ff.c          **** #if FF_STR_VOLUME_ID >= 1	/* String volume ID */
4385:ff.c          **** 			for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;
4386:ff.c          **** 			if (i >= n + 2) {
4387:ff.c          **** 				if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';
4388:ff.c          **** 				for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;
4389:ff.c          **** 				if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';
4390:ff.c          **** 				vl++;
4391:ff.c          **** 			}
4392:ff.c          **** #else						/* Numeric volume ID */
4393:ff.c          **** 			if (i >= 3) {
4394:ff.c          **** 				*tp++ = (TCHAR)'0' + CurrVol;
4395:ff.c          **** 				*tp++ = (TCHAR)':';
4396:ff.c          **** 				vl = 2;
4397:ff.c          **** 			}
4398:ff.c          **** #endif
4399:ff.c          **** 			if (vl == 0) res = FR_NOT_ENOUGH_CORE;
4400:ff.c          **** #endif
4401:ff.c          **** 			/* Add current directory path */
4402:ff.c          **** 			if (res == FR_OK) {
4403:ff.c          **** 				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
4404:ff.c          **** 			}
4405:ff.c          **** 		}
4406:ff.c          **** 		FREE_NAMBUF();
4407:ff.c          **** 	}
4408:ff.c          **** 
4409:ff.c          **** 	*tp = 0;
4410:ff.c          **** 	LEAVE_FF(fs, res);
4411:ff.c          **** }
4412:ff.c          **** 
4413:ff.c          **** #endif /* FF_FS_RPATH >= 2 */
4414:ff.c          **** #endif /* FF_FS_RPATH >= 1 */
4415:ff.c          **** 
4416:ff.c          **** 
4417:ff.c          **** 
4418:ff.c          **** #if FF_FS_MINIMIZE <= 2
4419:ff.c          **** /*-----------------------------------------------------------------------*/
4420:ff.c          **** /* Seek File Read/Write Pointer                                          */
4421:ff.c          **** /*-----------------------------------------------------------------------*/
4422:ff.c          **** 
4423:ff.c          **** FRESULT f_lseek (
4424:ff.c          **** 	FIL* fp,		/* Pointer to the file object */
4425:ff.c          **** 	FSIZE_t ofs		/* File pointer from top of file */
4426:ff.c          **** )
4427:ff.c          **** {
 7498               		.loc 1 4427 0
 7499               		.cfi_startproc
 7500               	.LVL726:
 7501 22e6 4F92      		push r4
 7502               	.LCFI255:
 7503               		.cfi_def_cfa_offset 3
 7504               		.cfi_offset 4, -2
 7505 22e8 5F92      		push r5
 7506               	.LCFI256:
 7507               		.cfi_def_cfa_offset 4
 7508               		.cfi_offset 5, -3
 7509 22ea 6F92      		push r6
 7510               	.LCFI257:
 7511               		.cfi_def_cfa_offset 5
 7512               		.cfi_offset 6, -4
 7513 22ec 7F92      		push r7
 7514               	.LCFI258:
 7515               		.cfi_def_cfa_offset 6
 7516               		.cfi_offset 7, -5
 7517 22ee 8F92      		push r8
 7518               	.LCFI259:
 7519               		.cfi_def_cfa_offset 7
 7520               		.cfi_offset 8, -6
 7521 22f0 9F92      		push r9
 7522               	.LCFI260:
 7523               		.cfi_def_cfa_offset 8
 7524               		.cfi_offset 9, -7
 7525 22f2 AF92      		push r10
 7526               	.LCFI261:
 7527               		.cfi_def_cfa_offset 9
 7528               		.cfi_offset 10, -8
 7529 22f4 BF92      		push r11
 7530               	.LCFI262:
 7531               		.cfi_def_cfa_offset 10
 7532               		.cfi_offset 11, -9
 7533 22f6 CF92      		push r12
 7534               	.LCFI263:
 7535               		.cfi_def_cfa_offset 11
 7536               		.cfi_offset 12, -10
 7537 22f8 DF92      		push r13
 7538               	.LCFI264:
 7539               		.cfi_def_cfa_offset 12
 7540               		.cfi_offset 13, -11
 7541 22fa EF92      		push r14
 7542               	.LCFI265:
 7543               		.cfi_def_cfa_offset 13
 7544               		.cfi_offset 14, -12
 7545 22fc FF92      		push r15
 7546               	.LCFI266:
 7547               		.cfi_def_cfa_offset 14
 7548               		.cfi_offset 15, -13
 7549 22fe 0F93      		push r16
 7550               	.LCFI267:
 7551               		.cfi_def_cfa_offset 15
 7552               		.cfi_offset 16, -14
 7553 2300 1F93      		push r17
 7554               	.LCFI268:
 7555               		.cfi_def_cfa_offset 16
 7556               		.cfi_offset 17, -15
 7557 2302 CF93      		push r28
 7558               	.LCFI269:
 7559               		.cfi_def_cfa_offset 17
 7560               		.cfi_offset 28, -16
 7561 2304 DF93      		push r29
 7562               	.LCFI270:
 7563               		.cfi_def_cfa_offset 18
 7564               		.cfi_offset 29, -17
 7565 2306 00D0      		rcall .
 7566 2308 00D0      		rcall .
 7567 230a 00D0      		rcall .
 7568               	.LCFI271:
 7569               		.cfi_def_cfa_offset 24
 7570 230c CDB7      		in r28,__SP_L__
 7571 230e DEB7      		in r29,__SP_H__
 7572               	.LCFI272:
 7573               		.cfi_def_cfa_register 28
 7574               	/* prologue: function */
 7575               	/* frame size = 6 */
 7576               	/* stack size = 22 */
 7577               	.L__stack_usage = 22
 7578 2310 8C01      		movw r16,r24
 7579 2312 6A01      		movw r12,r20
 7580 2314 7B01      		movw r14,r22
4428:ff.c          **** 	FRESULT res;
4429:ff.c          **** 	FATFS *fs;
4430:ff.c          **** 	DWORD clst, bcs;
4431:ff.c          **** 	LBA_t nsect;
4432:ff.c          **** 	FSIZE_t ifptr;
4433:ff.c          **** #if FF_USE_FASTSEEK
4434:ff.c          **** 	DWORD cl, pcl, ncl, tcl, tlen, ulen, *tbl;
4435:ff.c          **** 	LBA_t dsc;
4436:ff.c          **** #endif
4437:ff.c          **** 
4438:ff.c          **** 	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 7581               		.loc 1 4438 0
 7582 2316 BE01      		movw r22,r28
 7583 2318 6F5F      		subi r22,-1
 7584 231a 7F4F      		sbci r23,-1
 7585 231c 0E94 0000 		call validate
 7586               	.LVL727:
4439:ff.c          **** 	if (res == FR_OK) res = (FRESULT)fp->err;
 7587               		.loc 1 4439 0
 7588 2320 8111      		cpse r24,__zero_reg__
 7589 2322 00C0      		rjmp .L570
 7590               		.loc 1 4439 0 is_stmt 0 discriminator 1
 7591 2324 D801      		movw r26,r16
 7592 2326 1F96      		adiw r26,15
 7593 2328 8C91      		ld r24,X
 7594 232a 1F97      		sbiw r26,15
 7595               	.LVL728:
4440:ff.c          **** #if FF_FS_EXFAT && !FF_FS_READONLY
4441:ff.c          **** 	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
4442:ff.c          **** 		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed
4443:ff.c          **** 	}
4444:ff.c          **** #endif
4445:ff.c          **** 	if (res != FR_OK) LEAVE_FF(fs, res);
 7596               		.loc 1 4445 0 is_stmt 1 discriminator 1
 7597 232c 8111      		cpse r24,__zero_reg__
 7598 232e 00C0      		rjmp .L570
4446:ff.c          **** 
4447:ff.c          **** #if FF_USE_FASTSEEK
4448:ff.c          **** 	if (fp->cltbl) {	/* Fast seek */
4449:ff.c          **** 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
4450:ff.c          **** 			tbl = fp->cltbl;
4451:ff.c          **** 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
4452:ff.c          **** 			cl = fp->obj.sclust;		/* Origin of the chain */
4453:ff.c          **** 			if (cl != 0) {
4454:ff.c          **** 				do {
4455:ff.c          **** 					/* Get a fragment */
4456:ff.c          **** 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
4457:ff.c          **** 					do {
4458:ff.c          **** 						pcl = cl; ncl++;
4459:ff.c          **** 						cl = get_fat(&fp->obj, cl);
4460:ff.c          **** 						if (cl <= 1) ABORT(fs, FR_INT_ERR);
4461:ff.c          **** 						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
4462:ff.c          **** 					} while (cl == pcl + 1);
4463:ff.c          **** 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
4464:ff.c          **** 						*tbl++ = ncl; *tbl++ = tcl;
4465:ff.c          **** 					}
4466:ff.c          **** 				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
4467:ff.c          **** 			}
4468:ff.c          **** 			*fp->cltbl = ulen;	/* Number of items used */
4469:ff.c          **** 			if (ulen <= tlen) {
4470:ff.c          **** 				*tbl = 0;		/* Terminate table */
4471:ff.c          **** 			} else {
4472:ff.c          **** 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
4473:ff.c          **** 			}
4474:ff.c          **** 		} else {						/* Fast seek */
4475:ff.c          **** 			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
4476:ff.c          **** 			fp->fptr = ofs;				/* Set file pointer */
4477:ff.c          **** 			if (ofs > 0) {
4478:ff.c          **** 				fp->clust = clmt_clust(fp, ofs - 1);
4479:ff.c          **** 				dsc = clst2sect(fs, fp->clust);
4480:ff.c          **** 				if (dsc == 0) ABORT(fs, FR_INT_ERR);
4481:ff.c          **** 				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
4482:ff.c          **** 				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
4483:ff.c          **** #if !FF_FS_TINY
4484:ff.c          **** #if !FF_FS_READONLY
4485:ff.c          **** 					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
4486:ff.c          **** 						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
4487:ff.c          **** 						fp->flag &= (BYTE)~FA_DIRTY;
4488:ff.c          **** 					}
4489:ff.c          **** #endif
4490:ff.c          **** 					if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current se
4491:ff.c          **** #endif
4492:ff.c          **** 					fp->sect = dsc;
4493:ff.c          **** 				}
4494:ff.c          **** 			}
4495:ff.c          **** 		}
4496:ff.c          **** 	} else
4497:ff.c          **** #endif
4498:ff.c          **** 
4499:ff.c          **** 	/* Normal Seek */
4500:ff.c          **** 	{
4501:ff.c          **** #if FF_FS_EXFAT
4502:ff.c          **** 		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4 GiB - 1 if at F
4503:ff.c          **** #endif
4504:ff.c          **** 		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, 
 7599               		.loc 1 4504 0
 7600 2330 1A96      		adiw r26,10
 7601 2332 8D91      		ld r24,X+
 7602 2334 9D91      		ld r25,X+
 7603 2336 0D90      		ld __tmp_reg__,X+
 7604 2338 BC91      		ld r27,X
 7605 233a A02D      		mov r26,__tmp_reg__
 7606               	.LVL729:
 7607 233c 8C15      		cp r24,r12
 7608 233e 9D05      		cpc r25,r13
 7609 2340 AE05      		cpc r26,r14
 7610 2342 BF05      		cpc r27,r15
 7611 2344 00F4      		brsh .L531
 7612               		.loc 1 4504 0 is_stmt 0 discriminator 1
 7613 2346 F801      		movw r30,r16
 7614 2348 2685      		ldd r18,Z+14
 7615 234a 21FD      		sbrc r18,1
 7616 234c 00C0      		rjmp .L531
 7617               		.loc 1 4504 0
 7618 234e 6C01      		movw r12,r24
 7619 2350 7D01      		movw r14,r26
 7620               	.LVL730:
 7621               	.L531:
4505:ff.c          **** 			ofs = fp->obj.objsize;
4506:ff.c          **** 		}
4507:ff.c          **** 		ifptr = fp->fptr;
 7622               		.loc 1 4507 0 is_stmt 1
 7623 2352 D801      		movw r26,r16
 7624 2354 5096      		adiw r26,16
 7625 2356 8D90      		ld r8,X+
 7626 2358 9D90      		ld r9,X+
 7627 235a AD90      		ld r10,X+
 7628 235c BC90      		ld r11,X
 7629 235e 5397      		sbiw r26,16+3
 7630               	.LVL731:
4508:ff.c          **** 		fp->fptr = nsect = 0;
 7631               		.loc 1 4508 0
 7632 2360 F801      		movw r30,r16
 7633 2362 108A      		std Z+16,__zero_reg__
 7634 2364 118A      		std Z+17,__zero_reg__
 7635 2366 128A      		std Z+18,__zero_reg__
 7636 2368 138A      		std Z+19,__zero_reg__
4509:ff.c          **** 		if (ofs > 0) {
 7637               		.loc 1 4509 0
 7638 236a C114      		cp r12,__zero_reg__
 7639 236c D104      		cpc r13,__zero_reg__
 7640 236e E104      		cpc r14,__zero_reg__
 7641 2370 F104      		cpc r15,__zero_reg__
 7642 2372 01F4      		brne .+2
 7643 2374 00C0      		rjmp .L571
4510:ff.c          **** 			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 7644               		.loc 1 4510 0
 7645 2376 E981      		ldd r30,Y+1
 7646 2378 FA81      		ldd r31,Y+2
 7647 237a 8185      		ldd r24,Z+9
 7648 237c 9285      		ldd r25,Z+10
 7649 237e A0E0      		ldi r26,0
 7650 2380 B0E0      		ldi r27,0
 7651 2382 2C01      		movw r4,r24
 7652 2384 3D01      		movw r6,r26
 7653 2386 39E0      		ldi r19,9
 7654               		1:
 7655 2388 440C      		lsl r4
 7656 238a 551C      		rol r5
 7657 238c 661C      		rol r6
 7658 238e 771C      		rol r7
 7659 2390 3A95      		dec r19
 7660 2392 01F4      		brne 1b
 7661               	.LVL732:
4511:ff.c          **** 			if (ifptr > 0 &&
 7662               		.loc 1 4511 0
 7663 2394 8114      		cp r8,__zero_reg__
 7664 2396 9104      		cpc r9,__zero_reg__
 7665 2398 A104      		cpc r10,__zero_reg__
 7666 239a B104      		cpc r11,__zero_reg__
 7667 239c 01F4      		brne .+2
 7668 239e 00C0      		rjmp .L535
4512:ff.c          **** 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 7669               		.loc 1 4512 0 discriminator 1
 7670 23a0 F1E0      		ldi r31,1
 7671 23a2 8F1A      		sub r8,r31
 7672 23a4 9108      		sbc r9,__zero_reg__
 7673 23a6 A108      		sbc r10,__zero_reg__
 7674 23a8 B108      		sbc r11,__zero_reg__
 7675               	.LVL733:
4511:ff.c          **** 			if (ifptr > 0 &&
 7676               		.loc 1 4511 0 discriminator 1
 7677 23aa C701      		movw r24,r14
 7678 23ac B601      		movw r22,r12
 7679 23ae 6150      		subi r22,1
 7680 23b0 7109      		sbc r23,__zero_reg__
 7681 23b2 8109      		sbc r24,__zero_reg__
 7682 23b4 9109      		sbc r25,__zero_reg__
 7683 23b6 A301      		movw r20,r6
 7684 23b8 9201      		movw r18,r4
 7685 23ba 0E94 0000 		call __udivmodsi4
 7686 23be 2B83      		std Y+3,r18
 7687 23c0 3C83      		std Y+4,r19
 7688 23c2 4D83      		std Y+5,r20
 7689 23c4 5E83      		std Y+6,r21
 7690 23c6 C501      		movw r24,r10
 7691 23c8 B401      		movw r22,r8
 7692 23ca A301      		movw r20,r6
 7693 23cc 9201      		movw r18,r4
 7694 23ce 0E94 0000 		call __udivmodsi4
 7695 23d2 8B81      		ldd r24,Y+3
 7696 23d4 9C81      		ldd r25,Y+4
 7697 23d6 AD81      		ldd r26,Y+5
 7698 23d8 BE81      		ldd r27,Y+6
 7699 23da 8217      		cp r24,r18
 7700 23dc 9307      		cpc r25,r19
 7701 23de A407      		cpc r26,r20
 7702 23e0 B507      		cpc r27,r21
 7703 23e2 00F0      		brlo .L535
4513:ff.c          **** 				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 7704               		.loc 1 4513 0
 7705 23e4 8827      		clr r24
 7706 23e6 9927      		clr r25
 7707 23e8 DC01      		movw r26,r24
 7708 23ea 8419      		sub r24,r4
 7709 23ec 9509      		sbc r25,r5
 7710 23ee A609      		sbc r26,r6
 7711 23f0 B709      		sbc r27,r7
 7712 23f2 8822      		and r8,r24
 7713 23f4 9922      		and r9,r25
 7714 23f6 AA22      		and r10,r26
 7715 23f8 BB22      		and r11,r27
 7716               	.LVL734:
 7717 23fa D801      		movw r26,r16
 7718 23fc 5096      		adiw r26,16
 7719 23fe 8D92      		st X+,r8
 7720 2400 9D92      		st X+,r9
 7721 2402 AD92      		st X+,r10
 7722 2404 BC92      		st X,r11
 7723 2406 5397      		sbiw r26,16+3
4514:ff.c          **** 				ofs -= fp->fptr;
 7724               		.loc 1 4514 0
 7725 2408 C818      		sub r12,r8
 7726 240a D908      		sbc r13,r9
 7727 240c EA08      		sbc r14,r10
 7728 240e FB08      		sbc r15,r11
 7729               	.LVL735:
4515:ff.c          **** 				clst = fp->clust;
 7730               		.loc 1 4515 0
 7731 2410 5496      		adiw r26,20
 7732 2412 4D91      		ld r20,X+
 7733 2414 5D91      		ld r21,X+
 7734 2416 6D91      		ld r22,X+
 7735 2418 7C91      		ld r23,X
 7736 241a 5797      		sbiw r26,20+3
 7737               	.LVL736:
 7738 241c 00C0      		rjmp .L536
 7739               	.LVL737:
 7740               	.L535:
4516:ff.c          **** 			} else {									/* When seek to back cluster, */
4517:ff.c          **** 				clst = fp->obj.sclust;					/* start from the first cluster */
 7741               		.loc 1 4517 0
 7742 241e F801      		movw r30,r16
 7743 2420 4681      		ldd r20,Z+6
 7744 2422 5781      		ldd r21,Z+7
 7745 2424 6085      		ldd r22,Z+8
 7746 2426 7185      		ldd r23,Z+9
 7747               	.LVL738:
4518:ff.c          **** #if !FF_FS_READONLY
4519:ff.c          **** 				if (clst == 0) {						/* If no cluster chain, create a new chain */
 7748               		.loc 1 4519 0
 7749 2428 4115      		cp r20,__zero_reg__
 7750 242a 5105      		cpc r21,__zero_reg__
 7751 242c 6105      		cpc r22,__zero_reg__
 7752 242e 7105      		cpc r23,__zero_reg__
 7753 2430 01F4      		brne .L537
4520:ff.c          **** 					clst = create_chain(&fp->obj, 0);
 7754               		.loc 1 4520 0
 7755 2432 40E0      		ldi r20,0
 7756 2434 50E0      		ldi r21,0
 7757 2436 BA01      		movw r22,r20
 7758               	.LVL739:
 7759 2438 C801      		movw r24,r16
 7760 243a 0E94 0000 		call create_chain
 7761               	.LVL740:
 7762 243e AB01      		movw r20,r22
 7763 2440 BC01      		movw r22,r24
 7764               	.LVL741:
4521:ff.c          **** 					if (clst == 1) ABORT(fs, FR_INT_ERR);
 7765               		.loc 1 4521 0
 7766 2442 4130      		cpi r20,1
 7767 2444 5105      		cpc r21,__zero_reg__
 7768 2446 6105      		cpc r22,__zero_reg__
 7769 2448 7105      		cpc r23,__zero_reg__
 7770 244a 01F4      		brne .L538
 7771               	.LVL742:
 7772               	.L546:
 7773               		.loc 1 4521 0 is_stmt 0 discriminator 1
 7774 244c 82E0      		ldi r24,lo8(2)
 7775 244e D801      		movw r26,r16
 7776 2450 1F96      		adiw r26,15
 7777 2452 8C93      		st X,r24
 7778 2454 00C0      		rjmp .L570
 7779               	.LVL743:
 7780               	.L538:
4522:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 7781               		.loc 1 4522 0 is_stmt 1
 7782 2456 4F3F      		cpi r20,-1
 7783 2458 BFEF      		ldi r27,-1
 7784 245a 5B07      		cpc r21,r27
 7785 245c 6B07      		cpc r22,r27
 7786 245e 7B07      		cpc r23,r27
 7787 2460 01F4      		brne .L539
 7788               	.L545:
 7789               		.loc 1 4522 0 is_stmt 0 discriminator 1
 7790 2462 81E0      		ldi r24,lo8(1)
 7791 2464 F801      		movw r30,r16
 7792 2466 8787      		std Z+15,r24
 7793 2468 00C0      		rjmp .L570
 7794               	.L539:
4523:ff.c          **** 					fp->obj.sclust = clst;
 7795               		.loc 1 4523 0 is_stmt 1
 7796 246a D801      		movw r26,r16
 7797 246c 1696      		adiw r26,6
 7798 246e 4D93      		st X+,r20
 7799 2470 5D93      		st X+,r21
 7800 2472 6D93      		st X+,r22
 7801 2474 7C93      		st X,r23
 7802 2476 1997      		sbiw r26,6+3
 7803               	.L537:
4524:ff.c          **** 				}
4525:ff.c          **** #endif
4526:ff.c          **** 				fp->clust = clst;
 7804               		.loc 1 4526 0
 7805 2478 F801      		movw r30,r16
 7806 247a 448B      		std Z+20,r20
 7807 247c 558B      		std Z+21,r21
 7808 247e 668B      		std Z+22,r22
 7809 2480 778B      		std Z+23,r23
 7810               	.L536:
4527:ff.c          **** 			}
4528:ff.c          **** 			if (clst != 0) {
 7811               		.loc 1 4528 0
 7812 2482 4115      		cp r20,__zero_reg__
 7813 2484 5105      		cpc r21,__zero_reg__
 7814 2486 6105      		cpc r22,__zero_reg__
 7815 2488 7105      		cpc r23,__zero_reg__
 7816 248a 01F0      		breq .+2
 7817 248c 00C0      		rjmp .L541
 7818               	.L540:
4508:ff.c          **** 		if (ofs > 0) {
 7819               		.loc 1 4508 0
 7820 248e C12C      		mov r12,__zero_reg__
 7821 2490 D12C      		mov r13,__zero_reg__
 7822 2492 7601      		movw r14,r12
 7823               	.LVL744:
 7824 2494 00C0      		rjmp .L534
 7825               	.LVL745:
 7826               	.L547:
4529:ff.c          **** 				while (ofs > bcs) {						/* Cluster following loop */
4530:ff.c          **** 					ofs -= bcs; fp->fptr += bcs;
 7827               		.loc 1 4530 0
 7828 2496 C418      		sub r12,r4
 7829 2498 D508      		sbc r13,r5
 7830 249a E608      		sbc r14,r6
 7831 249c F708      		sbc r15,r7
 7832               	.LVL746:
 7833 249e F801      		movw r30,r16
 7834 24a0 8089      		ldd r24,Z+16
 7835 24a2 9189      		ldd r25,Z+17
 7836 24a4 A289      		ldd r26,Z+18
 7837 24a6 B389      		ldd r27,Z+19
 7838 24a8 840D      		add r24,r4
 7839 24aa 951D      		adc r25,r5
 7840 24ac A61D      		adc r26,r6
 7841 24ae B71D      		adc r27,r7
 7842 24b0 808B      		std Z+16,r24
 7843 24b2 918B      		std Z+17,r25
 7844 24b4 A28B      		std Z+18,r26
 7845 24b6 B38B      		std Z+19,r27
4531:ff.c          **** #if !FF_FS_READONLY
4532:ff.c          **** 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 7846               		.loc 1 4532 0
 7847 24b8 8685      		ldd r24,Z+14
 7848 24ba 81FF      		sbrs r24,1
 7849 24bc 00C0      		rjmp .L542
4533:ff.c          **** 						if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize
4534:ff.c          **** 							fp->obj.objsize = fp->fptr;
4535:ff.c          **** 							fp->flag |= FA_MODIFIED;
4536:ff.c          **** 						}
4537:ff.c          **** 						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 7850               		.loc 1 4537 0
 7851 24be C801      		movw r24,r16
 7852 24c0 0E94 0000 		call create_chain
 7853               	.LVL747:
 7854 24c4 AB01      		movw r20,r22
 7855 24c6 BC01      		movw r22,r24
 7856               	.LVL748:
4538:ff.c          **** 						if (clst == 0) {				/* Clip file size in case of disk full */
 7857               		.loc 1 4538 0
 7858 24c8 4115      		cp r20,__zero_reg__
 7859 24ca 5105      		cpc r21,__zero_reg__
 7860 24cc 6105      		cpc r22,__zero_reg__
 7861 24ce 7105      		cpc r23,__zero_reg__
 7862 24d0 01F0      		breq .L572
 7863               	.L544:
4539:ff.c          **** 							ofs = 0; break;
4540:ff.c          **** 						}
4541:ff.c          **** 					} else
4542:ff.c          **** #endif
4543:ff.c          **** 					{
4544:ff.c          **** 						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
4545:ff.c          **** 					}
4546:ff.c          **** 					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 7864               		.loc 1 4546 0
 7865 24d2 4F3F      		cpi r20,-1
 7866 24d4 BFEF      		ldi r27,-1
 7867 24d6 5B07      		cpc r21,r27
 7868 24d8 6B07      		cpc r22,r27
 7869 24da 7B07      		cpc r23,r27
 7870 24dc 01F0      		breq .L545
4547:ff.c          **** 					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 7871               		.loc 1 4547 0
 7872 24de 4230      		cpi r20,2
 7873 24e0 5105      		cpc r21,__zero_reg__
 7874 24e2 6105      		cpc r22,__zero_reg__
 7875 24e4 7105      		cpc r23,__zero_reg__
 7876 24e6 00F4      		brsh .+2
 7877 24e8 00C0      		rjmp .L546
 7878               		.loc 1 4547 0 is_stmt 0 discriminator 2
 7879 24ea E981      		ldd r30,Y+1
 7880 24ec FA81      		ldd r31,Y+2
 7881 24ee 8389      		ldd r24,Z+19
 7882 24f0 9489      		ldd r25,Z+20
 7883 24f2 A589      		ldd r26,Z+21
 7884 24f4 B689      		ldd r27,Z+22
 7885 24f6 4817      		cp r20,r24
 7886 24f8 5907      		cpc r21,r25
 7887 24fa 6A07      		cpc r22,r26
 7888 24fc 7B07      		cpc r23,r27
 7889 24fe 00F0      		brlo .+2
 7890 2500 00C0      		rjmp .L546
4548:ff.c          **** 					fp->clust = clst;
 7891               		.loc 1 4548 0 is_stmt 1
 7892 2502 F801      		movw r30,r16
 7893 2504 448B      		std Z+20,r20
 7894 2506 558B      		std Z+21,r21
 7895 2508 668B      		std Z+22,r22
 7896 250a 778B      		std Z+23,r23
 7897               	.L541:
4529:ff.c          **** 					ofs -= bcs; fp->fptr += bcs;
 7898               		.loc 1 4529 0
 7899 250c 4C14      		cp r4,r12
 7900 250e 5D04      		cpc r5,r13
 7901 2510 6E04      		cpc r6,r14
 7902 2512 7F04      		cpc r7,r15
 7903 2514 00F4      		brsh .+2
 7904 2516 00C0      		rjmp .L547
 7905 2518 00C0      		rjmp .L543
 7906               	.L542:
4544:ff.c          **** 					}
 7907               		.loc 1 4544 0
 7908 251a 8081      		ld r24,Z
 7909 251c 9181      		ldd r25,Z+1
 7910 251e 0E94 0000 		call get_fat.isra.10
 7911               	.LVL749:
 7912 2522 AB01      		movw r20,r22
 7913 2524 BC01      		movw r22,r24
 7914               	.LVL750:
 7915 2526 00C0      		rjmp .L544
 7916               	.L572:
4539:ff.c          **** 						}
 7917               		.loc 1 4539 0
 7918 2528 C12C      		mov r12,__zero_reg__
 7919 252a D12C      		mov r13,__zero_reg__
 7920 252c 7601      		movw r14,r12
 7921               	.LVL751:
 7922               	.L543:
4549:ff.c          **** 				}
4550:ff.c          **** 				fp->fptr += ofs;
 7923               		.loc 1 4550 0
 7924 252e F801      		movw r30,r16
 7925 2530 8089      		ldd r24,Z+16
 7926 2532 9189      		ldd r25,Z+17
 7927 2534 A289      		ldd r26,Z+18
 7928 2536 B389      		ldd r27,Z+19
 7929 2538 8C0D      		add r24,r12
 7930 253a 9D1D      		adc r25,r13
 7931 253c AE1D      		adc r26,r14
 7932 253e BF1D      		adc r27,r15
 7933 2540 808B      		std Z+16,r24
 7934 2542 918B      		std Z+17,r25
 7935 2544 A28B      		std Z+18,r26
 7936 2546 B38B      		std Z+19,r27
4551:ff.c          **** 				if (ofs % SS(fs)) {
 7937               		.loc 1 4551 0
 7938 2548 D701      		movw r26,r14
 7939 254a C601      		movw r24,r12
 7940 254c 9170      		andi r25,1
 7941 254e AA27      		clr r26
 7942 2550 BB27      		clr r27
 7943 2552 892B      		or r24,r25
 7944 2554 8A2B      		or r24,r26
 7945 2556 8B2B      		or r24,r27
 7946 2558 01F4      		brne .+2
 7947 255a 00C0      		rjmp .L540
4552:ff.c          **** 					nsect = clst2sect(fs, clst);	/* Current sector */
 7948               		.loc 1 4552 0
 7949 255c 8981      		ldd r24,Y+1
 7950 255e 9A81      		ldd r25,Y+2
 7951 2560 0E94 0000 		call clst2sect
 7952               	.LVL752:
4553:ff.c          **** 					if (nsect == 0) ABORT(fs, FR_INT_ERR);
 7953               		.loc 1 4553 0
 7954 2564 6115      		cp r22,__zero_reg__
 7955 2566 7105      		cpc r23,__zero_reg__
 7956 2568 8105      		cpc r24,__zero_reg__
 7957 256a 9105      		cpc r25,__zero_reg__
 7958 256c 01F4      		brne .+2
 7959 256e 00C0      		rjmp .L546
4554:ff.c          **** 					nsect += (DWORD)(ofs / SS(fs));
 7960               		.loc 1 4554 0
 7961 2570 29E0      		ldi r18,9
 7962               		1:
 7963 2572 F694      		lsr r15
 7964 2574 E794      		ror r14
 7965 2576 D794      		ror r13
 7966 2578 C794      		ror r12
 7967 257a 2A95      		dec r18
 7968 257c 01F4      		brne 1b
 7969               	.LVL753:
 7970 257e C60E      		add r12,r22
 7971 2580 D71E      		adc r13,r23
 7972 2582 E81E      		adc r14,r24
 7973 2584 F91E      		adc r15,r25
 7974               	.LVL754:
 7975               	.L534:
4555:ff.c          **** 				}
4556:ff.c          **** 			}
4557:ff.c          **** 		}
4558:ff.c          **** 		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is 
 7976               		.loc 1 4558 0
 7977 2586 F801      		movw r30,r16
 7978 2588 8089      		ldd r24,Z+16
 7979 258a 9189      		ldd r25,Z+17
 7980 258c A289      		ldd r26,Z+18
 7981 258e B389      		ldd r27,Z+19
 7982 2590 4285      		ldd r20,Z+10
 7983 2592 5385      		ldd r21,Z+11
 7984 2594 6485      		ldd r22,Z+12
 7985 2596 7585      		ldd r23,Z+13
 7986 2598 4817      		cp r20,r24
 7987 259a 5907      		cpc r21,r25
 7988 259c 6A07      		cpc r22,r26
 7989 259e 7B07      		cpc r23,r27
 7990 25a0 00F4      		brsh .L548
4559:ff.c          **** 			fp->obj.objsize = fp->fptr;
 7991               		.loc 1 4559 0
 7992 25a2 8287      		std Z+10,r24
 7993 25a4 9387      		std Z+11,r25
 7994 25a6 A487      		std Z+12,r26
 7995 25a8 B587      		std Z+13,r27
4560:ff.c          **** 			fp->flag |= FA_MODIFIED;
 7996               		.loc 1 4560 0
 7997 25aa 2685      		ldd r18,Z+14
 7998 25ac 2064      		ori r18,lo8(64)
 7999 25ae 2687      		std Z+14,r18
 8000               	.LVL755:
 8001               	.L548:
4561:ff.c          **** 		}
4562:ff.c          **** 		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8002               		.loc 1 4562 0
 8003 25b0 9170      		andi r25,1
 8004 25b2 AA27      		clr r26
 8005 25b4 BB27      		clr r27
 8006 25b6 892B      		or r24,r25
 8007 25b8 8A2B      		or r24,r26
 8008 25ba 8B2B      		or r24,r27
 8009 25bc 01F0      		breq .L553
 8010               		.loc 1 4562 0 is_stmt 0 discriminator 1
 8011 25be F801      		movw r30,r16
 8012 25c0 808D      		ldd r24,Z+24
 8013 25c2 918D      		ldd r25,Z+25
 8014 25c4 A28D      		ldd r26,Z+26
 8015 25c6 B38D      		ldd r27,Z+27
 8016 25c8 8C15      		cp r24,r12
 8017 25ca 9D05      		cpc r25,r13
 8018 25cc AE05      		cpc r26,r14
 8019 25ce BF05      		cpc r27,r15
 8020 25d0 01F0      		breq .L553
4563:ff.c          **** #if !FF_FS_TINY
4564:ff.c          **** #if !FF_FS_READONLY
4565:ff.c          **** 			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
4566:ff.c          **** 				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
4567:ff.c          **** 				fp->flag &= (BYTE)~FA_DIRTY;
4568:ff.c          **** 			}
4569:ff.c          **** #endif
4570:ff.c          **** 			if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cac
4571:ff.c          **** #endif
4572:ff.c          **** 			fp->sect = nsect;
 8021               		.loc 1 4572 0 is_stmt 1
 8022 25d2 C08E      		std Z+24,r12
 8023 25d4 D18E      		std Z+25,r13
 8024 25d6 E28E      		std Z+26,r14
 8025 25d8 F38E      		std Z+27,r15
 8026               	.L553:
 8027 25da 80E0      		ldi r24,0
 8028 25dc 00C0      		rjmp .L570
 8029               	.LVL756:
 8030               	.L571:
4558:ff.c          **** 			fp->obj.objsize = fp->fptr;
 8031               		.loc 1 4558 0
 8032 25de 80E0      		ldi r24,0
 8033 25e0 90E0      		ldi r25,0
 8034 25e2 DC01      		movw r26,r24
4508:ff.c          **** 		if (ofs > 0) {
 8035               		.loc 1 4508 0
 8036 25e4 C12C      		mov r12,__zero_reg__
 8037 25e6 D12C      		mov r13,__zero_reg__
 8038 25e8 7601      		movw r14,r12
 8039               	.LVL757:
 8040 25ea 00C0      		rjmp .L548
 8041               	.LVL758:
 8042               	.L570:
 8043               	/* epilogue start */
4573:ff.c          **** 		}
4574:ff.c          **** 	}
4575:ff.c          **** 
4576:ff.c          **** 	LEAVE_FF(fs, res);
4577:ff.c          **** }
 8044               		.loc 1 4577 0
 8045 25ec 2696      		adiw r28,6
 8046 25ee 0FB6      		in __tmp_reg__,__SREG__
 8047 25f0 F894      		cli
 8048 25f2 DEBF      		out __SP_H__,r29
 8049 25f4 0FBE      		out __SREG__,__tmp_reg__
 8050 25f6 CDBF      		out __SP_L__,r28
 8051 25f8 DF91      		pop r29
 8052 25fa CF91      		pop r28
 8053 25fc 1F91      		pop r17
 8054 25fe 0F91      		pop r16
 8055               	.LVL759:
 8056 2600 FF90      		pop r15
 8057 2602 EF90      		pop r14
 8058 2604 DF90      		pop r13
 8059 2606 CF90      		pop r12
 8060 2608 BF90      		pop r11
 8061 260a AF90      		pop r10
 8062 260c 9F90      		pop r9
 8063 260e 8F90      		pop r8
 8064 2610 7F90      		pop r7
 8065 2612 6F90      		pop r6
 8066 2614 5F90      		pop r5
 8067 2616 4F90      		pop r4
 8068 2618 0895      		ret
 8069               		.cfi_endproc
 8070               	.LFE42:
 8072               	.global	f_opendir
 8074               	f_opendir:
 8075               	.LFB43:
4578:ff.c          **** 
4579:ff.c          **** 
4580:ff.c          **** 
4581:ff.c          **** #if FF_FS_MINIMIZE <= 1
4582:ff.c          **** /*-----------------------------------------------------------------------*/
4583:ff.c          **** /* Create a Directory Object                                             */
4584:ff.c          **** /*-----------------------------------------------------------------------*/
4585:ff.c          **** 
4586:ff.c          **** FRESULT f_opendir (
4587:ff.c          **** 	DIR* dp,			/* Pointer to directory object to create */
4588:ff.c          **** 	const TCHAR* path	/* Pointer to the directory path */
4589:ff.c          **** )
4590:ff.c          **** {
 8076               		.loc 1 4590 0
 8077               		.cfi_startproc
 8078               	.LVL760:
 8079 261a 0F93      		push r16
 8080               	.LCFI273:
 8081               		.cfi_def_cfa_offset 3
 8082               		.cfi_offset 16, -2
 8083 261c 1F93      		push r17
 8084               	.LCFI274:
 8085               		.cfi_def_cfa_offset 4
 8086               		.cfi_offset 17, -3
 8087 261e CF93      		push r28
 8088               	.LCFI275:
 8089               		.cfi_def_cfa_offset 5
 8090               		.cfi_offset 28, -4
 8091 2620 DF93      		push r29
 8092               	.LCFI276:
 8093               		.cfi_def_cfa_offset 6
 8094               		.cfi_offset 29, -5
 8095 2622 00D0      		rcall .
 8096 2624 00D0      		rcall .
 8097               	.LCFI277:
 8098               		.cfi_def_cfa_offset 10
 8099 2626 CDB7      		in r28,__SP_L__
 8100 2628 DEB7      		in r29,__SP_H__
 8101               	.LCFI278:
 8102               		.cfi_def_cfa_register 28
 8103               	/* prologue: function */
 8104               	/* frame size = 4 */
 8105               	/* stack size = 8 */
 8106               	.L__stack_usage = 8
 8107 262a 7C83      		std Y+4,r23
 8108 262c 6B83      		std Y+3,r22
4591:ff.c          **** 	FRESULT res;
4592:ff.c          **** 	FATFS *fs;
4593:ff.c          **** 	DEF_NAMBUF
4594:ff.c          **** 
4595:ff.c          **** 
4596:ff.c          **** 	if (!dp) return FR_INVALID_OBJECT;
 8109               		.loc 1 4596 0
 8110 262e 0097      		sbiw r24,0
 8111 2630 01F0      		breq .L581
 8112 2632 8C01      		movw r16,r24
4597:ff.c          **** 
4598:ff.c          **** 	/* Get logical drive */
4599:ff.c          **** 	res = mount_volume(&path, &fs, 0);
 8113               		.loc 1 4599 0
 8114 2634 40E0      		ldi r20,0
 8115 2636 BE01      		movw r22,r28
 8116               	.LVL761:
 8117 2638 6F5F      		subi r22,-1
 8118 263a 7F4F      		sbci r23,-1
 8119 263c CE01      		movw r24,r28
 8120               	.LVL762:
 8121 263e 0396      		adiw r24,3
 8122 2640 0E94 0000 		call mount_volume
 8123               	.LVL763:
4600:ff.c          **** 	if (res == FR_OK) {
 8124               		.loc 1 4600 0
 8125 2644 8111      		cpse r24,__zero_reg__
 8126 2646 00C0      		rjmp .L578
4601:ff.c          **** 		dp->obj.fs = fs;
 8127               		.loc 1 4601 0
 8128 2648 8981      		ldd r24,Y+1
 8129 264a 9A81      		ldd r25,Y+2
 8130               	.LVL764:
 8131 264c F801      		movw r30,r16
 8132 264e 9183      		std Z+1,r25
 8133 2650 8083      		st Z,r24
4602:ff.c          **** 		INIT_NAMBUF(fs);
4603:ff.c          **** 		res = follow_path(dp, path);			/* Follow the path to the directory */
 8134               		.loc 1 4603 0
 8135 2652 6B81      		ldd r22,Y+3
 8136 2654 7C81      		ldd r23,Y+4
 8137 2656 C801      		movw r24,r16
 8138 2658 0E94 0000 		call follow_path
 8139               	.LVL765:
4604:ff.c          **** 		if (res == FR_OK) {						/* Follow completed */
 8140               		.loc 1 4604 0
 8141 265c 8111      		cpse r24,__zero_reg__
 8142 265e 00C0      		rjmp .L576
4605:ff.c          **** 			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8143               		.loc 1 4605 0
 8144 2660 F801      		movw r30,r16
 8145 2662 87A1      		ldd r24,Z+39
 8146               	.LVL766:
 8147 2664 87FD      		sbrc r24,7
 8148 2666 00C0      		rjmp .L577
4606:ff.c          **** 				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 8149               		.loc 1 4606 0
 8150 2668 8481      		ldd r24,Z+4
 8151 266a 84FF      		sbrs r24,4
 8152 266c 00C0      		rjmp .L582
4607:ff.c          **** #if FF_FS_EXFAT
4608:ff.c          **** 					if (fs->fs_type == FS_EXFAT) {
4609:ff.c          **** 						dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
4610:ff.c          **** 						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
4611:ff.c          **** 						dp->obj.c_ofs = dp->blk_ofs;
4612:ff.c          **** 						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
4613:ff.c          **** 					} else
4614:ff.c          **** #endif
4615:ff.c          **** 					{
4616:ff.c          **** 						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8153               		.loc 1 4616 0
 8154 266e 628D      		ldd r22,Z+26
 8155 2670 738D      		ldd r23,Z+27
 8156 2672 E981      		ldd r30,Y+1
 8157 2674 FA81      		ldd r31,Y+2
 8158 2676 8081      		ld r24,Z
 8159 2678 0E94 0000 		call ld_clust.isra.3
 8160               	.LVL767:
 8161 267c F801      		movw r30,r16
 8162 267e 6683      		std Z+6,r22
 8163 2680 7783      		std Z+7,r23
 8164 2682 8087      		std Z+8,r24
 8165 2684 9187      		std Z+9,r25
 8166               	.L577:
 8167               	.LVL768:
4617:ff.c          **** 					}
4618:ff.c          **** 				} else {						/* This object is a file */
4619:ff.c          **** 					res = FR_NO_PATH;
4620:ff.c          **** 				}
4621:ff.c          **** 			}
4622:ff.c          **** 			if (res == FR_OK) {
4623:ff.c          **** 				dp->obj.id = fs->id;
 8168               		.loc 1 4623 0
 8169 2686 E981      		ldd r30,Y+1
 8170 2688 FA81      		ldd r31,Y+2
 8171 268a 8581      		ldd r24,Z+5
 8172 268c 9681      		ldd r25,Z+6
 8173 268e F801      		movw r30,r16
 8174 2690 9383      		std Z+3,r25
 8175 2692 8283      		std Z+2,r24
4624:ff.c          **** 				res = dir_sdi(dp, 0);			/* Rewind directory */
 8176               		.loc 1 4624 0
 8177 2694 C801      		movw r24,r16
 8178 2696 0E94 0000 		call dir_sdi.constprop.15
 8179               	.LVL769:
4625:ff.c          **** #if FF_FS_LOCK != 0
4626:ff.c          **** 				if (res == FR_OK) {
4627:ff.c          **** 					if (dp->obj.sclust != 0) {
4628:ff.c          **** 						dp->obj.lockid = inc_lock(dp, 0);	/* Lock the sub directory */
4629:ff.c          **** 						if (!dp->obj.lockid) res = FR_TOO_MANY_OPEN_FILES;
4630:ff.c          **** 					} else {
4631:ff.c          **** 						dp->obj.lockid = 0;	/* Root directory need not to be locked */
4632:ff.c          **** 					}
4633:ff.c          **** 				}
4634:ff.c          **** #endif
4635:ff.c          **** 			}
4636:ff.c          **** 		}
4637:ff.c          **** 		FREE_NAMBUF();
4638:ff.c          **** 		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8180               		.loc 1 4638 0
 8181 269a 8430      		cpi r24,lo8(4)
 8182 269c 01F4      		brne .L579
 8183               	.LVL770:
 8184               	.L582:
4619:ff.c          **** 				}
 8185               		.loc 1 4619 0
 8186 269e 85E0      		ldi r24,lo8(5)
 8187               	.L578:
 8188               	.LVL771:
4639:ff.c          **** 	}
4640:ff.c          **** 	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8189               		.loc 1 4640 0 discriminator 1
 8190 26a0 F801      		movw r30,r16
 8191 26a2 1182      		std Z+1,__zero_reg__
 8192 26a4 1082      		st Z,__zero_reg__
 8193 26a6 00C0      		rjmp .L587
 8194               	.LVL772:
 8195               	.L581:
4596:ff.c          **** 
 8196               		.loc 1 4596 0
 8197 26a8 89E0      		ldi r24,lo8(9)
 8198               	.LVL773:
 8199 26aa 00C0      		rjmp .L587
 8200               	.LVL774:
 8201               	.L579:
 8202               		.loc 1 4640 0
 8203 26ac 8111      		cpse r24,__zero_reg__
 8204 26ae 00C0      		rjmp .L578
 8205 26b0 80E0      		ldi r24,0
 8206               	.LVL775:
 8207 26b2 00C0      		rjmp .L587
 8208               	.LVL776:
 8209               	.L576:
4638:ff.c          **** 	}
 8210               		.loc 1 4638 0
 8211 26b4 8430      		cpi r24,lo8(4)
 8212 26b6 01F0      		breq .L582
 8213 26b8 00C0      		rjmp .L578
 8214               	.LVL777:
 8215               	.L587:
 8216               	/* epilogue start */
4641:ff.c          **** 
4642:ff.c          **** 	LEAVE_FF(fs, res);
4643:ff.c          **** }
 8217               		.loc 1 4643 0
 8218 26ba 0F90      		pop __tmp_reg__
 8219 26bc 0F90      		pop __tmp_reg__
 8220 26be 0F90      		pop __tmp_reg__
 8221 26c0 0F90      		pop __tmp_reg__
 8222 26c2 DF91      		pop r29
 8223 26c4 CF91      		pop r28
 8224               	.LVL778:
 8225 26c6 1F91      		pop r17
 8226               	.LVL779:
 8227 26c8 0F91      		pop r16
 8228               	.LVL780:
 8229 26ca 0895      		ret
 8230               		.cfi_endproc
 8231               	.LFE43:
 8233               	.global	f_closedir
 8235               	f_closedir:
 8236               	.LFB44:
4644:ff.c          **** 
4645:ff.c          **** 
4646:ff.c          **** 
4647:ff.c          **** 
4648:ff.c          **** /*-----------------------------------------------------------------------*/
4649:ff.c          **** /* Close Directory                                                       */
4650:ff.c          **** /*-----------------------------------------------------------------------*/
4651:ff.c          **** 
4652:ff.c          **** FRESULT f_closedir (
4653:ff.c          **** 	DIR *dp		/* Pointer to the directory object to be closed */
4654:ff.c          **** )
4655:ff.c          **** {
 8237               		.loc 1 4655 0
 8238               		.cfi_startproc
 8239               	.LVL781:
 8240 26cc 0F93      		push r16
 8241               	.LCFI279:
 8242               		.cfi_def_cfa_offset 3
 8243               		.cfi_offset 16, -2
 8244 26ce 1F93      		push r17
 8245               	.LCFI280:
 8246               		.cfi_def_cfa_offset 4
 8247               		.cfi_offset 17, -3
 8248 26d0 CF93      		push r28
 8249               	.LCFI281:
 8250               		.cfi_def_cfa_offset 5
 8251               		.cfi_offset 28, -4
 8252 26d2 DF93      		push r29
 8253               	.LCFI282:
 8254               		.cfi_def_cfa_offset 6
 8255               		.cfi_offset 29, -5
 8256 26d4 00D0      		rcall .
 8257               	.LCFI283:
 8258               		.cfi_def_cfa_offset 8
 8259 26d6 CDB7      		in r28,__SP_L__
 8260 26d8 DEB7      		in r29,__SP_H__
 8261               	.LCFI284:
 8262               		.cfi_def_cfa_register 28
 8263               	/* prologue: function */
 8264               	/* frame size = 2 */
 8265               	/* stack size = 6 */
 8266               	.L__stack_usage = 6
 8267 26da 8C01      		movw r16,r24
4656:ff.c          **** 	FRESULT res;
4657:ff.c          **** 	FATFS *fs;
4658:ff.c          **** 
4659:ff.c          **** 
4660:ff.c          **** 	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 8268               		.loc 1 4660 0
 8269 26dc BE01      		movw r22,r28
 8270 26de 6F5F      		subi r22,-1
 8271 26e0 7F4F      		sbci r23,-1
 8272 26e2 0E94 0000 		call validate
 8273               	.LVL782:
4661:ff.c          **** 	if (res == FR_OK) {
 8274               		.loc 1 4661 0
 8275 26e6 8111      		cpse r24,__zero_reg__
 8276 26e8 00C0      		rjmp .L589
4662:ff.c          **** #if FF_FS_LOCK != 0
4663:ff.c          **** 		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
4664:ff.c          **** 		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
4665:ff.c          **** #else
4666:ff.c          **** 		dp->obj.fs = 0;	/* Invalidate directory object */
 8277               		.loc 1 4666 0
 8278 26ea F801      		movw r30,r16
 8279 26ec 1182      		std Z+1,__zero_reg__
 8280 26ee 1082      		st Z,__zero_reg__
 8281               	.L589:
 8282               	/* epilogue start */
4667:ff.c          **** #endif
4668:ff.c          **** #if FF_FS_REENTRANT
4669:ff.c          **** 		unlock_fs(fs, FR_OK);		/* Unlock volume */
4670:ff.c          **** #endif
4671:ff.c          **** 	}
4672:ff.c          **** 	return res;
4673:ff.c          **** }
 8283               		.loc 1 4673 0
 8284 26f0 0F90      		pop __tmp_reg__
 8285 26f2 0F90      		pop __tmp_reg__
 8286 26f4 DF91      		pop r29
 8287 26f6 CF91      		pop r28
 8288 26f8 1F91      		pop r17
 8289 26fa 0F91      		pop r16
 8290               	.LVL783:
 8291 26fc 0895      		ret
 8292               		.cfi_endproc
 8293               	.LFE44:
 8295               	.global	f_readdir
 8297               	f_readdir:
 8298               	.LFB45:
4674:ff.c          **** 
4675:ff.c          **** 
4676:ff.c          **** 
4677:ff.c          **** 
4678:ff.c          **** /*-----------------------------------------------------------------------*/
4679:ff.c          **** /* Read Directory Entries in Sequence                                    */
4680:ff.c          **** /*-----------------------------------------------------------------------*/
4681:ff.c          **** 
4682:ff.c          **** FRESULT f_readdir (
4683:ff.c          **** 	DIR* dp,			/* Pointer to the open directory object */
4684:ff.c          **** 	FILINFO* fno		/* Pointer to file information to return */
4685:ff.c          **** )
4686:ff.c          **** {
 8299               		.loc 1 4686 0
 8300               		.cfi_startproc
 8301               	.LVL784:
 8302 26fe CF92      		push r12
 8303               	.LCFI285:
 8304               		.cfi_def_cfa_offset 3
 8305               		.cfi_offset 12, -2
 8306 2700 DF92      		push r13
 8307               	.LCFI286:
 8308               		.cfi_def_cfa_offset 4
 8309               		.cfi_offset 13, -3
 8310 2702 FF92      		push r15
 8311               	.LCFI287:
 8312               		.cfi_def_cfa_offset 5
 8313               		.cfi_offset 15, -4
 8314 2704 0F93      		push r16
 8315               	.LCFI288:
 8316               		.cfi_def_cfa_offset 6
 8317               		.cfi_offset 16, -5
 8318 2706 1F93      		push r17
 8319               	.LCFI289:
 8320               		.cfi_def_cfa_offset 7
 8321               		.cfi_offset 17, -6
 8322 2708 CF93      		push r28
 8323               	.LCFI290:
 8324               		.cfi_def_cfa_offset 8
 8325               		.cfi_offset 28, -7
 8326 270a DF93      		push r29
 8327               	.LCFI291:
 8328               		.cfi_def_cfa_offset 9
 8329               		.cfi_offset 29, -8
 8330 270c 00D0      		rcall .
 8331               	.LCFI292:
 8332               		.cfi_def_cfa_offset 11
 8333 270e CDB7      		in r28,__SP_L__
 8334 2710 DEB7      		in r29,__SP_H__
 8335               	.LCFI293:
 8336               		.cfi_def_cfa_register 28
 8337               	/* prologue: function */
 8338               	/* frame size = 2 */
 8339               	/* stack size = 9 */
 8340               	.L__stack_usage = 9
 8341 2712 8C01      		movw r16,r24
 8342 2714 6B01      		movw r12,r22
4687:ff.c          **** 	FRESULT res;
4688:ff.c          **** 	FATFS *fs;
4689:ff.c          **** 	DEF_NAMBUF
4690:ff.c          **** 
4691:ff.c          **** 
4692:ff.c          **** 	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8343               		.loc 1 4692 0
 8344 2716 BE01      		movw r22,r28
 8345               	.LVL785:
 8346 2718 6F5F      		subi r22,-1
 8347 271a 7F4F      		sbci r23,-1
 8348 271c 0E94 0000 		call validate
 8349               	.LVL786:
 8350 2720 F82E      		mov r15,r24
 8351               	.LVL787:
4693:ff.c          **** 	if (res == FR_OK) {
 8352               		.loc 1 4693 0
 8353 2722 8111      		cpse r24,__zero_reg__
 8354 2724 00C0      		rjmp .L591
4694:ff.c          **** 		if (!fno) {
4695:ff.c          **** 			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8355               		.loc 1 4695 0
 8356 2726 C801      		movw r24,r16
4694:ff.c          **** 		if (!fno) {
 8357               		.loc 1 4694 0
 8358 2728 C114      		cp r12,__zero_reg__
 8359 272a D104      		cpc r13,__zero_reg__
 8360 272c 01F4      		brne .L592
 8361               		.loc 1 4695 0
 8362 272e 0E94 0000 		call dir_sdi.constprop.15
 8363               	.LVL788:
 8364 2732 00C0      		rjmp .L595
 8365               	.L592:
4696:ff.c          **** 		} else {
4697:ff.c          **** 			INIT_NAMBUF(fs);
4698:ff.c          **** 			res = DIR_READ_FILE(dp);		/* Read an item */
 8366               		.loc 1 4698 0
 8367 2734 0E94 0000 		call dir_read.constprop.13
 8368               	.LVL789:
4699:ff.c          **** 			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
4700:ff.c          **** 			if (res == FR_OK) {				/* A valid entry is found */
 8369               		.loc 1 4700 0
 8370 2738 982F      		mov r25,r24
 8371 273a 9B7F      		andi r25,lo8(-5)
 8372 273c 01F4      		brne .L595
 8373               	.LVL790:
 8374               	.LBB336:
 8375               	.LBB337:
2690:ff.c          **** 	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 8376               		.loc 1 2690 0
 8377 273e F601      		movw r30,r12
 8378 2740 1186      		std Z+9,__zero_reg__
2691:ff.c          **** 
 8379               		.loc 1 2691 0
 8380 2742 F801      		movw r30,r16
 8381 2744 8689      		ldd r24,Z+22
 8382 2746 9789      		ldd r25,Z+23
 8383 2748 A08D      		ldd r26,Z+24
 8384 274a B18D      		ldd r27,Z+25
 8385 274c 892B      		or r24,r25
 8386 274e 8A2B      		or r24,r26
 8387 2750 8B2B      		or r24,r27
 8388 2752 01F0      		breq .L593
 8389 2754 B601      		movw r22,r12
 8390 2756 C801      		movw r24,r16
 8391 2758 0E94 0000 		call get_fileinfo.part.5
 8392               	.LVL791:
 8393               	.L593:
 8394               	.LBE337:
 8395               	.LBE336:
4701:ff.c          **** 				get_fileinfo(dp, fno);		/* Get the object information */
4702:ff.c          **** 				res = dir_next(dp, 0);		/* Increment index for next */
 8396               		.loc 1 4702 0
 8397 275c 60E0      		ldi r22,0
 8398 275e 70E0      		ldi r23,0
 8399 2760 C801      		movw r24,r16
 8400 2762 0E94 0000 		call dir_next
 8401               	.LVL792:
4703:ff.c          **** 				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8402               		.loc 1 4703 0
 8403 2766 8430      		cpi r24,lo8(4)
 8404 2768 01F0      		breq .L591
 8405               	.LVL793:
 8406               	.L595:
 8407 276a F82E      		mov r15,r24
 8408               	.L591:
 8409               	.LVL794:
4704:ff.c          **** 			}
4705:ff.c          **** 			FREE_NAMBUF();
4706:ff.c          **** 		}
4707:ff.c          **** 	}
4708:ff.c          **** 	LEAVE_FF(fs, res);
4709:ff.c          **** }
 8410               		.loc 1 4709 0
 8411 276c 8F2D      		mov r24,r15
 8412               	/* epilogue start */
 8413 276e 0F90      		pop __tmp_reg__
 8414 2770 0F90      		pop __tmp_reg__
 8415 2772 DF91      		pop r29
 8416 2774 CF91      		pop r28
 8417 2776 1F91      		pop r17
 8418 2778 0F91      		pop r16
 8419               	.LVL795:
 8420 277a FF90      		pop r15
 8421               	.LVL796:
 8422 277c DF90      		pop r13
 8423 277e CF90      		pop r12
 8424               	.LVL797:
 8425 2780 0895      		ret
 8426               		.cfi_endproc
 8427               	.LFE45:
 8429               	.global	f_stat
 8431               	f_stat:
 8432               	.LFB46:
4710:ff.c          **** 
4711:ff.c          **** 
4712:ff.c          **** 
4713:ff.c          **** #if FF_USE_FIND
4714:ff.c          **** /*-----------------------------------------------------------------------*/
4715:ff.c          **** /* Find Next File                                                        */
4716:ff.c          **** /*-----------------------------------------------------------------------*/
4717:ff.c          **** 
4718:ff.c          **** FRESULT f_findnext (
4719:ff.c          **** 	DIR* dp,		/* Pointer to the open directory object */
4720:ff.c          **** 	FILINFO* fno	/* Pointer to the file information structure */
4721:ff.c          **** )
4722:ff.c          **** {
4723:ff.c          **** 	FRESULT res;
4724:ff.c          **** 
4725:ff.c          **** 
4726:ff.c          **** 	for (;;) {
4727:ff.c          **** 		res = f_readdir(dp, fno);		/* Get a directory item */
4728:ff.c          **** 		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory 
4729:ff.c          **** 		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
4730:ff.c          **** #if FF_USE_LFN && FF_USE_FIND == 2
4731:ff.c          **** 		if (pattern_match(dp->pat, fno->altname, 0, FIND_RECURS)) break;	/* Test for alternative name if 
4732:ff.c          **** #endif
4733:ff.c          **** 	}
4734:ff.c          **** 	return res;
4735:ff.c          **** }
4736:ff.c          **** 
4737:ff.c          **** 
4738:ff.c          **** 
4739:ff.c          **** /*-----------------------------------------------------------------------*/
4740:ff.c          **** /* Find First File                                                       */
4741:ff.c          **** /*-----------------------------------------------------------------------*/
4742:ff.c          **** 
4743:ff.c          **** FRESULT f_findfirst (
4744:ff.c          **** 	DIR* dp,				/* Pointer to the blank directory object */
4745:ff.c          **** 	FILINFO* fno,			/* Pointer to the file information structure */
4746:ff.c          **** 	const TCHAR* path,		/* Pointer to the directory to open */
4747:ff.c          **** 	const TCHAR* pattern	/* Pointer to the matching pattern */
4748:ff.c          **** )
4749:ff.c          **** {
4750:ff.c          **** 	FRESULT res;
4751:ff.c          **** 
4752:ff.c          **** 
4753:ff.c          **** 	dp->pat = pattern;		/* Save pointer to pattern string */
4754:ff.c          **** 	res = f_opendir(dp, path);		/* Open the target directory */
4755:ff.c          **** 	if (res == FR_OK) {
4756:ff.c          **** 		res = f_findnext(dp, fno);	/* Find the first item */
4757:ff.c          **** 	}
4758:ff.c          **** 	return res;
4759:ff.c          **** }
4760:ff.c          **** 
4761:ff.c          **** #endif	/* FF_USE_FIND */
4762:ff.c          **** 
4763:ff.c          **** 
4764:ff.c          **** 
4765:ff.c          **** #if FF_FS_MINIMIZE == 0
4766:ff.c          **** /*-----------------------------------------------------------------------*/
4767:ff.c          **** /* Get File Status                                                       */
4768:ff.c          **** /*-----------------------------------------------------------------------*/
4769:ff.c          **** 
4770:ff.c          **** FRESULT f_stat (
4771:ff.c          **** 	const TCHAR* path,	/* Pointer to the file path */
4772:ff.c          **** 	FILINFO* fno		/* Pointer to file information to return */
4773:ff.c          **** )
4774:ff.c          **** {
 8433               		.loc 1 4774 0
 8434               		.cfi_startproc
 8435               	.LVL798:
 8436 2782 EF92      		push r14
 8437               	.LCFI294:
 8438               		.cfi_def_cfa_offset 3
 8439               		.cfi_offset 14, -2
 8440 2784 FF92      		push r15
 8441               	.LCFI295:
 8442               		.cfi_def_cfa_offset 4
 8443               		.cfi_offset 15, -3
 8444 2786 1F93      		push r17
 8445               	.LCFI296:
 8446               		.cfi_def_cfa_offset 5
 8447               		.cfi_offset 17, -4
 8448 2788 CF93      		push r28
 8449               	.LCFI297:
 8450               		.cfi_def_cfa_offset 6
 8451               		.cfi_offset 28, -5
 8452 278a DF93      		push r29
 8453               	.LCFI298:
 8454               		.cfi_def_cfa_offset 7
 8455               		.cfi_offset 29, -6
 8456 278c CDB7      		in r28,__SP_L__
 8457 278e DEB7      		in r29,__SP_H__
 8458               	.LCFI299:
 8459               		.cfi_def_cfa_register 28
 8460 2790 AA97      		sbiw r28,42
 8461               	.LCFI300:
 8462               		.cfi_def_cfa_offset 49
 8463 2792 0FB6      		in __tmp_reg__,__SREG__
 8464 2794 F894      		cli
 8465 2796 DEBF      		out __SP_H__,r29
 8466 2798 0FBE      		out __SREG__,__tmp_reg__
 8467 279a CDBF      		out __SP_L__,r28
 8468               	/* prologue: function */
 8469               	/* frame size = 42 */
 8470               	/* stack size = 47 */
 8471               	.L__stack_usage = 47
 8472 279c 9AA7      		std Y+42,r25
 8473 279e 89A7      		std Y+41,r24
 8474 27a0 7B01      		movw r14,r22
4775:ff.c          **** 	FRESULT res;
4776:ff.c          **** 	DIR dj;
4777:ff.c          **** 	DEF_NAMBUF
4778:ff.c          **** 
4779:ff.c          **** 
4780:ff.c          **** 	/* Get logical drive */
4781:ff.c          **** 	res = mount_volume(&path, &dj.obj.fs, 0);
 8475               		.loc 1 4781 0
 8476 27a2 40E0      		ldi r20,0
 8477 27a4 BE01      		movw r22,r28
 8478               	.LVL799:
 8479 27a6 6F5F      		subi r22,-1
 8480 27a8 7F4F      		sbci r23,-1
 8481 27aa CE01      		movw r24,r28
 8482               	.LVL800:
 8483 27ac 8996      		adiw r24,41
 8484 27ae 0E94 0000 		call mount_volume
 8485               	.LVL801:
 8486 27b2 182F      		mov r17,r24
 8487               	.LVL802:
4782:ff.c          **** 	if (res == FR_OK) {
 8488               		.loc 1 4782 0
 8489 27b4 8111      		cpse r24,__zero_reg__
 8490 27b6 00C0      		rjmp .L600
4783:ff.c          **** 		INIT_NAMBUF(dj.obj.fs);
4784:ff.c          **** 		res = follow_path(&dj, path);	/* Follow the file path */
 8491               		.loc 1 4784 0
 8492 27b8 69A5      		ldd r22,Y+41
 8493 27ba 7AA5      		ldd r23,Y+42
 8494 27bc CE01      		movw r24,r28
 8495 27be 0196      		adiw r24,1
 8496 27c0 0E94 0000 		call follow_path
 8497               	.LVL803:
 8498 27c4 182F      		mov r17,r24
 8499               	.LVL804:
4785:ff.c          **** 		if (res == FR_OK) {				/* Follow completed */
 8500               		.loc 1 4785 0
 8501 27c6 8111      		cpse r24,__zero_reg__
 8502 27c8 00C0      		rjmp .L600
4786:ff.c          **** 			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
 8503               		.loc 1 4786 0
 8504 27ca 88A5      		ldd r24,Y+40
 8505 27cc 87FD      		sbrc r24,7
 8506 27ce 00C0      		rjmp .L603
4787:ff.c          **** 				res = FR_INVALID_NAME;
4788:ff.c          **** 			} else {							/* Found an object */
4789:ff.c          **** 				if (fno) get_fileinfo(&dj, fno);
 8507               		.loc 1 4789 0
 8508 27d0 E114      		cp r14,__zero_reg__
 8509 27d2 F104      		cpc r15,__zero_reg__
 8510 27d4 01F0      		breq .L600
 8511               	.LVL805:
 8512               	.LBB340:
 8513               	.LBB341:
2690:ff.c          **** 	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 8514               		.loc 1 2690 0
 8515 27d6 F701      		movw r30,r14
 8516 27d8 1186      		std Z+9,__zero_reg__
2691:ff.c          **** 
 8517               		.loc 1 2691 0
 8518 27da 8F89      		ldd r24,Y+23
 8519 27dc 988D      		ldd r25,Y+24
 8520 27de A98D      		ldd r26,Y+25
 8521 27e0 BA8D      		ldd r27,Y+26
 8522 27e2 892B      		or r24,r25
 8523 27e4 8A2B      		or r24,r26
 8524 27e6 8B2B      		or r24,r27
 8525 27e8 01F0      		breq .L600
 8526 27ea B701      		movw r22,r14
 8527 27ec CE01      		movw r24,r28
 8528 27ee 0196      		adiw r24,1
 8529 27f0 0E94 0000 		call get_fileinfo.part.5
 8530               	.LVL806:
 8531 27f4 00C0      		rjmp .L600
 8532               	.LVL807:
 8533               	.L603:
 8534               	.LBE341:
 8535               	.LBE340:
4787:ff.c          **** 				res = FR_INVALID_NAME;
 8536               		.loc 1 4787 0
 8537 27f6 16E0      		ldi r17,lo8(6)
 8538               	.LVL808:
 8539               	.L600:
4790:ff.c          **** 			}
4791:ff.c          **** 		}
4792:ff.c          **** 		FREE_NAMBUF();
4793:ff.c          **** 	}
4794:ff.c          **** 
4795:ff.c          **** 	LEAVE_FF(dj.obj.fs, res);
4796:ff.c          **** }
 8540               		.loc 1 4796 0
 8541 27f8 812F      		mov r24,r17
 8542               	/* epilogue start */
 8543 27fa AA96      		adiw r28,42
 8544 27fc 0FB6      		in __tmp_reg__,__SREG__
 8545 27fe F894      		cli
 8546 2800 DEBF      		out __SP_H__,r29
 8547 2802 0FBE      		out __SREG__,__tmp_reg__
 8548 2804 CDBF      		out __SP_L__,r28
 8549 2806 DF91      		pop r29
 8550 2808 CF91      		pop r28
 8551 280a 1F91      		pop r17
 8552               	.LVL809:
 8553 280c FF90      		pop r15
 8554 280e EF90      		pop r14
 8555               	.LVL810:
 8556 2810 0895      		ret
 8557               		.cfi_endproc
 8558               	.LFE46:
 8560               	.global	f_getfree
 8562               	f_getfree:
 8563               	.LFB47:
4797:ff.c          **** 
4798:ff.c          **** 
4799:ff.c          **** 
4800:ff.c          **** #if !FF_FS_READONLY
4801:ff.c          **** /*-----------------------------------------------------------------------*/
4802:ff.c          **** /* Get Number of Free Clusters                                           */
4803:ff.c          **** /*-----------------------------------------------------------------------*/
4804:ff.c          **** 
4805:ff.c          **** FRESULT f_getfree (
4806:ff.c          **** 	const TCHAR* path,	/* Logical drive number */
4807:ff.c          **** 	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
4808:ff.c          **** 	FATFS** fatfs		/* Pointer to return pointer to corresponding filesystem object */
4809:ff.c          **** )
4810:ff.c          **** {
 8564               		.loc 1 4810 0
 8565               		.cfi_startproc
 8566               	.LVL811:
 8567 2812 2F92      		push r2
 8568               	.LCFI301:
 8569               		.cfi_def_cfa_offset 3
 8570               		.cfi_offset 2, -2
 8571 2814 3F92      		push r3
 8572               	.LCFI302:
 8573               		.cfi_def_cfa_offset 4
 8574               		.cfi_offset 3, -3
 8575 2816 4F92      		push r4
 8576               	.LCFI303:
 8577               		.cfi_def_cfa_offset 5
 8578               		.cfi_offset 4, -4
 8579 2818 5F92      		push r5
 8580               	.LCFI304:
 8581               		.cfi_def_cfa_offset 6
 8582               		.cfi_offset 5, -5
 8583 281a 6F92      		push r6
 8584               	.LCFI305:
 8585               		.cfi_def_cfa_offset 7
 8586               		.cfi_offset 6, -6
 8587 281c 7F92      		push r7
 8588               	.LCFI306:
 8589               		.cfi_def_cfa_offset 8
 8590               		.cfi_offset 7, -7
 8591 281e 8F92      		push r8
 8592               	.LCFI307:
 8593               		.cfi_def_cfa_offset 9
 8594               		.cfi_offset 8, -8
 8595 2820 9F92      		push r9
 8596               	.LCFI308:
 8597               		.cfi_def_cfa_offset 10
 8598               		.cfi_offset 9, -9
 8599 2822 AF92      		push r10
 8600               	.LCFI309:
 8601               		.cfi_def_cfa_offset 11
 8602               		.cfi_offset 10, -10
 8603 2824 BF92      		push r11
 8604               	.LCFI310:
 8605               		.cfi_def_cfa_offset 12
 8606               		.cfi_offset 11, -11
 8607 2826 CF92      		push r12
 8608               	.LCFI311:
 8609               		.cfi_def_cfa_offset 13
 8610               		.cfi_offset 12, -12
 8611 2828 DF92      		push r13
 8612               	.LCFI312:
 8613               		.cfi_def_cfa_offset 14
 8614               		.cfi_offset 13, -13
 8615 282a EF92      		push r14
 8616               	.LCFI313:
 8617               		.cfi_def_cfa_offset 15
 8618               		.cfi_offset 14, -14
 8619 282c FF92      		push r15
 8620               	.LCFI314:
 8621               		.cfi_def_cfa_offset 16
 8622               		.cfi_offset 15, -15
 8623 282e 0F93      		push r16
 8624               	.LCFI315:
 8625               		.cfi_def_cfa_offset 17
 8626               		.cfi_offset 16, -16
 8627 2830 1F93      		push r17
 8628               	.LCFI316:
 8629               		.cfi_def_cfa_offset 18
 8630               		.cfi_offset 17, -17
 8631 2832 CF93      		push r28
 8632               	.LCFI317:
 8633               		.cfi_def_cfa_offset 19
 8634               		.cfi_offset 28, -18
 8635 2834 DF93      		push r29
 8636               	.LCFI318:
 8637               		.cfi_def_cfa_offset 20
 8638               		.cfi_offset 29, -19
 8639 2836 CDB7      		in r28,__SP_L__
 8640 2838 DEB7      		in r29,__SP_H__
 8641               	.LCFI319:
 8642               		.cfi_def_cfa_register 28
 8643 283a 2997      		sbiw r28,9
 8644               	.LCFI320:
 8645               		.cfi_def_cfa_offset 29
 8646 283c 0FB6      		in __tmp_reg__,__SREG__
 8647 283e F894      		cli
 8648 2840 DEBF      		out __SP_H__,r29
 8649 2842 0FBE      		out __SREG__,__tmp_reg__
 8650 2844 CDBF      		out __SP_L__,r28
 8651               	/* prologue: function */
 8652               	/* frame size = 9 */
 8653               	/* stack size = 27 */
 8654               	.L__stack_usage = 27
 8655 2846 9C83      		std Y+4,r25
 8656 2848 8B83      		std Y+3,r24
 8657 284a 1B01      		movw r2,r22
 8658 284c 7A01      		movw r14,r20
4811:ff.c          **** 	FRESULT res;
4812:ff.c          **** 	FATFS *fs;
4813:ff.c          **** 	DWORD nfree, clst, stat;
4814:ff.c          **** 	LBA_t sect;
4815:ff.c          **** 	UINT i;
4816:ff.c          **** 	FFOBJID obj;
4817:ff.c          **** 
4818:ff.c          **** 
4819:ff.c          **** 	/* Get logical drive */
4820:ff.c          **** 	res = mount_volume(&path, &fs, 0);
 8659               		.loc 1 4820 0
 8660 284e 40E0      		ldi r20,0
 8661               	.LVL812:
 8662 2850 BE01      		movw r22,r28
 8663               	.LVL813:
 8664 2852 6F5F      		subi r22,-1
 8665 2854 7F4F      		sbci r23,-1
 8666 2856 CE01      		movw r24,r28
 8667               	.LVL814:
 8668 2858 0396      		adiw r24,3
 8669 285a 0E94 0000 		call mount_volume
 8670               	.LVL815:
 8671 285e 8D83      		std Y+5,r24
 8672               	.LVL816:
4821:ff.c          **** 	if (res == FR_OK) {
 8673               		.loc 1 4821 0
 8674 2860 8111      		cpse r24,__zero_reg__
 8675 2862 00C0      		rjmp .L608
4822:ff.c          **** 		*fatfs = fs;				/* Return ptr to the fs object */
 8676               		.loc 1 4822 0
 8677 2864 0981      		ldd r16,Y+1
 8678 2866 1A81      		ldd r17,Y+2
 8679 2868 D701      		movw r26,r14
 8680 286a 0D93      		st X+,r16
 8681 286c 1C93      		st X,r17
4823:ff.c          **** 		/* If free_clst is valid, return it without full FAT scan */
4824:ff.c          **** 		if (fs->free_clst <= fs->n_fatent - 2) {
 8682               		.loc 1 4824 0
 8683 286e F801      		movw r30,r16
 8684 2870 8785      		ldd r24,Z+15
 8685 2872 9089      		ldd r25,Z+16
 8686 2874 A189      		ldd r26,Z+17
 8687 2876 B289      		ldd r27,Z+18
 8688               	.LVL817:
 8689 2878 4388      		ldd r4,Z+19
 8690 287a 5488      		ldd r5,Z+20
 8691 287c 6588      		ldd r6,Z+21
 8692 287e 7688      		ldd r7,Z+22
 8693 2880 B301      		movw r22,r6
 8694 2882 A201      		movw r20,r4
 8695 2884 4250      		subi r20,2
 8696 2886 5109      		sbc r21,__zero_reg__
 8697 2888 6109      		sbc r22,__zero_reg__
 8698 288a 7109      		sbc r23,__zero_reg__
 8699 288c 4817      		cp r20,r24
 8700 288e 5907      		cpc r21,r25
 8701 2890 6A07      		cpc r22,r26
 8702 2892 7B07      		cpc r23,r27
 8703 2894 00F0      		brlo .L609
4825:ff.c          **** 			*nclst = fs->free_clst;
 8704               		.loc 1 4825 0
 8705 2896 F101      		movw r30,r2
 8706 2898 8083      		st Z,r24
 8707 289a 9183      		std Z+1,r25
 8708 289c A283      		std Z+2,r26
 8709 289e B383      		std Z+3,r27
 8710 28a0 00C0      		rjmp .L608
 8711               	.L609:
 8712               	.LVL818:
4826:ff.c          **** 		} else {
4827:ff.c          **** 			/* Scan FAT to obtain number of free clusters */
4828:ff.c          **** 			nfree = 0;
4829:ff.c          **** 			if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
 8713               		.loc 1 4829 0
 8714 28a2 8081      		ld r24,Z
 8715 28a4 8130      		cpi r24,lo8(1)
 8716 28a6 01F4      		brne .L610
 8717 28a8 82E0      		ldi r24,lo8(2)
 8718 28aa 482E      		mov r4,r24
 8719 28ac 512C      		mov r5,__zero_reg__
 8720 28ae 612C      		mov r6,__zero_reg__
 8721 28b0 712C      		mov r7,__zero_reg__
 8722 28b2 C12C      		mov r12,__zero_reg__
 8723 28b4 D12C      		mov r13,__zero_reg__
 8724 28b6 7601      		movw r14,r12
 8725               	.LVL819:
 8726               	.L613:
4830:ff.c          **** 				clst = 2; obj.fs = fs;
4831:ff.c          **** 				do {
4832:ff.c          **** 					stat = get_fat(&obj, clst);
 8727               		.loc 1 4832 0
 8728 28b8 B301      		movw r22,r6
 8729 28ba A201      		movw r20,r4
 8730 28bc C801      		movw r24,r16
 8731 28be 0E94 0000 		call get_fat.isra.10
 8732               	.LVL820:
4833:ff.c          **** 					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 8733               		.loc 1 4833 0
 8734 28c2 6F3F      		cpi r22,-1
 8735 28c4 BFEF      		ldi r27,-1
 8736 28c6 7B07      		cpc r23,r27
 8737 28c8 8B07      		cpc r24,r27
 8738 28ca 9B07      		cpc r25,r27
 8739 28cc 01F4      		brne .+2
 8740 28ce 00C0      		rjmp .L620
4834:ff.c          **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 8741               		.loc 1 4834 0
 8742 28d0 6130      		cpi r22,1
 8743 28d2 7105      		cpc r23,__zero_reg__
 8744 28d4 8105      		cpc r24,__zero_reg__
 8745 28d6 9105      		cpc r25,__zero_reg__
 8746 28d8 01F4      		brne .+2
 8747 28da 00C0      		rjmp .L621
4835:ff.c          **** 					if (stat == 0) nfree++;
 8748               		.loc 1 4835 0
 8749 28dc 672B      		or r22,r23
 8750 28de 682B      		or r22,r24
 8751 28e0 692B      		or r22,r25
 8752 28e2 01F4      		brne .L612
 8753               		.loc 1 4835 0 is_stmt 0 discriminator 1
 8754 28e4 EFEF      		ldi r30,-1
 8755 28e6 CE1A      		sub r12,r30
 8756 28e8 DE0A      		sbc r13,r30
 8757 28ea EE0A      		sbc r14,r30
 8758 28ec FE0A      		sbc r15,r30
 8759               	.LVL821:
 8760               	.L612:
4836:ff.c          **** 				} while (++clst < fs->n_fatent);
 8761               		.loc 1 4836 0 is_stmt 1
 8762 28ee FFEF      		ldi r31,-1
 8763 28f0 4F1A      		sub r4,r31
 8764 28f2 5F0A      		sbc r5,r31
 8765 28f4 6F0A      		sbc r6,r31
 8766 28f6 7F0A      		sbc r7,r31
 8767               	.LVL822:
 8768 28f8 E981      		ldd r30,Y+1
 8769 28fa FA81      		ldd r31,Y+2
 8770 28fc 8389      		ldd r24,Z+19
 8771 28fe 9489      		ldd r25,Z+20
 8772 2900 A589      		ldd r26,Z+21
 8773 2902 B689      		ldd r27,Z+22
 8774 2904 4816      		cp r4,r24
 8775 2906 5906      		cpc r5,r25
 8776 2908 6A06      		cpc r6,r26
 8777 290a 7B06      		cpc r7,r27
 8778 290c 00F0      		brlo .L613
 8779 290e 00C0      		rjmp .L611
 8780               	.LVL823:
 8781               	.L610:
4837:ff.c          **** 			} else {
4838:ff.c          **** #if FF_FS_EXFAT
4839:ff.c          **** 				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan allocation bitmap */
4840:ff.c          **** 					BYTE bm;
4841:ff.c          **** 					UINT b;
4842:ff.c          **** 
4843:ff.c          **** 					clst = fs->n_fatent - 2;	/* Number of clusters */
4844:ff.c          **** 					sect = fs->bitbase;			/* Bitmap sector */
4845:ff.c          **** 					i = 0;						/* Offset in the sector */
4846:ff.c          **** 					do {	/* Counts numbuer of bits with zero in the bitmap */
4847:ff.c          **** 						if (i == 0) {
4848:ff.c          **** 							res = move_window(fs, sect++);
4849:ff.c          **** 							if (res != FR_OK) break;
4850:ff.c          **** 						}
4851:ff.c          **** 						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
4852:ff.c          **** 							if (!(bm & 1)) nfree++;
4853:ff.c          **** 							bm >>= 1;
4854:ff.c          **** 						}
4855:ff.c          **** 						i = (i + 1) % SS(fs);
4856:ff.c          **** 					} while (clst);
4857:ff.c          **** 				} else
4858:ff.c          **** #endif
4859:ff.c          **** 				{	/* FAT16/32: Scan WORD/DWORD FAT entries */
4860:ff.c          **** 					clst = fs->n_fatent;	/* Number of entries */
4861:ff.c          **** 					sect = fs->fatbase;		/* Top of the FAT */
 8782               		.loc 1 4861 0
 8783 2910 878C      		ldd r8,Z+31
 8784 2912 90A0      		ldd r9,Z+32
 8785 2914 A1A0      		ldd r10,Z+33
 8786 2916 B2A0      		ldd r11,Z+34
 8787               	.LVL824:
4862:ff.c          **** 					i = 0;					/* Offset in the sector */
 8788               		.loc 1 4862 0
 8789 2918 00E0      		ldi r16,0
 8790 291a 10E0      		ldi r17,0
4828:ff.c          **** 			if (fs->fs_type == FS_FAT12) {	/* FAT12: Scan bit field FAT entries */
 8791               		.loc 1 4828 0
 8792 291c C12C      		mov r12,__zero_reg__
 8793 291e D12C      		mov r13,__zero_reg__
 8794 2920 7601      		movw r14,r12
 8795               	.LVL825:
 8796               	.L619:
4863:ff.c          **** 					do {	/* Counts numbuer of entries with zero in the FAT */
4864:ff.c          **** 						if (i == 0) {
 8797               		.loc 1 4864 0
 8798 2922 0115      		cp r16,__zero_reg__
 8799 2924 1105      		cpc r17,__zero_reg__
 8800 2926 01F4      		brne .L614
 8801               	.LVL826:
4865:ff.c          **** 							res = move_window(fs, sect++);
 8802               		.loc 1 4865 0
 8803 2928 D501      		movw r26,r10
 8804 292a C401      		movw r24,r8
 8805 292c 0196      		adiw r24,1
 8806 292e A11D      		adc r26,__zero_reg__
 8807 2930 B11D      		adc r27,__zero_reg__
 8808 2932 8E83      		std Y+6,r24
 8809 2934 9F83      		std Y+7,r25
 8810 2936 A887      		std Y+8,r26
 8811 2938 B987      		std Y+9,r27
 8812               	.LVL827:
 8813 293a B501      		movw r22,r10
 8814 293c A401      		movw r20,r8
 8815 293e 8981      		ldd r24,Y+1
 8816 2940 9A81      		ldd r25,Y+2
 8817               	.LVL828:
 8818 2942 0E94 0000 		call move_window
 8819               	.LVL829:
4866:ff.c          **** 							if (res != FR_OK) break;
 8820               		.loc 1 4866 0
 8821 2946 8111      		cpse r24,__zero_reg__
 8822 2948 00C0      		rjmp .L622
4865:ff.c          **** 							res = move_window(fs, sect++);
 8823               		.loc 1 4865 0
 8824 294a 8E80      		ldd r8,Y+6
 8825 294c 9F80      		ldd r9,Y+7
 8826 294e A884      		ldd r10,Y+8
 8827 2950 B984      		ldd r11,Y+9
 8828               	.LVL830:
 8829               	.L614:
4867:ff.c          **** 						}
4868:ff.c          **** 						if (fs->fs_type == FS_FAT16) {
 8830               		.loc 1 4868 0
 8831 2952 E981      		ldd r30,Y+1
 8832 2954 FA81      		ldd r31,Y+2
 8833 2956 8081      		ld r24,Z
 8834 2958 8230      		cpi r24,lo8(2)
 8835 295a 01F4      		brne .L615
 8836               	.LBB342:
 8837               	.LBB343:
 615:ff.c          **** 	return rv;
 8838               		.loc 1 615 0
 8839 295c E00F      		add r30,r16
 8840 295e F11F      		adc r31,r17
 8841               	.LBE343:
 8842               	.LBE342:
4869:ff.c          **** 							if (ld_word(fs->win + i) == 0) nfree++;
 8843               		.loc 1 4869 0
 8844 2960 87A5      		ldd r24,Z+47
 8845 2962 90A9      		ldd r25,Z+48
 8846 2964 892B      		or r24,r25
 8847 2966 01F4      		brne .L616
 8848               		.loc 1 4869 0 is_stmt 0 discriminator 1
 8849 2968 9FEF      		ldi r25,-1
 8850 296a C91A      		sub r12,r25
 8851 296c D90A      		sbc r13,r25
 8852 296e E90A      		sbc r14,r25
 8853 2970 F90A      		sbc r15,r25
 8854               	.LVL831:
 8855               	.L616:
4870:ff.c          **** 							i += 2;
 8856               		.loc 1 4870 0 is_stmt 1
 8857 2972 0E5F      		subi r16,-2
 8858 2974 1F4F      		sbci r17,-1
 8859               	.LVL832:
 8860 2976 00C0      		rjmp .L617
 8861               	.LVL833:
 8862               	.L615:
4871:ff.c          **** 						} else {
4872:ff.c          **** 							if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
 8863               		.loc 1 4872 0
 8864 2978 CF01      		movw r24,r30
 8865 297a 8F96      		adiw r24,47
 8866 297c 800F      		add r24,r16
 8867 297e 911F      		adc r25,r17
 8868 2980 0E94 0000 		call ld_dword
 8869               	.LVL834:
 8870 2984 DC01      		movw r26,r24
 8871 2986 CB01      		movw r24,r22
 8872 2988 BF70      		andi r27,15
 8873 298a 892B      		or r24,r25
 8874 298c 8A2B      		or r24,r26
 8875 298e 8B2B      		or r24,r27
 8876 2990 01F4      		brne .L618
 8877               		.loc 1 4872 0 is_stmt 0 discriminator 1
 8878 2992 AFEF      		ldi r26,-1
 8879 2994 CA1A      		sub r12,r26
 8880 2996 DA0A      		sbc r13,r26
 8881 2998 EA0A      		sbc r14,r26
 8882 299a FA0A      		sbc r15,r26
 8883               	.LVL835:
 8884               	.L618:
4873:ff.c          **** 							i += 4;
 8885               		.loc 1 4873 0 is_stmt 1
 8886 299c 0C5F      		subi r16,-4
 8887 299e 1F4F      		sbci r17,-1
 8888               	.LVL836:
 8889               	.L617:
4874:ff.c          **** 						}
4875:ff.c          **** 						i %= SS(fs);
 8890               		.loc 1 4875 0
 8891 29a0 1170      		andi r17,1
 8892               	.LVL837:
4876:ff.c          **** 					} while (--clst);
 8893               		.loc 1 4876 0
 8894 29a2 B1E0      		ldi r27,1
 8895 29a4 4B1A      		sub r4,r27
 8896 29a6 5108      		sbc r5,__zero_reg__
 8897 29a8 6108      		sbc r6,__zero_reg__
 8898 29aa 7108      		sbc r7,__zero_reg__
 8899               	.LVL838:
 8900 29ac 01F0      		breq .+2
 8901 29ae 00C0      		rjmp .L619
 8902 29b0 00C0      		rjmp .L611
 8903               	.LVL839:
 8904               	.L620:
4833:ff.c          **** 					if (stat == 1) { res = FR_INT_ERR; break; }
 8905               		.loc 1 4833 0
 8906 29b2 E1E0      		ldi r30,lo8(1)
 8907 29b4 ED83      		std Y+5,r30
 8908               	.LVL840:
 8909 29b6 00C0      		rjmp .L611
 8910               	.LVL841:
 8911               	.L621:
4834:ff.c          **** 					if (stat == 0) nfree++;
 8912               		.loc 1 4834 0
 8913 29b8 F2E0      		ldi r31,lo8(2)
 8914 29ba FD83      		std Y+5,r31
 8915               	.LVL842:
 8916 29bc 00C0      		rjmp .L611
 8917               	.LVL843:
 8918               	.L622:
4865:ff.c          **** 							if (res != FR_OK) break;
 8919               		.loc 1 4865 0
 8920 29be 8D83      		std Y+5,r24
 8921               	.LVL844:
 8922               	.L611:
4877:ff.c          **** 				}
4878:ff.c          **** 			}
4879:ff.c          **** 			*nclst = nfree;			/* Return the free clusters */
 8923               		.loc 1 4879 0
 8924 29c0 D101      		movw r26,r2
 8925 29c2 CD92      		st X+,r12
 8926 29c4 DD92      		st X+,r13
 8927 29c6 ED92      		st X+,r14
 8928 29c8 FC92      		st X,r15
 8929 29ca 1397      		sbiw r26,3
4880:ff.c          **** 			fs->free_clst = nfree;	/* Now free_clst is valid */
 8930               		.loc 1 4880 0
 8931 29cc E981      		ldd r30,Y+1
 8932 29ce FA81      		ldd r31,Y+2
 8933 29d0 C786      		std Z+15,r12
 8934 29d2 D08A      		std Z+16,r13
 8935 29d4 E18A      		std Z+17,r14
 8936 29d6 F28A      		std Z+18,r15
4881:ff.c          **** 			fs->fsi_flag |= 1;		/* FAT32: FSInfo is to be updated */
 8937               		.loc 1 4881 0
 8938 29d8 8481      		ldd r24,Z+4
 8939 29da 8160      		ori r24,lo8(1)
 8940 29dc 8483      		std Z+4,r24
 8941               	.LVL845:
 8942               	.L608:
4882:ff.c          **** 		}
4883:ff.c          **** 	}
4884:ff.c          **** 
4885:ff.c          **** 	LEAVE_FF(fs, res);
4886:ff.c          **** }
 8943               		.loc 1 4886 0
 8944 29de 8D81      		ldd r24,Y+5
 8945               	/* epilogue start */
 8946 29e0 2996      		adiw r28,9
 8947 29e2 0FB6      		in __tmp_reg__,__SREG__
 8948 29e4 F894      		cli
 8949 29e6 DEBF      		out __SP_H__,r29
 8950 29e8 0FBE      		out __SREG__,__tmp_reg__
 8951 29ea CDBF      		out __SP_L__,r28
 8952 29ec DF91      		pop r29
 8953 29ee CF91      		pop r28
 8954 29f0 1F91      		pop r17
 8955 29f2 0F91      		pop r16
 8956 29f4 FF90      		pop r15
 8957 29f6 EF90      		pop r14
 8958               	.LVL846:
 8959 29f8 DF90      		pop r13
 8960 29fa CF90      		pop r12
 8961 29fc BF90      		pop r11
 8962 29fe AF90      		pop r10
 8963 2a00 9F90      		pop r9
 8964 2a02 8F90      		pop r8
 8965 2a04 7F90      		pop r7
 8966 2a06 6F90      		pop r6
 8967 2a08 5F90      		pop r5
 8968 2a0a 4F90      		pop r4
 8969 2a0c 3F90      		pop r3
 8970 2a0e 2F90      		pop r2
 8971               	.LVL847:
 8972 2a10 0895      		ret
 8973               		.cfi_endproc
 8974               	.LFE47:
 8976               	.global	f_truncate
 8978               	f_truncate:
 8979               	.LFB48:
4887:ff.c          **** 
4888:ff.c          **** 
4889:ff.c          **** 
4890:ff.c          **** 
4891:ff.c          **** /*-----------------------------------------------------------------------*/
4892:ff.c          **** /* Truncate File                                                         */
4893:ff.c          **** /*-----------------------------------------------------------------------*/
4894:ff.c          **** 
4895:ff.c          **** FRESULT f_truncate (
4896:ff.c          **** 	FIL* fp		/* Pointer to the file object */
4897:ff.c          **** )
4898:ff.c          **** {
 8980               		.loc 1 4898 0
 8981               		.cfi_startproc
 8982               	.LVL848:
 8983 2a12 EF92      		push r14
 8984               	.LCFI321:
 8985               		.cfi_def_cfa_offset 3
 8986               		.cfi_offset 14, -2
 8987 2a14 FF92      		push r15
 8988               	.LCFI322:
 8989               		.cfi_def_cfa_offset 4
 8990               		.cfi_offset 15, -3
 8991 2a16 0F93      		push r16
 8992               	.LCFI323:
 8993               		.cfi_def_cfa_offset 5
 8994               		.cfi_offset 16, -4
 8995 2a18 1F93      		push r17
 8996               	.LCFI324:
 8997               		.cfi_def_cfa_offset 6
 8998               		.cfi_offset 17, -5
 8999 2a1a CF93      		push r28
 9000               	.LCFI325:
 9001               		.cfi_def_cfa_offset 7
 9002               		.cfi_offset 28, -6
 9003 2a1c DF93      		push r29
 9004               	.LCFI326:
 9005               		.cfi_def_cfa_offset 8
 9006               		.cfi_offset 29, -7
 9007 2a1e 00D0      		rcall .
 9008               	.LCFI327:
 9009               		.cfi_def_cfa_offset 10
 9010 2a20 CDB7      		in r28,__SP_L__
 9011 2a22 DEB7      		in r29,__SP_H__
 9012               	.LCFI328:
 9013               		.cfi_def_cfa_register 28
 9014               	/* prologue: function */
 9015               	/* frame size = 2 */
 9016               	/* stack size = 8 */
 9017               	.L__stack_usage = 8
 9018 2a24 7C01      		movw r14,r24
4899:ff.c          **** 	FRESULT res;
4900:ff.c          **** 	FATFS *fs;
4901:ff.c          **** 	DWORD ncl;
4902:ff.c          **** 
4903:ff.c          **** 
4904:ff.c          **** 	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 9019               		.loc 1 4904 0
 9020 2a26 BE01      		movw r22,r28
 9021 2a28 6F5F      		subi r22,-1
 9022 2a2a 7F4F      		sbci r23,-1
 9023 2a2c 0E94 0000 		call validate
 9024               	.LVL849:
4905:ff.c          **** 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
 9025               		.loc 1 4905 0
 9026 2a30 8111      		cpse r24,__zero_reg__
 9027 2a32 00C0      		rjmp .L639
 9028               		.loc 1 4905 0 is_stmt 0 discriminator 2
 9029 2a34 F701      		movw r30,r14
 9030 2a36 1785      		ldd r17,Z+15
 9031               	.LVL850:
 9032 2a38 1111      		cpse r17,__zero_reg__
 9033 2a3a 00C0      		rjmp .L632
4906:ff.c          **** 	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 9034               		.loc 1 4906 0 is_stmt 1
 9035 2a3c 8685      		ldd r24,Z+14
 9036 2a3e 81FF      		sbrs r24,1
 9037 2a40 00C0      		rjmp .L633
4907:ff.c          **** 
4908:ff.c          **** 	if (fp->fptr < fp->obj.objsize) {	/* Process when fptr is not on the eof */
 9038               		.loc 1 4908 0
 9039 2a42 8089      		ldd r24,Z+16
 9040 2a44 9189      		ldd r25,Z+17
 9041 2a46 A289      		ldd r26,Z+18
 9042 2a48 B389      		ldd r27,Z+19
 9043 2a4a 4285      		ldd r20,Z+10
 9044 2a4c 5385      		ldd r21,Z+11
 9045 2a4e 6485      		ldd r22,Z+12
 9046 2a50 7585      		ldd r23,Z+13
 9047 2a52 8417      		cp r24,r20
 9048 2a54 9507      		cpc r25,r21
 9049 2a56 A607      		cpc r26,r22
 9050 2a58 B707      		cpc r27,r23
 9051 2a5a 00F0      		brlo .+2
 9052 2a5c 00C0      		rjmp .L637
4909:ff.c          **** 		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 9053               		.loc 1 4909 0
 9054 2a5e 892B      		or r24,r25
 9055 2a60 8A2B      		or r24,r26
 9056 2a62 8B2B      		or r24,r27
 9057 2a64 01F4      		brne .L627
4910:ff.c          **** 			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 9058               		.loc 1 4910 0
 9059 2a66 4681      		ldd r20,Z+6
 9060 2a68 5781      		ldd r21,Z+7
 9061 2a6a 6085      		ldd r22,Z+8
 9062 2a6c 7185      		ldd r23,Z+9
 9063 2a6e 00E0      		ldi r16,0
 9064 2a70 10E0      		ldi r17,0
 9065 2a72 9801      		movw r18,r16
 9066 2a74 C701      		movw r24,r14
 9067 2a76 0E94 0000 		call remove_chain
 9068               	.LVL851:
 9069 2a7a 182F      		mov r17,r24
 9070               	.LVL852:
4911:ff.c          **** 			fp->obj.sclust = 0;
 9071               		.loc 1 4911 0
 9072 2a7c F701      		movw r30,r14
 9073 2a7e 1682      		std Z+6,__zero_reg__
 9074 2a80 1782      		std Z+7,__zero_reg__
 9075 2a82 1086      		std Z+8,__zero_reg__
 9076 2a84 1186      		std Z+9,__zero_reg__
 9077 2a86 00C0      		rjmp .L628
 9078               	.L627:
4912:ff.c          **** 		} else {				/* When truncate a part of the file, remove remaining clusters */
4913:ff.c          **** 			ncl = get_fat(&fp->obj, fp->clust);
 9079               		.loc 1 4913 0
 9080 2a88 F701      		movw r30,r14
 9081 2a8a 4489      		ldd r20,Z+20
 9082 2a8c 5589      		ldd r21,Z+21
 9083 2a8e 6689      		ldd r22,Z+22
 9084 2a90 7789      		ldd r23,Z+23
 9085 2a92 8081      		ld r24,Z
 9086 2a94 9181      		ldd r25,Z+1
 9087 2a96 0E94 0000 		call get_fat.isra.10
 9088               	.LVL853:
 9089 2a9a AB01      		movw r20,r22
 9090 2a9c BC01      		movw r22,r24
 9091               	.LVL854:
4914:ff.c          **** 			res = FR_OK;
4915:ff.c          **** 			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 9092               		.loc 1 4915 0
 9093 2a9e 4F3F      		cpi r20,-1
 9094 2aa0 FFEF      		ldi r31,-1
 9095 2aa2 5F07      		cpc r21,r31
 9096 2aa4 6F07      		cpc r22,r31
 9097 2aa6 7F07      		cpc r23,r31
 9098 2aa8 01F0      		breq .L635
4916:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
 9099               		.loc 1 4916 0
 9100 2aaa 4130      		cpi r20,1
 9101 2aac 5105      		cpc r21,__zero_reg__
 9102 2aae 6105      		cpc r22,__zero_reg__
 9103 2ab0 7105      		cpc r23,__zero_reg__
 9104 2ab2 01F4      		brne .L638
 9105 2ab4 12E0      		ldi r17,lo8(2)
 9106 2ab6 00C0      		rjmp .L628
 9107               	.L635:
4915:ff.c          **** 			if (ncl == 1) res = FR_INT_ERR;
 9108               		.loc 1 4915 0
 9109 2ab8 11E0      		ldi r17,lo8(1)
 9110 2aba 00C0      		rjmp .L628
 9111               	.L638:
4917:ff.c          **** 			if (res == FR_OK && ncl < fs->n_fatent) {
 9112               		.loc 1 4917 0
 9113 2abc E981      		ldd r30,Y+1
 9114 2abe FA81      		ldd r31,Y+2
 9115 2ac0 8389      		ldd r24,Z+19
 9116 2ac2 9489      		ldd r25,Z+20
 9117 2ac4 A589      		ldd r26,Z+21
 9118 2ac6 B689      		ldd r27,Z+22
 9119 2ac8 4817      		cp r20,r24
 9120 2aca 5907      		cpc r21,r25
 9121 2acc 6A07      		cpc r22,r26
 9122 2ace 7B07      		cpc r23,r27
 9123 2ad0 00F4      		brsh .L628
4918:ff.c          **** 				res = remove_chain(&fp->obj, ncl, fp->clust);
 9124               		.loc 1 4918 0
 9125 2ad2 F701      		movw r30,r14
 9126 2ad4 0489      		ldd r16,Z+20
 9127 2ad6 1589      		ldd r17,Z+21
 9128 2ad8 2689      		ldd r18,Z+22
 9129 2ada 3789      		ldd r19,Z+23
 9130 2adc C701      		movw r24,r14
 9131 2ade 0E94 0000 		call remove_chain
 9132               	.LVL855:
 9133 2ae2 182F      		mov r17,r24
 9134               	.LVL856:
 9135               	.L628:
4919:ff.c          **** 			}
4920:ff.c          **** 		}
4921:ff.c          **** 		fp->obj.objsize = fp->fptr;	/* Set file size to current read/write point */
 9136               		.loc 1 4921 0
 9137 2ae4 F701      		movw r30,r14
 9138 2ae6 8089      		ldd r24,Z+16
 9139 2ae8 9189      		ldd r25,Z+17
 9140 2aea A289      		ldd r26,Z+18
 9141 2aec B389      		ldd r27,Z+19
 9142 2aee 8287      		std Z+10,r24
 9143 2af0 9387      		std Z+11,r25
 9144 2af2 A487      		std Z+12,r26
 9145 2af4 B587      		std Z+13,r27
4922:ff.c          **** 		fp->flag |= FA_MODIFIED;
 9146               		.loc 1 4922 0
 9147 2af6 8685      		ldd r24,Z+14
 9148 2af8 8064      		ori r24,lo8(64)
 9149 2afa 8687      		std Z+14,r24
4923:ff.c          **** #if !FF_FS_TINY
4924:ff.c          **** 		if (res == FR_OK && (fp->flag & FA_DIRTY)) {
4925:ff.c          **** 			if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
4926:ff.c          **** 				res = FR_DISK_ERR;
4927:ff.c          **** 			} else {
4928:ff.c          **** 				fp->flag &= (BYTE)~FA_DIRTY;
4929:ff.c          **** 			}
4930:ff.c          **** 		}
4931:ff.c          **** #endif
4932:ff.c          **** 		if (res != FR_OK) ABORT(fs, res);
 9150               		.loc 1 4932 0
 9151 2afc 1123      		tst r17
 9152 2afe 01F0      		breq .L637
 9153               		.loc 1 4932 0 is_stmt 0 discriminator 1
 9154 2b00 1787      		std Z+15,r17
 9155               	.L632:
 9156 2b02 812F      		mov r24,r17
 9157 2b04 00C0      		rjmp .L639
 9158               	.L633:
4906:ff.c          **** 
 9159               		.loc 1 4906 0 is_stmt 1
 9160 2b06 87E0      		ldi r24,lo8(7)
 9161 2b08 00C0      		rjmp .L639
 9162               	.L637:
 9163 2b0a 80E0      		ldi r24,0
 9164               	.LVL857:
 9165               	.L639:
 9166               	/* epilogue start */
4933:ff.c          **** 	}
4934:ff.c          **** 
4935:ff.c          **** 	LEAVE_FF(fs, res);
4936:ff.c          **** }
 9167               		.loc 1 4936 0
 9168 2b0c 0F90      		pop __tmp_reg__
 9169 2b0e 0F90      		pop __tmp_reg__
 9170 2b10 DF91      		pop r29
 9171 2b12 CF91      		pop r28
 9172 2b14 1F91      		pop r17
 9173 2b16 0F91      		pop r16
 9174 2b18 FF90      		pop r15
 9175 2b1a EF90      		pop r14
 9176               	.LVL858:
 9177 2b1c 0895      		ret
 9178               		.cfi_endproc
 9179               	.LFE48:
 9181               	.global	f_unlink
 9183               	f_unlink:
 9184               	.LFB49:
4937:ff.c          **** 
4938:ff.c          **** 
4939:ff.c          **** 
4940:ff.c          **** 
4941:ff.c          **** /*-----------------------------------------------------------------------*/
4942:ff.c          **** /* Delete a File/Directory                                               */
4943:ff.c          **** /*-----------------------------------------------------------------------*/
4944:ff.c          **** 
4945:ff.c          **** FRESULT f_unlink (
4946:ff.c          **** 	const TCHAR* path		/* Pointer to the file or directory path */
4947:ff.c          **** )
4948:ff.c          **** {
 9185               		.loc 1 4948 0
 9186               		.cfi_startproc
 9187               	.LVL859:
 9188 2b1e BF92      		push r11
 9189               	.LCFI329:
 9190               		.cfi_def_cfa_offset 3
 9191               		.cfi_offset 11, -2
 9192 2b20 CF92      		push r12
 9193               	.LCFI330:
 9194               		.cfi_def_cfa_offset 4
 9195               		.cfi_offset 12, -3
 9196 2b22 DF92      		push r13
 9197               	.LCFI331:
 9198               		.cfi_def_cfa_offset 5
 9199               		.cfi_offset 13, -4
 9200 2b24 EF92      		push r14
 9201               	.LCFI332:
 9202               		.cfi_def_cfa_offset 6
 9203               		.cfi_offset 14, -5
 9204 2b26 FF92      		push r15
 9205               	.LCFI333:
 9206               		.cfi_def_cfa_offset 7
 9207               		.cfi_offset 15, -6
 9208 2b28 0F93      		push r16
 9209               	.LCFI334:
 9210               		.cfi_def_cfa_offset 8
 9211               		.cfi_offset 16, -7
 9212 2b2a 1F93      		push r17
 9213               	.LCFI335:
 9214               		.cfi_def_cfa_offset 9
 9215               		.cfi_offset 17, -8
 9216 2b2c CF93      		push r28
 9217               	.LCFI336:
 9218               		.cfi_def_cfa_offset 10
 9219               		.cfi_offset 28, -9
 9220 2b2e DF93      		push r29
 9221               	.LCFI337:
 9222               		.cfi_def_cfa_offset 11
 9223               		.cfi_offset 29, -10
 9224 2b30 CDB7      		in r28,__SP_L__
 9225 2b32 DEB7      		in r29,__SP_H__
 9226               	.LCFI338:
 9227               		.cfi_def_cfa_register 28
 9228 2b34 C455      		subi r28,84
 9229 2b36 D109      		sbc r29,__zero_reg__
 9230               	.LCFI339:
 9231               		.cfi_def_cfa_offset 95
 9232 2b38 0FB6      		in __tmp_reg__,__SREG__
 9233 2b3a F894      		cli
 9234 2b3c DEBF      		out __SP_H__,r29
 9235 2b3e 0FBE      		out __SREG__,__tmp_reg__
 9236 2b40 CDBF      		out __SP_L__,r28
 9237               	/* prologue: function */
 9238               	/* frame size = 84 */
 9239               	/* stack size = 93 */
 9240               	.L__stack_usage = 93
 9241 2b42 6596      		adiw r28,83-62
 9242 2b44 9FAF      		std Y+63,r25
 9243 2b46 8EAF      		std Y+62,r24
 9244 2b48 6597      		sbiw r28,83-62
 9245               	.LVL860:
4949:ff.c          **** 	FRESULT res;
4950:ff.c          **** 	DIR dj, sdj;
4951:ff.c          **** 	DWORD dclst = 0;
4952:ff.c          **** 	FATFS *fs;
4953:ff.c          **** #if FF_FS_EXFAT
4954:ff.c          **** 	FFOBJID obj;
4955:ff.c          **** #endif
4956:ff.c          **** 	DEF_NAMBUF
4957:ff.c          **** 
4958:ff.c          **** 
4959:ff.c          **** 	/* Get logical drive */
4960:ff.c          **** 	res = mount_volume(&path, &fs, FA_WRITE);
 9246               		.loc 1 4960 0
 9247 2b4a 42E0      		ldi r20,lo8(2)
 9248 2b4c BE01      		movw r22,r28
 9249 2b4e 6F5A      		subi r22,-81
 9250 2b50 7F4F      		sbci r23,-1
 9251 2b52 CE01      		movw r24,r28
 9252               	.LVL861:
 9253 2b54 8D5A      		subi r24,-83
 9254 2b56 9F4F      		sbci r25,-1
 9255 2b58 0E94 0000 		call mount_volume
 9256               	.LVL862:
4961:ff.c          **** 	if (res == FR_OK) {
 9257               		.loc 1 4961 0
 9258 2b5c 8111      		cpse r24,__zero_reg__
 9259 2b5e 00C0      		rjmp .L655
4962:ff.c          **** 		dj.obj.fs = fs;
 9260               		.loc 1 4962 0
 9261 2b60 6396      		adiw r28,81-62
 9262 2b62 8EAD      		ldd r24,Y+62
 9263 2b64 9FAD      		ldd r25,Y+63
 9264 2b66 6397      		sbiw r28,81-62
 9265               	.LVL863:
 9266 2b68 9AA7      		std Y+42,r25
 9267 2b6a 89A7      		std Y+41,r24
4963:ff.c          **** 		INIT_NAMBUF(fs);
4964:ff.c          **** 		res = follow_path(&dj, path);		/* Follow the file path */
 9268               		.loc 1 4964 0
 9269 2b6c 6596      		adiw r28,83-62
 9270 2b6e 6EAD      		ldd r22,Y+62
 9271 2b70 7FAD      		ldd r23,Y+63
 9272 2b72 6597      		sbiw r28,83-62
 9273 2b74 CE01      		movw r24,r28
 9274 2b76 8996      		adiw r24,41
 9275 2b78 0E94 0000 		call follow_path
 9276               	.LVL864:
4965:ff.c          **** 		if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
4966:ff.c          **** 			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
4967:ff.c          **** 		}
4968:ff.c          **** #if FF_FS_LOCK != 0
4969:ff.c          **** 		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
4970:ff.c          **** #endif
4971:ff.c          **** 		if (res == FR_OK) {					/* The object is accessible */
 9277               		.loc 1 4971 0
 9278 2b7c 8111      		cpse r24,__zero_reg__
 9279 2b7e 00C0      		rjmp .L655
4972:ff.c          **** 			if (dj.fn[NSFLAG] & NS_NONAME) {
 9280               		.loc 1 4972 0
 9281 2b80 6196      		adiw r28,80-63
 9282 2b82 8FAD      		ldd r24,Y+63
 9283 2b84 6197      		sbiw r28,80-63
 9284               	.LVL865:
 9285 2b86 87FD      		sbrc r24,7
 9286 2b88 00C0      		rjmp .L650
4973:ff.c          **** 				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
4974:ff.c          **** 			} else {
4975:ff.c          **** 				if (dj.obj.attr & AM_RDO) {
 9287               		.loc 1 4975 0
 9288 2b8a BDA4      		ldd r11,Y+45
 9289 2b8c B0FC      		sbrc r11,0
 9290 2b8e 00C0      		rjmp .L652
 9291               	.LVL866:
4976:ff.c          **** 					res = FR_DENIED;		/* Cannot remove R/O object */
4977:ff.c          **** 				}
4978:ff.c          **** 			}
4979:ff.c          **** 			if (res == FR_OK) {
4980:ff.c          **** #if FF_FS_EXFAT
4981:ff.c          **** 				obj.fs = fs;
4982:ff.c          **** 				if (fs->fs_type == FS_EXFAT) {
4983:ff.c          **** 					init_alloc_info(fs, &obj);
4984:ff.c          **** 					dclst = obj.sclust;
4985:ff.c          **** 				} else
4986:ff.c          **** #endif
4987:ff.c          **** 				{
4988:ff.c          **** 					dclst = ld_clust(fs, dj.dir);
 9292               		.loc 1 4988 0
 9293 2b90 6396      		adiw r28,81-62
 9294 2b92 0EAD      		ldd r16,Y+62
 9295 2b94 1FAD      		ldd r17,Y+63
 9296 2b96 6397      		sbiw r28,81-62
 9297 2b98 2596      		adiw r28,67-62
 9298 2b9a 6EAD      		ldd r22,Y+62
 9299 2b9c 7FAD      		ldd r23,Y+63
 9300 2b9e 2597      		sbiw r28,67-62
 9301 2ba0 F801      		movw r30,r16
 9302 2ba2 8081      		ld r24,Z
 9303 2ba4 0E94 0000 		call ld_clust.isra.3
 9304               	.LVL867:
 9305 2ba8 6B01      		movw r12,r22
 9306 2baa 7C01      		movw r14,r24
 9307               	.LVL868:
4989:ff.c          **** 				}
4990:ff.c          **** 				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 9308               		.loc 1 4990 0
 9309 2bac B4FE      		sbrs r11,4
 9310 2bae 00C0      		rjmp .L645
4991:ff.c          **** #if FF_FS_RPATH != 0
4992:ff.c          **** 					if (dclst == fs->cdir) {		 	/* Is it the current directory? */
4993:ff.c          **** 						res = FR_DENIED;
4994:ff.c          **** 					} else
4995:ff.c          **** #endif
4996:ff.c          **** 					{
4997:ff.c          **** 						sdj.obj.fs = fs;				/* Open the sub-directory */
 9311               		.loc 1 4997 0
 9312 2bb0 1A83      		std Y+2,r17
 9313 2bb2 0983      		std Y+1,r16
4998:ff.c          **** 						sdj.obj.sclust = dclst;
 9314               		.loc 1 4998 0
 9315 2bb4 CF82      		std Y+7,r12
 9316 2bb6 D886      		std Y+8,r13
 9317 2bb8 E986      		std Y+9,r14
 9318 2bba FA86      		std Y+10,r15
4999:ff.c          **** #if FF_FS_EXFAT
5000:ff.c          **** 						if (fs->fs_type == FS_EXFAT) {
5001:ff.c          **** 							sdj.obj.objsize = obj.objsize;
5002:ff.c          **** 							sdj.obj.stat = obj.stat;
5003:ff.c          **** 						}
5004:ff.c          **** #endif
5005:ff.c          **** 						res = dir_sdi(&sdj, 0);
 9319               		.loc 1 5005 0
 9320 2bbc CE01      		movw r24,r28
 9321 2bbe 0196      		adiw r24,1
 9322 2bc0 0E94 0000 		call dir_sdi.constprop.15
 9323               	.LVL869:
5006:ff.c          **** 						if (res == FR_OK) {
 9324               		.loc 1 5006 0
 9325 2bc4 8111      		cpse r24,__zero_reg__
 9326 2bc6 00C0      		rjmp .L655
5007:ff.c          **** 							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
 9327               		.loc 1 5007 0
 9328 2bc8 CE01      		movw r24,r28
 9329               	.LVL870:
 9330 2bca 0196      		adiw r24,1
 9331 2bcc 0E94 0000 		call dir_read.constprop.13
 9332               	.LVL871:
5008:ff.c          **** 							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 9333               		.loc 1 5008 0
 9334 2bd0 8823      		tst r24
 9335 2bd2 01F0      		breq .L652
5009:ff.c          **** 							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 9336               		.loc 1 5009 0
 9337 2bd4 8430      		cpi r24,lo8(4)
 9338 2bd6 01F0      		breq .L645
 9339 2bd8 00C0      		rjmp .L655
 9340               	.LVL872:
 9341               	.L650:
4973:ff.c          **** 			} else {
 9342               		.loc 1 4973 0
 9343 2bda 86E0      		ldi r24,lo8(6)
 9344 2bdc 00C0      		rjmp .L655
 9345               	.LVL873:
 9346               	.L652:
5008:ff.c          **** 							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 9347               		.loc 1 5008 0
 9348 2bde 87E0      		ldi r24,lo8(7)
 9349               	.LVL874:
 9350 2be0 00C0      		rjmp .L655
 9351               	.LVL875:
 9352               	.L645:
 9353               	.LBB346:
 9354               	.LBB347:
2634:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 9355               		.loc 1 2634 0
 9356 2be2 09A5      		ldd r16,Y+41
 9357 2be4 1AA5      		ldd r17,Y+42
 9358               	.LVL876:
2656:ff.c          **** 	if (res == FR_OK) {
 9359               		.loc 1 2656 0
 9360 2be6 2396      		adiw r28,63-60
 9361 2be8 4CAD      		ldd r20,Y+60
 9362 2bea 5DAD      		ldd r21,Y+61
 9363 2bec 6EAD      		ldd r22,Y+62
 9364 2bee 7FAD      		ldd r23,Y+63
 9365 2bf0 2397      		sbiw r28,63-60
 9366 2bf2 C801      		movw r24,r16
 9367 2bf4 0E94 0000 		call move_window
 9368               	.LVL877:
2657:ff.c          **** 		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 9369               		.loc 1 2657 0
 9370 2bf8 8111      		cpse r24,__zero_reg__
 9371 2bfa 00C0      		rjmp .L655
2658:ff.c          **** 		fs->wflag = 1;
 9372               		.loc 1 2658 0
 9373 2bfc 2596      		adiw r28,67-62
 9374 2bfe EEAD      		ldd r30,Y+62
 9375 2c00 FFAD      		ldd r31,Y+63
 9376 2c02 2597      		sbiw r28,67-62
 9377 2c04 85EE      		ldi r24,lo8(-27)
 9378               	.LVL878:
 9379 2c06 8083      		st Z,r24
2659:ff.c          **** 	}
 9380               		.loc 1 2659 0
 9381 2c08 81E0      		ldi r24,lo8(1)
 9382 2c0a F801      		movw r30,r16
 9383 2c0c 8383      		std Z+3,r24
 9384               	.LVL879:
 9385               	.LBE347:
 9386               	.LBE346:
5010:ff.c          **** 						}
5011:ff.c          **** 					}
5012:ff.c          **** 				}
5013:ff.c          **** 			}
5014:ff.c          **** 			if (res == FR_OK) {
5015:ff.c          **** 				res = dir_remove(&dj);			/* Remove the directory entry */
5016:ff.c          **** 				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 9387               		.loc 1 5016 0
 9388 2c0e C114      		cp r12,__zero_reg__
 9389 2c10 D104      		cpc r13,__zero_reg__
 9390 2c12 E104      		cpc r14,__zero_reg__
 9391 2c14 F104      		cpc r15,__zero_reg__
 9392 2c16 01F4      		brne .L646
 9393               	.L647:
5017:ff.c          **** #if FF_FS_EXFAT
5018:ff.c          **** 					res = remove_chain(&obj, dclst, 0);
5019:ff.c          **** #else
5020:ff.c          **** 					res = remove_chain(&dj.obj, dclst, 0);
5021:ff.c          **** #endif
5022:ff.c          **** 				}
5023:ff.c          **** 				if (res == FR_OK) res = sync_fs(fs);
 9394               		.loc 1 5023 0
 9395 2c18 6396      		adiw r28,81-62
 9396 2c1a 8EAD      		ldd r24,Y+62
 9397 2c1c 9FAD      		ldd r25,Y+63
 9398 2c1e 6397      		sbiw r28,81-62
 9399 2c20 0E94 0000 		call sync_fs
 9400               	.LVL880:
 9401 2c24 00C0      		rjmp .L655
 9402               	.LVL881:
 9403               	.L646:
5020:ff.c          **** #endif
 9404               		.loc 1 5020 0
 9405 2c26 00E0      		ldi r16,0
 9406 2c28 10E0      		ldi r17,0
 9407 2c2a 9801      		movw r18,r16
 9408 2c2c B701      		movw r22,r14
 9409 2c2e A601      		movw r20,r12
 9410 2c30 CE01      		movw r24,r28
 9411 2c32 8996      		adiw r24,41
 9412 2c34 0E94 0000 		call remove_chain
 9413               	.LVL882:
 9414               		.loc 1 5023 0
 9415 2c38 8823      		tst r24
 9416 2c3a 01F0      		breq .L647
 9417               	.LVL883:
 9418               	.L655:
 9419               	/* epilogue start */
5024:ff.c          **** 			}
5025:ff.c          **** 		}
5026:ff.c          **** 		FREE_NAMBUF();
5027:ff.c          **** 	}
5028:ff.c          **** 
5029:ff.c          **** 	LEAVE_FF(fs, res);
5030:ff.c          **** }
 9420               		.loc 1 5030 0
 9421 2c3c CC5A      		subi r28,-84
 9422 2c3e DF4F      		sbci r29,-1
 9423 2c40 0FB6      		in __tmp_reg__,__SREG__
 9424 2c42 F894      		cli
 9425 2c44 DEBF      		out __SP_H__,r29
 9426 2c46 0FBE      		out __SREG__,__tmp_reg__
 9427 2c48 CDBF      		out __SP_L__,r28
 9428 2c4a DF91      		pop r29
 9429 2c4c CF91      		pop r28
 9430 2c4e 1F91      		pop r17
 9431 2c50 0F91      		pop r16
 9432 2c52 FF90      		pop r15
 9433 2c54 EF90      		pop r14
 9434 2c56 DF90      		pop r13
 9435 2c58 CF90      		pop r12
 9436 2c5a BF90      		pop r11
 9437 2c5c 0895      		ret
 9438               		.cfi_endproc
 9439               	.LFE49:
 9441               	.global	f_mkdir
 9443               	f_mkdir:
 9444               	.LFB50:
5031:ff.c          **** 
5032:ff.c          **** 
5033:ff.c          **** 
5034:ff.c          **** 
5035:ff.c          **** /*-----------------------------------------------------------------------*/
5036:ff.c          **** /* Create a Directory                                                    */
5037:ff.c          **** /*-----------------------------------------------------------------------*/
5038:ff.c          **** 
5039:ff.c          **** FRESULT f_mkdir (
5040:ff.c          **** 	const TCHAR* path		/* Pointer to the directory path */
5041:ff.c          **** )
5042:ff.c          **** {
 9445               		.loc 1 5042 0
 9446               		.cfi_startproc
 9447               	.LVL884:
 9448 2c5e 8F92      		push r8
 9449               	.LCFI340:
 9450               		.cfi_def_cfa_offset 3
 9451               		.cfi_offset 8, -2
 9452 2c60 9F92      		push r9
 9453               	.LCFI341:
 9454               		.cfi_def_cfa_offset 4
 9455               		.cfi_offset 9, -3
 9456 2c62 AF92      		push r10
 9457               	.LCFI342:
 9458               		.cfi_def_cfa_offset 5
 9459               		.cfi_offset 10, -4
 9460 2c64 BF92      		push r11
 9461               	.LCFI343:
 9462               		.cfi_def_cfa_offset 6
 9463               		.cfi_offset 11, -5
 9464 2c66 DF92      		push r13
 9465               	.LCFI344:
 9466               		.cfi_def_cfa_offset 7
 9467               		.cfi_offset 13, -6
 9468 2c68 EF92      		push r14
 9469               	.LCFI345:
 9470               		.cfi_def_cfa_offset 8
 9471               		.cfi_offset 14, -7
 9472 2c6a FF92      		push r15
 9473               	.LCFI346:
 9474               		.cfi_def_cfa_offset 9
 9475               		.cfi_offset 15, -8
 9476 2c6c 0F93      		push r16
 9477               	.LCFI347:
 9478               		.cfi_def_cfa_offset 10
 9479               		.cfi_offset 16, -9
 9480 2c6e 1F93      		push r17
 9481               	.LCFI348:
 9482               		.cfi_def_cfa_offset 11
 9483               		.cfi_offset 17, -10
 9484 2c70 CF93      		push r28
 9485               	.LCFI349:
 9486               		.cfi_def_cfa_offset 12
 9487               		.cfi_offset 28, -11
 9488 2c72 DF93      		push r29
 9489               	.LCFI350:
 9490               		.cfi_def_cfa_offset 13
 9491               		.cfi_offset 29, -12
 9492 2c74 CDB7      		in r28,__SP_L__
 9493 2c76 DEB7      		in r29,__SP_H__
 9494               	.LCFI351:
 9495               		.cfi_def_cfa_register 28
 9496 2c78 EA97      		sbiw r28,58
 9497               	.LCFI352:
 9498               		.cfi_def_cfa_offset 71
 9499 2c7a 0FB6      		in __tmp_reg__,__SREG__
 9500 2c7c F894      		cli
 9501 2c7e DEBF      		out __SP_H__,r29
 9502 2c80 0FBE      		out __SREG__,__tmp_reg__
 9503 2c82 CDBF      		out __SP_L__,r28
 9504               	/* prologue: function */
 9505               	/* frame size = 58 */
 9506               	/* stack size = 69 */
 9507               	.L__stack_usage = 69
 9508 2c84 9AAF      		std Y+58,r25
 9509 2c86 89AF      		std Y+57,r24
5043:ff.c          **** 	FRESULT res;
5044:ff.c          **** 	DIR dj;
5045:ff.c          **** 	FFOBJID sobj;
5046:ff.c          **** 	FATFS *fs;
5047:ff.c          **** 	DWORD dcl, pcl, tm;
5048:ff.c          **** 	DEF_NAMBUF
5049:ff.c          **** 
5050:ff.c          **** 
5051:ff.c          **** 	res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 9510               		.loc 1 5051 0
 9511 2c88 42E0      		ldi r20,lo8(2)
 9512 2c8a BE01      		movw r22,r28
 9513 2c8c 695C      		subi r22,-55
 9514 2c8e 7F4F      		sbci r23,-1
 9515 2c90 CE01      		movw r24,r28
 9516               	.LVL885:
 9517 2c92 C996      		adiw r24,57
 9518 2c94 0E94 0000 		call mount_volume
 9519               	.LVL886:
 9520 2c98 F82E      		mov r15,r24
 9521               	.LVL887:
5052:ff.c          **** 	if (res == FR_OK) {
 9522               		.loc 1 5052 0
 9523 2c9a 8111      		cpse r24,__zero_reg__
 9524 2c9c 00C0      		rjmp .L672
5053:ff.c          **** 		dj.obj.fs = fs;
 9525               		.loc 1 5053 0
 9526 2c9e 8FA9      		ldd r24,Y+55
 9527 2ca0 98AD      		ldd r25,Y+56
 9528 2ca2 9A83      		std Y+2,r25
 9529 2ca4 8983      		std Y+1,r24
5054:ff.c          **** 		INIT_NAMBUF(fs);
5055:ff.c          **** 		res = follow_path(&dj, path);			/* Follow the file path */
 9530               		.loc 1 5055 0
 9531 2ca6 69AD      		ldd r22,Y+57
 9532 2ca8 7AAD      		ldd r23,Y+58
 9533 2caa CE01      		movw r24,r28
 9534 2cac 0196      		adiw r24,1
 9535 2cae 0E94 0000 		call follow_path
 9536               	.LVL888:
 9537 2cb2 F82E      		mov r15,r24
 9538               	.LVL889:
5056:ff.c          **** 		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
 9539               		.loc 1 5056 0
 9540 2cb4 8823      		tst r24
 9541 2cb6 01F0      		breq .L668
5057:ff.c          **** 		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
5058:ff.c          **** 			res = FR_INVALID_NAME;
5059:ff.c          **** 		}
5060:ff.c          **** 		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
 9542               		.loc 1 5060 0
 9543 2cb8 84E0      		ldi r24,lo8(4)
 9544 2cba F812      		cpse r15,r24
 9545 2cbc 00C0      		rjmp .L672
5061:ff.c          **** 			sobj.fs = fs;						/* New object id to create a new chain */
 9546               		.loc 1 5061 0
 9547 2cbe 8FA9      		ldd r24,Y+55
 9548 2cc0 98AD      		ldd r25,Y+56
 9549 2cc2 9AA7      		std Y+42,r25
 9550 2cc4 89A7      		std Y+41,r24
5062:ff.c          **** 			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 9551               		.loc 1 5062 0
 9552 2cc6 40E0      		ldi r20,0
 9553 2cc8 50E0      		ldi r21,0
 9554 2cca BA01      		movw r22,r20
 9555 2ccc CE01      		movw r24,r28
 9556 2cce 8996      		adiw r24,41
 9557 2cd0 0E94 0000 		call create_chain
 9558               	.LVL890:
 9559 2cd4 4B01      		movw r8,r22
 9560 2cd6 5C01      		movw r10,r24
 9561               	.LVL891:
5063:ff.c          **** 			res = FR_OK;
5064:ff.c          **** 			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 9562               		.loc 1 5064 0
 9563 2cd8 6115      		cp r22,__zero_reg__
 9564 2cda 7105      		cpc r23,__zero_reg__
 9565 2cdc 8105      		cpc r24,__zero_reg__
 9566 2cde 9105      		cpc r25,__zero_reg__
 9567 2ce0 01F0      		breq .L669
5065:ff.c          **** 			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 9568               		.loc 1 5065 0
 9569 2ce2 6130      		cpi r22,1
 9570 2ce4 7105      		cpc r23,__zero_reg__
 9571 2ce6 8105      		cpc r24,__zero_reg__
 9572 2ce8 9105      		cpc r25,__zero_reg__
 9573 2cea 01F4      		brne .L676
 9574 2cec 82E0      		ldi r24,lo8(2)
 9575 2cee F82E      		mov r15,r24
 9576               	.LVL892:
 9577               	.L666:
5066:ff.c          **** 			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
5067:ff.c          **** 			tm = GET_FATTIME();
5068:ff.c          **** 			if (res == FR_OK) {
5069:ff.c          **** 				res = dir_clear(fs, dcl);		/* Clean up the new table */
5070:ff.c          **** 				if (res == FR_OK) {
5071:ff.c          **** 					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
5072:ff.c          **** 						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
5073:ff.c          **** 						fs->win[DIR_Name] = '.';
5074:ff.c          **** 						fs->win[DIR_Attr] = AM_DIR;
5075:ff.c          **** 						st_dword(fs->win + DIR_ModTime, tm);
5076:ff.c          **** 						st_clust(fs, fs->win, dcl);
5077:ff.c          **** 						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
5078:ff.c          **** 						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
5079:ff.c          **** 						st_clust(fs, fs->win + SZDIRE, pcl);
5080:ff.c          **** 						fs->wflag = 1;
5081:ff.c          **** 					}
5082:ff.c          **** 					res = dir_register(&dj);	/* Register the object to the parent directoy */
5083:ff.c          **** 				}
5084:ff.c          **** 			}
5085:ff.c          **** 			if (res == FR_OK) {
5086:ff.c          **** #if FF_FS_EXFAT
5087:ff.c          **** 				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
5088:ff.c          **** 					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
5089:ff.c          **** 					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
5090:ff.c          **** 					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)fs->csize * SS(fs));	/* Directory size needs to be
5091:ff.c          **** 					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)fs->csize * SS(fs));
5092:ff.c          **** 					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
5093:ff.c          **** 					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
5094:ff.c          **** 					res = store_xdir(&dj);
5095:ff.c          **** 				} else
5096:ff.c          **** #endif
5097:ff.c          **** 				{
5098:ff.c          **** 					st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
5099:ff.c          **** 					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
5100:ff.c          **** 					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
5101:ff.c          **** 					fs->wflag = 1;
5102:ff.c          **** 				}
5103:ff.c          **** 				if (res == FR_OK) {
5104:ff.c          **** 					res = sync_fs(fs);
5105:ff.c          **** 				}
5106:ff.c          **** 			} else {
5107:ff.c          **** 				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 9578               		.loc 1 5107 0
 9579 2cf0 00E0      		ldi r16,0
 9580 2cf2 10E0      		ldi r17,0
 9581 2cf4 9801      		movw r18,r16
 9582 2cf6 B501      		movw r22,r10
 9583 2cf8 A401      		movw r20,r8
 9584 2cfa CE01      		movw r24,r28
 9585 2cfc 8996      		adiw r24,41
 9586 2cfe 0E94 0000 		call remove_chain
 9587               	.LVL893:
 9588 2d02 00C0      		rjmp .L672
 9589               	.LVL894:
 9590               	.L668:
5056:ff.c          **** 		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
 9591               		.loc 1 5056 0
 9592 2d04 28E0      		ldi r18,lo8(8)
 9593 2d06 F22E      		mov r15,r18
 9594               	.LVL895:
5108:ff.c          **** 			}
5109:ff.c          **** 		}
5110:ff.c          **** 		FREE_NAMBUF();
5111:ff.c          **** 	}
5112:ff.c          **** 
5113:ff.c          **** 	LEAVE_FF(fs, res);
 9595               		.loc 1 5113 0
 9596 2d08 00C0      		rjmp .L672
 9597               	.LVL896:
 9598               	.L669:
5064:ff.c          **** 			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 9599               		.loc 1 5064 0
 9600 2d0a 97E0      		ldi r25,lo8(7)
 9601 2d0c F92E      		mov r15,r25
 9602 2d0e 00C0      		rjmp .L666
 9603               	.L676:
5066:ff.c          **** 			tm = GET_FATTIME();
 9604               		.loc 1 5066 0
 9605 2d10 6F3F      		cpi r22,-1
 9606 2d12 7F4F      		sbci r23,-1
 9607 2d14 8F4F      		sbci r24,-1
 9608 2d16 9F4F      		sbci r25,-1
 9609 2d18 01F4      		brne .+2
 9610 2d1a 00C0      		rjmp .L671
 9611               	.LVL897:
5069:ff.c          **** 				if (res == FR_OK) {
 9612               		.loc 1 5069 0
 9613 2d1c B501      		movw r22,r10
 9614 2d1e A401      		movw r20,r8
 9615 2d20 8FA9      		ldd r24,Y+55
 9616 2d22 98AD      		ldd r25,Y+56
 9617 2d24 0E94 0000 		call dir_clear
 9618               	.LVL898:
 9619 2d28 F82E      		mov r15,r24
 9620               	.LVL899:
5070:ff.c          **** 					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
 9621               		.loc 1 5070 0
 9622 2d2a 8111      		cpse r24,__zero_reg__
 9623 2d2c 00C0      		rjmp .L666
5072:ff.c          **** 						fs->win[DIR_Name] = '.';
 9624               		.loc 1 5072 0
 9625 2d2e 8FA9      		ldd r24,Y+55
 9626 2d30 98AD      		ldd r25,Y+56
 9627               	.LVL900:
 9628 2d32 FC01      		movw r30,r24
 9629 2d34 BF96      		adiw r30,47
 9630               	.LVL901:
 9631 2d36 CA96      		adiw r24,58
 9632               	.LBB356:
 9633               	.LBB357:
 703:ff.c          **** 	} while (--cnt);
 9634               		.loc 1 703 0
 9635 2d38 20E2      		ldi r18,lo8(32)
 9636               	.LVL902:
 9637               	.L665:
 9638 2d3a 2193      		st Z+,r18
 9639               	.LVL903:
 704:ff.c          **** }
 9640               		.loc 1 704 0
 9641 2d3c E817      		cp r30,r24
 9642 2d3e F907      		cpc r31,r25
 9643 2d40 01F4      		brne .L665
 9644               	.LVL904:
 9645               	.LBE357:
 9646               	.LBE356:
5073:ff.c          **** 						fs->win[DIR_Attr] = AM_DIR;
 9647               		.loc 1 5073 0
 9648 2d42 8FA9      		ldd r24,Y+55
 9649 2d44 98AD      		ldd r25,Y+56
 9650 2d46 1EE2      		ldi r17,lo8(46)
 9651 2d48 FC01      		movw r30,r24
 9652               	.LVL905:
 9653 2d4a 17A7      		std Z+47,r17
5074:ff.c          **** 						st_dword(fs->win + DIR_ModTime, tm);
 9654               		.loc 1 5074 0
 9655 2d4c 00E1      		ldi r16,lo8(16)
 9656 2d4e 02AF      		std Z+58,r16
 9657               	.LVL906:
 9658               	.LBB358:
 9659               	.LBB359:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 9660               		.loc 1 656 0
 9661 2d50 EB5B      		subi r30,-69
 9662 2d52 FF4F      		sbci r31,-1
 9663               	.LVL907:
 9664 2d54 1082      		st Z,__zero_reg__
 9665               	.LVL908:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 9666               		.loc 1 657 0
 9667 2d56 3196      		adiw r30,1
 9668               	.LVL909:
 9669 2d58 1082      		st Z,__zero_reg__
 9670               	.LVL910:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 9671               		.loc 1 658 0
 9672 2d5a 3196      		adiw r30,1
 9673               	.LVL911:
 9674 2d5c 32E3      		ldi r19,lo8(50)
 9675 2d5e D32E      		mov r13,r19
 9676 2d60 D082      		st Z,r13
 9677               	.LVL912:
 659:ff.c          **** }
 9678               		.loc 1 659 0
 9679 2d62 3196      		adiw r30,1
 9680               	.LVL913:
 9681 2d64 40E5      		ldi r20,lo8(80)
 9682 2d66 E42E      		mov r14,r20
 9683 2d68 E082      		st Z,r14
 9684               	.LVL914:
 9685               	.LBE359:
 9686               	.LBE358:
5076:ff.c          **** 						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
 9687               		.loc 1 5076 0
 9688 2d6a BC01      		movw r22,r24
 9689 2d6c 615D      		subi r22,-47
 9690 2d6e 7F4F      		sbci r23,-1
 9691 2d70 A501      		movw r20,r10
 9692 2d72 9401      		movw r18,r8
 9693 2d74 0E94 0000 		call st_clust.isra.4
 9694               	.LVL915:
5077:ff.c          **** 						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 9695               		.loc 1 5077 0
 9696 2d78 8FA9      		ldd r24,Y+55
 9697 2d7a 98AD      		ldd r25,Y+56
 9698               	.LVL916:
 9699 2d7c BC01      		movw r22,r24
 9700 2d7e 615D      		subi r22,-47
 9701 2d80 7F4F      		sbci r23,-1
 9702               	.LVL917:
 9703               	.LBB360:
 9704               	.LBB361:
 9705 2d82 40E2      		ldi r20,lo8(32)
 9706 2d84 50E0      		ldi r21,0
 9707 2d86 815B      		subi r24,-79
 9708 2d88 9F4F      		sbci r25,-1
 9709               	.LVL918:
 9710 2d8a 0E94 0000 		call mem_cpy.part.0
 9711               	.LVL919:
 9712               	.LBE361:
 9713               	.LBE360:
5078:ff.c          **** 						st_clust(fs, fs->win + SZDIRE, pcl);
 9714               		.loc 1 5078 0
 9715 2d8e 8FA9      		ldd r24,Y+55
 9716 2d90 98AD      		ldd r25,Y+56
 9717 2d92 FC01      		movw r30,r24
 9718 2d94 E05B      		subi r30,-80
 9719 2d96 FF4F      		sbci r31,-1
 9720 2d98 1083      		st Z,r17
 9721               	.LVL920:
5079:ff.c          **** 						fs->wflag = 1;
 9722               		.loc 1 5079 0
 9723 2d9a 2F81      		ldd r18,Y+7
 9724 2d9c 3885      		ldd r19,Y+8
 9725 2d9e 4985      		ldd r20,Y+9
 9726 2da0 5A85      		ldd r21,Y+10
 9727 2da2 BC01      		movw r22,r24
 9728 2da4 615B      		subi r22,-79
 9729 2da6 7F4F      		sbci r23,-1
 9730 2da8 0E94 0000 		call st_clust.isra.4
 9731               	.LVL921:
5080:ff.c          **** 					}
 9732               		.loc 1 5080 0
 9733 2dac EFA9      		ldd r30,Y+55
 9734 2dae F8AD      		ldd r31,Y+56
 9735 2db0 11E0      		ldi r17,lo8(1)
 9736 2db2 1383      		std Z+3,r17
5082:ff.c          **** 				}
 9737               		.loc 1 5082 0
 9738 2db4 CE01      		movw r24,r28
 9739 2db6 0196      		adiw r24,1
 9740 2db8 0E94 0000 		call dir_register
 9741               	.LVL922:
 9742 2dbc F82E      		mov r15,r24
 9743               	.LVL923:
5085:ff.c          **** #if FF_FS_EXFAT
 9744               		.loc 1 5085 0
 9745 2dbe 8111      		cpse r24,__zero_reg__
 9746 2dc0 00C0      		rjmp .L666
5098:ff.c          **** 					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 9747               		.loc 1 5098 0
 9748 2dc2 EB8D      		ldd r30,Y+27
 9749 2dc4 FC8D      		ldd r31,Y+28
 9750               	.LVL924:
 9751               	.LBB362:
 9752               	.LBB363:
 656:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 9753               		.loc 1 656 0
 9754 2dc6 168A      		std Z+22,__zero_reg__
 9755               	.LVL925:
 657:ff.c          **** 	*ptr++ = (BYTE)val; val >>= 8;
 9756               		.loc 1 657 0
 9757 2dc8 178A      		std Z+23,__zero_reg__
 9758               	.LVL926:
 658:ff.c          **** 	*ptr++ = (BYTE)val;
 9759               		.loc 1 658 0
 9760 2dca D08E      		std Z+24,r13
 9761               	.LVL927:
 659:ff.c          **** }
 9762               		.loc 1 659 0
 9763 2dcc E18E      		std Z+25,r14
 9764               	.LVL928:
 9765               	.LBE363:
 9766               	.LBE362:
5099:ff.c          **** 					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 9767               		.loc 1 5099 0
 9768 2dce 6B8D      		ldd r22,Y+27
 9769 2dd0 7C8D      		ldd r23,Y+28
 9770 2dd2 A501      		movw r20,r10
 9771 2dd4 9401      		movw r18,r8
 9772 2dd6 8FA9      		ldd r24,Y+55
 9773 2dd8 98AD      		ldd r25,Y+56
 9774 2dda 0E94 0000 		call st_clust.isra.4
 9775               	.LVL929:
5100:ff.c          **** 					fs->wflag = 1;
 9776               		.loc 1 5100 0
 9777 2dde EB8D      		ldd r30,Y+27
 9778 2de0 FC8D      		ldd r31,Y+28
 9779 2de2 0387      		std Z+11,r16
5101:ff.c          **** 				}
 9780               		.loc 1 5101 0
 9781 2de4 8FA9      		ldd r24,Y+55
 9782 2de6 98AD      		ldd r25,Y+56
 9783 2de8 FC01      		movw r30,r24
 9784 2dea 1383      		std Z+3,r17
5104:ff.c          **** 				}
 9785               		.loc 1 5104 0
 9786 2dec 0E94 0000 		call sync_fs
 9787               	.LVL930:
 9788 2df0 F82E      		mov r15,r24
 9789               	.LVL931:
 9790 2df2 00C0      		rjmp .L672
 9791               	.LVL932:
 9792               	.L671:
5066:ff.c          **** 			tm = GET_FATTIME();
 9793               		.loc 1 5066 0
 9794 2df4 FF24      		clr r15
 9795 2df6 F394      		inc r15
 9796 2df8 00C0      		rjmp .L666
 9797               	.LVL933:
 9798               	.L672:
5114:ff.c          **** }
 9799               		.loc 1 5114 0
 9800 2dfa 8F2D      		mov r24,r15
 9801               	/* epilogue start */
 9802 2dfc EA96      		adiw r28,58
 9803 2dfe 0FB6      		in __tmp_reg__,__SREG__
 9804 2e00 F894      		cli
 9805 2e02 DEBF      		out __SP_H__,r29
 9806 2e04 0FBE      		out __SREG__,__tmp_reg__
 9807 2e06 CDBF      		out __SP_L__,r28
 9808 2e08 DF91      		pop r29
 9809 2e0a CF91      		pop r28
 9810 2e0c 1F91      		pop r17
 9811 2e0e 0F91      		pop r16
 9812 2e10 FF90      		pop r15
 9813               	.LVL934:
 9814 2e12 EF90      		pop r14
 9815 2e14 DF90      		pop r13
 9816 2e16 BF90      		pop r11
 9817 2e18 AF90      		pop r10
 9818 2e1a 9F90      		pop r9
 9819 2e1c 8F90      		pop r8
 9820 2e1e 0895      		ret
 9821               		.cfi_endproc
 9822               	.LFE50:
 9824               	.global	f_rename
 9826               	f_rename:
 9827               	.LFB51:
5115:ff.c          **** 
5116:ff.c          **** 
5117:ff.c          **** 
5118:ff.c          **** 
5119:ff.c          **** /*-----------------------------------------------------------------------*/
5120:ff.c          **** /* Rename a File/Directory                                               */
5121:ff.c          **** /*-----------------------------------------------------------------------*/
5122:ff.c          **** 
5123:ff.c          **** FRESULT f_rename (
5124:ff.c          **** 	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
5125:ff.c          **** 	const TCHAR* path_new	/* Pointer to the new name */
5126:ff.c          **** )
5127:ff.c          **** {
 9828               		.loc 1 5127 0
 9829               		.cfi_startproc
 9830               	.LVL935:
 9831 2e20 DF92      		push r13
 9832               	.LCFI353:
 9833               		.cfi_def_cfa_offset 3
 9834               		.cfi_offset 13, -2
 9835 2e22 EF92      		push r14
 9836               	.LCFI354:
 9837               		.cfi_def_cfa_offset 4
 9838               		.cfi_offset 14, -3
 9839 2e24 FF92      		push r15
 9840               	.LCFI355:
 9841               		.cfi_def_cfa_offset 5
 9842               		.cfi_offset 15, -4
 9843 2e26 0F93      		push r16
 9844               	.LCFI356:
 9845               		.cfi_def_cfa_offset 6
 9846               		.cfi_offset 16, -5
 9847 2e28 1F93      		push r17
 9848               	.LCFI357:
 9849               		.cfi_def_cfa_offset 7
 9850               		.cfi_offset 17, -6
 9851 2e2a CF93      		push r28
 9852               	.LCFI358:
 9853               		.cfi_def_cfa_offset 8
 9854               		.cfi_offset 28, -7
 9855 2e2c DF93      		push r29
 9856               	.LCFI359:
 9857               		.cfi_def_cfa_offset 9
 9858               		.cfi_offset 29, -8
 9859 2e2e CDB7      		in r28,__SP_L__
 9860 2e30 DEB7      		in r29,__SP_H__
 9861               	.LCFI360:
 9862               		.cfi_def_cfa_register 28
 9863 2e32 C657      		subi r28,118
 9864 2e34 D109      		sbc r29,__zero_reg__
 9865               	.LCFI361:
 9866               		.cfi_def_cfa_offset 127
 9867 2e36 0FB6      		in __tmp_reg__,__SREG__
 9868 2e38 F894      		cli
 9869 2e3a DEBF      		out __SP_H__,r29
 9870 2e3c 0FBE      		out __SREG__,__tmp_reg__
 9871 2e3e CDBF      		out __SP_L__,r28
 9872               	/* prologue: function */
 9873               	/* frame size = 118 */
 9874               	/* stack size = 125 */
 9875               	.L__stack_usage = 125
 9876 2e40 E596      		adiw r28,115-62
 9877 2e42 9FAF      		std Y+63,r25
 9878 2e44 8EAF      		std Y+62,r24
 9879 2e46 E597      		sbiw r28,115-62
 9880 2e48 E796      		adiw r28,117-62
 9881 2e4a 7FAF      		std Y+63,r23
 9882 2e4c 6EAF      		std Y+62,r22
 9883 2e4e E797      		sbiw r28,117-62
5128:ff.c          **** 	FRESULT res;
5129:ff.c          **** 	DIR djo, djn;
5130:ff.c          **** 	FATFS *fs;
5131:ff.c          **** 	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
5132:ff.c          **** 	LBA_t sect;
5133:ff.c          **** 	DEF_NAMBUF
5134:ff.c          **** 
5135:ff.c          **** 
5136:ff.c          **** 	get_ldnumber(&path_new);						/* Snip the drive number of new name off */
 9884               		.loc 1 5136 0
 9885 2e50 CE01      		movw r24,r28
 9886               	.LVL936:
 9887 2e52 8B58      		subi r24,-117
 9888 2e54 9F4F      		sbci r25,-1
 9889 2e56 0E94 0000 		call get_ldnumber
 9890               	.LVL937:
5137:ff.c          **** 	res = mount_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
 9891               		.loc 1 5137 0
 9892 2e5a 42E0      		ldi r20,lo8(2)
 9893 2e5c BE01      		movw r22,r28
 9894 2e5e 6F58      		subi r22,-113
 9895 2e60 7F4F      		sbci r23,-1
 9896 2e62 CE01      		movw r24,r28
 9897 2e64 8D58      		subi r24,-115
 9898 2e66 9F4F      		sbci r25,-1
 9899 2e68 0E94 0000 		call mount_volume
 9900               	.LVL938:
5138:ff.c          **** 	if (res == FR_OK) {
 9901               		.loc 1 5138 0
 9902 2e6c 8111      		cpse r24,__zero_reg__
 9903 2e6e 00C0      		rjmp .L694
5139:ff.c          **** 		djo.obj.fs = fs;
 9904               		.loc 1 5139 0
 9905 2e70 E396      		adiw r28,113-62
 9906 2e72 8EAD      		ldd r24,Y+62
 9907 2e74 9FAD      		ldd r25,Y+63
 9908 2e76 E397      		sbiw r28,113-62
 9909               	.LVL939:
 9910 2e78 9AA7      		std Y+42,r25
 9911 2e7a 89A7      		std Y+41,r24
5140:ff.c          **** 		INIT_NAMBUF(fs);
5141:ff.c          **** 		res = follow_path(&djo, path_old);		/* Check old object */
 9912               		.loc 1 5141 0
 9913 2e7c E596      		adiw r28,115-62
 9914 2e7e 6EAD      		ldd r22,Y+62
 9915 2e80 7FAD      		ldd r23,Y+63
 9916 2e82 E597      		sbiw r28,115-62
 9917 2e84 CE01      		movw r24,r28
 9918 2e86 8996      		adiw r24,41
 9919 2e88 0E94 0000 		call follow_path
 9920               	.LVL940:
5142:ff.c          **** 		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check vali
 9921               		.loc 1 5142 0
 9922 2e8c 8111      		cpse r24,__zero_reg__
 9923 2e8e 00C0      		rjmp .L694
 9924               		.loc 1 5142 0 is_stmt 0 discriminator 1
 9925 2e90 6196      		adiw r28,80-63
 9926 2e92 8FAD      		ldd r24,Y+63
 9927 2e94 6197      		sbiw r28,80-63
 9928               	.LVL941:
 9929 2e96 807A      		andi r24,lo8(-96)
 9930 2e98 01F0      		breq .+2
 9931 2e9a 00C0      		rjmp .L690
 9932               	.LVL942:
 9933               	.LBB372:
 9934               	.LBB373:
 9935 2e9c 2596      		adiw r28,67-62
 9936 2e9e 6EAD      		ldd r22,Y+62
 9937 2ea0 7FAD      		ldd r23,Y+63
 9938 2ea2 2597      		sbiw r28,67-62
 9939 2ea4 40E2      		ldi r20,lo8(32)
 9940 2ea6 50E0      		ldi r21,0
 9941 2ea8 CE01      		movw r24,r28
 9942 2eaa 8F5A      		subi r24,-81
 9943 2eac 9F4F      		sbci r25,-1
 9944 2eae 0E94 0000 		call mem_cpy.part.0
 9945               	.LVL943:
 9946               	.LBE373:
 9947               	.LBE372:
 9948               	.LBB374:
 9949               	.LBB375:
 9950 2eb2 48E2      		ldi r20,lo8(40)
 9951 2eb4 50E0      		ldi r21,0
 9952 2eb6 BE01      		movw r22,r28
 9953 2eb8 675D      		subi r22,-41
 9954 2eba 7F4F      		sbci r23,-1
 9955 2ebc CE01      		movw r24,r28
 9956 2ebe 0196      		adiw r24,1
 9957 2ec0 0E94 0000 		call mem_cpy.part.0
 9958               	.LVL944:
 9959               	.LBE375:
 9960               	.LBE374:
5143:ff.c          **** #if FF_FS_LOCK != 0
5144:ff.c          **** 		if (res == FR_OK) {
5145:ff.c          **** 			res = chk_lock(&djo, 2);
5146:ff.c          **** 		}
5147:ff.c          **** #endif
5148:ff.c          **** 		if (res == FR_OK) {						/* Object to be renamed is found */
5149:ff.c          **** #if FF_FS_EXFAT
5150:ff.c          **** 			if (fs->fs_type == FS_EXFAT) {	/* At exFAT volume */
5151:ff.c          **** 				BYTE nf, nn;
5152:ff.c          **** 				WORD nh;
5153:ff.c          **** 
5154:ff.c          **** 				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
5155:ff.c          **** 				mem_cpy(&djn, &djo, sizeof djo);
5156:ff.c          **** 				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
5157:ff.c          **** 				if (res == FR_OK) {						/* Is new name already in use by any other object? */
5158:ff.c          **** 					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
5159:ff.c          **** 				}
5160:ff.c          **** 				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
5161:ff.c          **** 					res = dir_register(&djn);			/* Register the new entry */
5162:ff.c          **** 					if (res == FR_OK) {
5163:ff.c          **** 						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
5164:ff.c          **** 						nh = ld_word(fs->dirbuf + XDIR_NameHash);
5165:ff.c          **** 						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);	/* Restore 85+C0 entry */
5166:ff.c          **** 						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
5167:ff.c          **** 						st_word(fs->dirbuf + XDIR_NameHash, nh);
5168:ff.c          **** 						if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;	/* Set archive attrib
5169:ff.c          **** /* Start of critical section where an interruption can cause a cross-link */
5170:ff.c          **** 						res = store_xdir(&djn);
5171:ff.c          **** 					}
5172:ff.c          **** 				}
5173:ff.c          **** 			} else
5174:ff.c          **** #endif
5175:ff.c          **** 			{	/* At FAT/FAT32 volume */
5176:ff.c          **** 				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
5177:ff.c          **** 				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
5178:ff.c          **** 				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 9961               		.loc 1 5178 0 is_stmt 1
 9962 2ec4 E796      		adiw r28,117-62
 9963 2ec6 6EAD      		ldd r22,Y+62
 9964 2ec8 7FAD      		ldd r23,Y+63
 9965 2eca E797      		sbiw r28,117-62
 9966 2ecc CE01      		movw r24,r28
 9967 2ece 0196      		adiw r24,1
 9968 2ed0 0E94 0000 		call follow_path
 9969               	.LVL945:
5179:ff.c          **** 				if (res == FR_OK) {						/* Is new name already in use by any other object? */
 9970               		.loc 1 5179 0
 9971 2ed4 8111      		cpse r24,__zero_reg__
 9972 2ed6 00C0      		rjmp .L700
5180:ff.c          **** 					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 9973               		.loc 1 5180 0
 9974 2ed8 4F81      		ldd r20,Y+7
 9975 2eda 5885      		ldd r21,Y+8
 9976 2edc 6985      		ldd r22,Y+9
 9977 2ede 7A85      		ldd r23,Y+10
 9978 2ee0 8FA5      		ldd r24,Y+47
 9979 2ee2 98A9      		ldd r25,Y+48
 9980 2ee4 A9A9      		ldd r26,Y+49
 9981 2ee6 BAA9      		ldd r27,Y+50
 9982               	.LVL946:
 9983 2ee8 4817      		cp r20,r24
 9984 2eea 5907      		cpc r21,r25
 9985 2eec 6A07      		cpc r22,r26
 9986 2eee 7B07      		cpc r23,r27
 9987 2ef0 01F0      		breq .+2
 9988 2ef2 00C0      		rjmp .L691
 9989               		.loc 1 5180 0 is_stmt 0 discriminator 1
 9990 2ef4 4F85      		ldd r20,Y+15
 9991 2ef6 5889      		ldd r21,Y+16
 9992 2ef8 6989      		ldd r22,Y+17
 9993 2efa 7A89      		ldd r23,Y+18
 9994 2efc 8FA9      		ldd r24,Y+55
 9995 2efe 98AD      		ldd r25,Y+56
 9996 2f00 A9AD      		ldd r26,Y+57
 9997 2f02 BAAD      		ldd r27,Y+58
 9998 2f04 4817      		cp r20,r24
 9999 2f06 5907      		cpc r21,r25
 10000 2f08 6A07      		cpc r22,r26
 10001 2f0a 7B07      		cpc r23,r27
 10002 2f0c 01F0      		breq .+2
 10003 2f0e 00C0      		rjmp .L691
 10004 2f10 00C0      		rjmp .L682
 10005               	.LVL947:
 10006               	.L700:
5181:ff.c          **** 				}
5182:ff.c          **** 				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 10007               		.loc 1 5182 0 is_stmt 1
 10008 2f12 8430      		cpi r24,lo8(4)
 10009 2f14 01F0      		breq .+2
 10010 2f16 00C0      		rjmp .L694
 10011               	.LVL948:
 10012               	.L682:
5183:ff.c          **** 					res = dir_register(&djn);			/* Register the new entry */
 10013               		.loc 1 5183 0
 10014 2f18 CE01      		movw r24,r28
 10015 2f1a 0196      		adiw r24,1
 10016 2f1c 0E94 0000 		call dir_register
 10017               	.LVL949:
5184:ff.c          **** 					if (res == FR_OK) {
 10018               		.loc 1 5184 0
 10019 2f20 8111      		cpse r24,__zero_reg__
 10020 2f22 00C0      		rjmp .L694
5185:ff.c          **** 						dir = djn.dir;					/* Copy directory entry of the object except name */
 10021               		.loc 1 5185 0
 10022 2f24 0B8D      		ldd r16,Y+27
 10023 2f26 1C8D      		ldd r17,Y+28
 10024               	.LVL950:
 10025               	.LBB376:
 10026               	.LBB377:
 10027 2f28 61E5      		ldi r22,lo8(81)
 10028 2f2a 70E0      		ldi r23,0
 10029 2f2c 6C0F      		add r22,r28
 10030 2f2e 7D1F      		adc r23,r29
 10031 2f30 635F      		subi r22,-13
 10032 2f32 7F4F      		sbci r23,-1
 10033 2f34 43E1      		ldi r20,lo8(19)
 10034 2f36 50E0      		ldi r21,0
 10035 2f38 C801      		movw r24,r16
 10036               	.LVL951:
 10037 2f3a 0D96      		adiw r24,13
 10038               	.LVL952:
 10039 2f3c 0E94 0000 		call mem_cpy.part.0
 10040               	.LVL953:
 10041               	.LBE377:
 10042               	.LBE376:
5186:ff.c          **** 						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
5187:ff.c          **** 						dir[DIR_Attr] = buf[DIR_Attr];
 10043               		.loc 1 5187 0
 10044 2f40 6D96      		adiw r28,92-63
 10045 2f42 8FAD      		ldd r24,Y+63
 10046 2f44 6D97      		sbiw r28,92-63
5188:ff.c          **** 						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a f
 10047               		.loc 1 5188 0
 10048 2f46 84FF      		sbrs r24,4
 10049               		.loc 1 5188 0 is_stmt 0 discriminator 1
 10050 2f48 8062      		ori r24,lo8(32)
 10051               	.L699:
 10052 2f4a F801      		movw r30,r16
 10053 2f4c 8387      		std Z+11,r24
5189:ff.c          **** 						fs->wflag = 1;
 10054               		.loc 1 5189 0 is_stmt 1 discriminator 1
 10055 2f4e E396      		adiw r28,113-62
 10056 2f50 EEAC      		ldd r14,Y+62
 10057 2f52 FFAC      		ldd r15,Y+63
 10058 2f54 E397      		sbiw r28,113-62
 10059 2f56 DD24      		clr r13
 10060 2f58 D394      		inc r13
 10061 2f5a F701      		movw r30,r14
 10062 2f5c D382      		std Z+3,r13
5190:ff.c          **** 						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the
 10063               		.loc 1 5190 0 discriminator 1
 10064 2f5e F801      		movw r30,r16
 10065 2f60 8385      		ldd r24,Z+11
 10066 2f62 84FF      		sbrs r24,4
 10067 2f64 00C0      		rjmp .L686
 10068 2f66 4FA5      		ldd r20,Y+47
 10069 2f68 58A9      		ldd r21,Y+48
 10070 2f6a 69A9      		ldd r22,Y+49
 10071 2f6c 7AA9      		ldd r23,Y+50
 10072 2f6e 8F81      		ldd r24,Y+7
 10073 2f70 9885      		ldd r25,Y+8
 10074 2f72 A985      		ldd r26,Y+9
 10075 2f74 BA85      		ldd r27,Y+10
 10076 2f76 4817      		cp r20,r24
 10077 2f78 5907      		cpc r21,r25
 10078 2f7a 6A07      		cpc r22,r26
 10079 2f7c 7B07      		cpc r23,r27
 10080 2f7e 01F0      		breq .L686
5191:ff.c          **** 							sect = clst2sect(fs, ld_clust(fs, dir));
 10081               		.loc 1 5191 0
 10082 2f80 B801      		movw r22,r16
 10083 2f82 F701      		movw r30,r14
 10084 2f84 8081      		ld r24,Z
 10085 2f86 0E94 0000 		call ld_clust.isra.3
 10086               	.LVL954:
 10087 2f8a AB01      		movw r20,r22
 10088 2f8c BC01      		movw r22,r24
 10089 2f8e C701      		movw r24,r14
 10090 2f90 0E94 0000 		call clst2sect
 10091               	.LVL955:
 10092 2f94 AB01      		movw r20,r22
 10093 2f96 BC01      		movw r22,r24
 10094               	.LVL956:
5192:ff.c          **** 							if (sect == 0) {
 10095               		.loc 1 5192 0
 10096 2f98 4115      		cp r20,__zero_reg__
 10097 2f9a 5105      		cpc r21,__zero_reg__
 10098 2f9c 6105      		cpc r22,__zero_reg__
 10099 2f9e 7105      		cpc r23,__zero_reg__
 10100 2fa0 01F4      		brne .+2
 10101 2fa2 00C0      		rjmp .L692
5193:ff.c          **** 								res = FR_INT_ERR;
5194:ff.c          **** 							} else {
5195:ff.c          **** /* Start of critical section where an interruption can cause a cross-link */
5196:ff.c          **** 								res = move_window(fs, sect);
 10102               		.loc 1 5196 0
 10103 2fa4 C701      		movw r24,r14
 10104 2fa6 0E94 0000 		call move_window
 10105               	.LVL957:
5197:ff.c          **** 								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
5198:ff.c          **** 								if (res == FR_OK && dir[1] == '.') {
 10106               		.loc 1 5198 0
 10107 2faa 8111      		cpse r24,__zero_reg__
 10108 2fac 00C0      		rjmp .L694
5197:ff.c          **** 								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 10109               		.loc 1 5197 0 discriminator 1
 10110 2fae E396      		adiw r28,113-62
 10111 2fb0 8EAD      		ldd r24,Y+62
 10112 2fb2 9FAD      		ldd r25,Y+63
 10113 2fb4 E397      		sbiw r28,113-62
 10114               	.LVL958:
 10115               		.loc 1 5198 0 discriminator 1
 10116 2fb6 FC01      		movw r30,r24
 10117 2fb8 E05B      		subi r30,-80
 10118 2fba FF4F      		sbci r31,-1
 10119 2fbc 2081      		ld r18,Z
 10120 2fbe 2E32      		cpi r18,lo8(46)
 10121 2fc0 01F4      		brne .L686
5199:ff.c          **** 									st_clust(fs, dir, djn.obj.sclust);
 10122               		.loc 1 5199 0
 10123 2fc2 2F81      		ldd r18,Y+7
 10124 2fc4 3885      		ldd r19,Y+8
 10125 2fc6 4985      		ldd r20,Y+9
 10126 2fc8 5A85      		ldd r21,Y+10
5197:ff.c          **** 								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 10127               		.loc 1 5197 0
 10128 2fca BC01      		movw r22,r24
 10129 2fcc 615B      		subi r22,-79
 10130 2fce 7F4F      		sbci r23,-1
 10131               		.loc 1 5199 0
 10132 2fd0 0E94 0000 		call st_clust.isra.4
 10133               	.LVL959:
5200:ff.c          **** 									fs->wflag = 1;
 10134               		.loc 1 5200 0
 10135 2fd4 E396      		adiw r28,113-62
 10136 2fd6 EEAD      		ldd r30,Y+62
 10137 2fd8 FFAD      		ldd r31,Y+63
 10138 2fda E397      		sbiw r28,113-62
 10139 2fdc D382      		std Z+3,r13
 10140 2fde 00C0      		rjmp .L686
 10141               	.LVL960:
 10142               	.L690:
5142:ff.c          **** #if FF_FS_LOCK != 0
 10143               		.loc 1 5142 0
 10144 2fe0 86E0      		ldi r24,lo8(6)
 10145               	.LVL961:
 10146 2fe2 00C0      		rjmp .L694
 10147               	.LVL962:
 10148               	.L686:
 10149               	.LBB378:
 10150               	.LBB379:
2634:ff.c          **** #if FF_USE_LFN		/* LFN configuration */
 10151               		.loc 1 2634 0
 10152 2fe4 09A5      		ldd r16,Y+41
 10153 2fe6 1AA5      		ldd r17,Y+42
 10154               	.LVL963:
2656:ff.c          **** 	if (res == FR_OK) {
 10155               		.loc 1 2656 0
 10156 2fe8 2396      		adiw r28,63-60
 10157 2fea 4CAD      		ldd r20,Y+60
 10158 2fec 5DAD      		ldd r21,Y+61
 10159 2fee 6EAD      		ldd r22,Y+62
 10160 2ff0 7FAD      		ldd r23,Y+63
 10161 2ff2 2397      		sbiw r28,63-60
 10162 2ff4 C801      		movw r24,r16
 10163 2ff6 0E94 0000 		call move_window
 10164               	.LVL964:
2657:ff.c          **** 		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
 10165               		.loc 1 2657 0
 10166 2ffa 8111      		cpse r24,__zero_reg__
 10167 2ffc 00C0      		rjmp .L694
2658:ff.c          **** 		fs->wflag = 1;
 10168               		.loc 1 2658 0
 10169 2ffe 2596      		adiw r28,67-62
 10170 3000 EEAD      		ldd r30,Y+62
 10171 3002 FFAD      		ldd r31,Y+63
 10172 3004 2597      		sbiw r28,67-62
 10173 3006 85EE      		ldi r24,lo8(-27)
 10174               	.LVL965:
 10175 3008 8083      		st Z,r24
2659:ff.c          **** 	}
 10176               		.loc 1 2659 0
 10177 300a 81E0      		ldi r24,lo8(1)
 10178 300c F801      		movw r30,r16
 10179 300e 8383      		std Z+3,r24
 10180               	.LVL966:
 10181               	.LBE379:
 10182               	.LBE378:
5201:ff.c          **** 								}
5202:ff.c          **** 							}
5203:ff.c          **** 						}
5204:ff.c          **** 					}
5205:ff.c          **** 				}
5206:ff.c          **** 			}
5207:ff.c          **** 			if (res == FR_OK) {
5208:ff.c          **** 				res = dir_remove(&djo);		/* Remove old entry */
5209:ff.c          **** 				if (res == FR_OK) {
5210:ff.c          **** 					res = sync_fs(fs);
 10183               		.loc 1 5210 0
 10184 3010 E396      		adiw r28,113-62
 10185 3012 8EAD      		ldd r24,Y+62
 10186 3014 9FAD      		ldd r25,Y+63
 10187 3016 E397      		sbiw r28,113-62
 10188 3018 0E94 0000 		call sync_fs
 10189               	.LVL967:
 10190 301c 00C0      		rjmp .L694
 10191               	.L691:
 10192 301e 88E0      		ldi r24,lo8(8)
 10193 3020 00C0      		rjmp .L694
 10194               	.LVL968:
 10195               	.L692:
5193:ff.c          **** 							} else {
 10196               		.loc 1 5193 0
 10197 3022 82E0      		ldi r24,lo8(2)
 10198               	.LVL969:
 10199               	.L694:
 10200               	/* epilogue start */
5211:ff.c          **** 				}
5212:ff.c          **** 			}
5213:ff.c          **** /* End of the critical section */
5214:ff.c          **** 		}
5215:ff.c          **** 		FREE_NAMBUF();
5216:ff.c          **** 	}
5217:ff.c          **** 
5218:ff.c          **** 	LEAVE_FF(fs, res);
5219:ff.c          **** }
 10201               		.loc 1 5219 0
 10202 3024 CA58      		subi r28,-118
 10203 3026 DF4F      		sbci r29,-1
 10204 3028 0FB6      		in __tmp_reg__,__SREG__
 10205 302a F894      		cli
 10206 302c DEBF      		out __SP_H__,r29
 10207 302e 0FBE      		out __SREG__,__tmp_reg__
 10208 3030 CDBF      		out __SP_L__,r28
 10209 3032 DF91      		pop r29
 10210 3034 CF91      		pop r28
 10211 3036 1F91      		pop r17
 10212 3038 0F91      		pop r16
 10213 303a FF90      		pop r15
 10214 303c EF90      		pop r14
 10215 303e DF90      		pop r13
 10216 3040 0895      		ret
 10217               		.cfi_endproc
 10218               	.LFE51:
 10220               		.section	.rodata
 10223               	ExCvt:
 10224 0000 80        		.byte	-128
 10225 0001 9A        		.byte	-102
 10226 0002 90        		.byte	-112
 10227 0003 B6        		.byte	-74
 10228 0004 8E        		.byte	-114
 10229 0005 DE        		.byte	-34
 10230 0006 8F        		.byte	-113
 10231 0007 80        		.byte	-128
 10232 0008 9D        		.byte	-99
 10233 0009 D3        		.byte	-45
 10234 000a 8A        		.byte	-118
 10235 000b 8A        		.byte	-118
 10236 000c D7        		.byte	-41
 10237 000d 8D        		.byte	-115
 10238 000e 8E        		.byte	-114
 10239 000f 8F        		.byte	-113
 10240 0010 90        		.byte	-112
 10241 0011 91        		.byte	-111
 10242 0012 91        		.byte	-111
 10243 0013 E2        		.byte	-30
 10244 0014 99        		.byte	-103
 10245 0015 95        		.byte	-107
 10246 0016 95        		.byte	-107
 10247 0017 97        		.byte	-105
 10248 0018 97        		.byte	-105
 10249 0019 99        		.byte	-103
 10250 001a 9A        		.byte	-102
 10251 001b 9B        		.byte	-101
 10252 001c 9B        		.byte	-101
 10253 001d 9D        		.byte	-99
 10254 001e 9E        		.byte	-98
 10255 001f AC        		.byte	-84
 10256 0020 B5        		.byte	-75
 10257 0021 D6        		.byte	-42
 10258 0022 E0        		.byte	-32
 10259 0023 E9        		.byte	-23
 10260 0024 A4        		.byte	-92
 10261 0025 A4        		.byte	-92
 10262 0026 A6        		.byte	-90
 10263 0027 A6        		.byte	-90
 10264 0028 A8        		.byte	-88
 10265 0029 A8        		.byte	-88
 10266 002a AA        		.byte	-86
 10267 002b 8D        		.byte	-115
 10268 002c AC        		.byte	-84
 10269 002d B8        		.byte	-72
 10270 002e AE        		.byte	-82
 10271 002f AF        		.byte	-81
 10272 0030 B0        		.byte	-80
 10273 0031 B1        		.byte	-79
 10274 0032 B2        		.byte	-78
 10275 0033 B3        		.byte	-77
 10276 0034 B4        		.byte	-76
 10277 0035 B5        		.byte	-75
 10278 0036 B6        		.byte	-74
 10279 0037 B7        		.byte	-73
 10280 0038 B8        		.byte	-72
 10281 0039 B9        		.byte	-71
 10282 003a BA        		.byte	-70
 10283 003b BB        		.byte	-69
 10284 003c BC        		.byte	-68
 10285 003d BD        		.byte	-67
 10286 003e BD        		.byte	-67
 10287 003f BF        		.byte	-65
 10288 0040 C0        		.byte	-64
 10289 0041 C1        		.byte	-63
 10290 0042 C2        		.byte	-62
 10291 0043 C3        		.byte	-61
 10292 0044 C4        		.byte	-60
 10293 0045 C5        		.byte	-59
 10294 0046 C6        		.byte	-58
 10295 0047 C6        		.byte	-58
 10296 0048 C8        		.byte	-56
 10297 0049 C9        		.byte	-55
 10298 004a CA        		.byte	-54
 10299 004b CB        		.byte	-53
 10300 004c CC        		.byte	-52
 10301 004d CD        		.byte	-51
 10302 004e CE        		.byte	-50
 10303 004f CF        		.byte	-49
 10304 0050 D1        		.byte	-47
 10305 0051 D1        		.byte	-47
 10306 0052 D2        		.byte	-46
 10307 0053 D3        		.byte	-45
 10308 0054 D2        		.byte	-46
 10309 0055 D5        		.byte	-43
 10310 0056 D6        		.byte	-42
 10311 0057 D7        		.byte	-41
 10312 0058 B7        		.byte	-73
 10313 0059 D9        		.byte	-39
 10314 005a DA        		.byte	-38
 10315 005b DB        		.byte	-37
 10316 005c DC        		.byte	-36
 10317 005d DD        		.byte	-35
 10318 005e DE        		.byte	-34
 10319 005f DF        		.byte	-33
 10320 0060 E0        		.byte	-32
 10321 0061 E1        		.byte	-31
 10322 0062 E2        		.byte	-30
 10323 0063 E3        		.byte	-29
 10324 0064 E3        		.byte	-29
 10325 0065 D5        		.byte	-43
 10326 0066 E6        		.byte	-26
 10327 0067 E6        		.byte	-26
 10328 0068 E8        		.byte	-24
 10329 0069 E9        		.byte	-23
 10330 006a E8        		.byte	-24
 10331 006b EB        		.byte	-21
 10332 006c ED        		.byte	-19
 10333 006d ED        		.byte	-19
 10334 006e DD        		.byte	-35
 10335 006f EF        		.byte	-17
 10336 0070 F0        		.byte	-16
 10337 0071 F1        		.byte	-15
 10338 0072 F2        		.byte	-14
 10339 0073 F3        		.byte	-13
 10340 0074 F4        		.byte	-12
 10341 0075 F5        		.byte	-11
 10342 0076 F6        		.byte	-10
 10343 0077 F7        		.byte	-9
 10344 0078 F8        		.byte	-8
 10345 0079 F9        		.byte	-7
 10346 007a FA        		.byte	-6
 10347 007b EB        		.byte	-21
 10348 007c FC        		.byte	-4
 10349 007d FC        		.byte	-4
 10350 007e FE        		.byte	-2
 10351 007f FF        		.byte	-1
 10352               		.local	Fsid
 10353               		.comm	Fsid,2,1
 10354               		.local	FatFs
 10355               		.comm	FatFs,2,1
 10356               		.text
 10357               	.Letext0:
 10358               		.file 2 "/usr/lib/avr/include/stdint.h"
 10359               		.file 3 "ff.h"
 10360               		.file 4 "diskio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ff.c
     /tmp/cc8TAbhH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8TAbhH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8TAbhH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8TAbhH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8TAbhH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8TAbhH.s:11     .text:0000000000000000 ld_dword
     /tmp/cc8TAbhH.s:55     .text:000000000000002a clst2sect
     /tmp/cc8TAbhH.s:123    .text:000000000000007a get_ldnumber
     /tmp/cc8TAbhH.s:210    .text:00000000000000c8 validate
     /tmp/cc8TAbhH.s:298    .text:000000000000011c mem_cpy.part.0
     /tmp/cc8TAbhH.s:330    .text:0000000000000132 ld_clust.isra.3
     /tmp/cc8TAbhH.s:372    .text:000000000000015c st_clust.isra.4
     /tmp/cc8TAbhH.s:419    .text:0000000000000176 get_fileinfo.part.5
     /tmp/cc8TAbhH.s:565    .text:0000000000000214 sync_window
     /tmp/cc8TAbhH.s:713    .text:00000000000002bc move_window.part.7
     /tmp/cc8TAbhH.s:819    .text:0000000000000320 move_window
     /tmp/cc8TAbhH.s:869    .text:0000000000000348 check_fs.part.8
     /tmp/cc8TAbhH.s:1048   .text:0000000000000402 get_fat.isra.10
     /tmp/cc8TAbhH.s:1337   .text:0000000000000582 dir_sdi.constprop.15
     /tmp/cc8TAbhH.s:1551   .text:0000000000000680 dir_clear
     /tmp/cc8TAbhH.s:1728   .text:0000000000000732 mount_volume
     /tmp/cc8TAbhH.s:10353  .bss:0000000000000002 FatFs
                             .bss:0000000000000000 Fsid
     /tmp/cc8TAbhH.s:2700   .text:0000000000000c60 put_fat
     /tmp/cc8TAbhH.s:3139   .text:0000000000000e96 create_chain
     /tmp/cc8TAbhH.s:3619   .text:0000000000001118 dir_next
     /tmp/cc8TAbhH.s:3965   .text:00000000000012e2 follow_path
     /tmp/cc8TAbhH.s:10223  .rodata:0000000000000000 ExCvt
     /tmp/cc8TAbhH.s:4503   .text:0000000000001518 dir_read.constprop.13
     /tmp/cc8TAbhH.s:4630   .text:0000000000001596 dir_register
     /tmp/cc8TAbhH.s:4811   .text:0000000000001648 remove_chain
     /tmp/cc8TAbhH.s:5050   .text:0000000000001766 sync_fs
     /tmp/cc8TAbhH.s:5281   .text:0000000000001848 f_mount
     /tmp/cc8TAbhH.s:5404   .text:00000000000018cc f_open
     /tmp/cc8TAbhH.s:6081   .text:0000000000001c0c f_read
     /tmp/cc8TAbhH.s:6612   .text:0000000000001ea8 f_write
     /tmp/cc8TAbhH.s:7251   .text:00000000000021fe f_sync
     /tmp/cc8TAbhH.s:7426   .text:00000000000022aa f_close
     /tmp/cc8TAbhH.s:7496   .text:00000000000022e6 f_lseek
     /tmp/cc8TAbhH.s:8074   .text:000000000000261a f_opendir
     /tmp/cc8TAbhH.s:8235   .text:00000000000026cc f_closedir
     /tmp/cc8TAbhH.s:8297   .text:00000000000026fe f_readdir
     /tmp/cc8TAbhH.s:8431   .text:0000000000002782 f_stat
     /tmp/cc8TAbhH.s:8562   .text:0000000000002812 f_getfree
     /tmp/cc8TAbhH.s:8978   .text:0000000000002a12 f_truncate
     /tmp/cc8TAbhH.s:9183   .text:0000000000002b1e f_unlink
     /tmp/cc8TAbhH.s:9443   .text:0000000000002c5e f_mkdir
     /tmp/cc8TAbhH.s:9826   .text:0000000000002e20 f_rename
     /tmp/cc8TAbhH.s:865    .rodata.str1.1:0000000000000000 .LC0

UNDEFINED SYMBOLS
__muluhisi3
disk_status
disk_write
disk_read
disk_initialize
__udivmodsi4
disk_ioctl
__do_copy_data
__do_clear_bss
