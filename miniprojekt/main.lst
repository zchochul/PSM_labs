   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 546D 696E 		.string	"Tmin = %.1f\n"
  12      203D 2025 
  12      2E31 660A 
  12      00
  13               	.LC1:
  14 000d 506F 6461 		.string	"Podaj Tmax: "
  14      6A20 546D 
  14      6178 3A20 
  14      00
  15               	.LC2:
  16 001a 546D 6178 		.string	"Tmax = %.1f\n"
  16      203D 2025 
  16      2E31 660A 
  16      00
  17               	.LC3:
  18 0027 506F 6461 		.string	"Podaj Tmin: "
  18      6A20 546D 
  18      696E 3A20 
  18      00
  19               		.text
  20               	.global	__vector_13
  22               	__vector_13:
  23               	.LFB11:
  24               		.file 1 "main.c"
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <stdlib.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** 
   5:main.c        **** #include "lcd.h"
   6:main.c        **** #include "i1wire.h"
   7:main.c        **** #include "usart.h"
   8:main.c        **** 
   9:main.c        **** FILE u_stream = FDEV_SETUP_STREAM(u_putc, NULL, _FDEV_SETUP_WRITE);
  10:main.c        **** FILE lcd_stream = FDEV_SETUP_STREAM(lcd_putc, NULL, _FDEV_SETUP_WRITE);
  11:main.c        **** 
  12:main.c        **** uint8_t tab[10];
  13:main.c        **** uint8_t i;
  14:main.c        **** uint8_t etap = 0;
  15:main.c        **** int x,y; 
  16:main.c        **** float T1, T2;
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** ISR(USART_RXC_vect){
  25               		.loc 1 19 0
  26               		.cfi_startproc
  27 0000 1F92      		push r1
  28               	.LCFI0:
  29               		.cfi_def_cfa_offset 3
  30               		.cfi_offset 1, -2
  31 0002 0F92      		push r0
  32               	.LCFI1:
  33               		.cfi_def_cfa_offset 4
  34               		.cfi_offset 0, -3
  35 0004 0FB6      		in r0,__SREG__
  36 0006 0F92      		push r0
  37 0008 1124      		clr __zero_reg__
  38 000a 2F93      		push r18
  39               	.LCFI2:
  40               		.cfi_def_cfa_offset 5
  41               		.cfi_offset 18, -4
  42 000c 3F93      		push r19
  43               	.LCFI3:
  44               		.cfi_def_cfa_offset 6
  45               		.cfi_offset 19, -5
  46 000e 4F93      		push r20
  47               	.LCFI4:
  48               		.cfi_def_cfa_offset 7
  49               		.cfi_offset 20, -6
  50 0010 5F93      		push r21
  51               	.LCFI5:
  52               		.cfi_def_cfa_offset 8
  53               		.cfi_offset 21, -7
  54 0012 6F93      		push r22
  55               	.LCFI6:
  56               		.cfi_def_cfa_offset 9
  57               		.cfi_offset 22, -8
  58 0014 7F93      		push r23
  59               	.LCFI7:
  60               		.cfi_def_cfa_offset 10
  61               		.cfi_offset 23, -9
  62 0016 8F93      		push r24
  63               	.LCFI8:
  64               		.cfi_def_cfa_offset 11
  65               		.cfi_offset 24, -10
  66 0018 9F93      		push r25
  67               	.LCFI9:
  68               		.cfi_def_cfa_offset 12
  69               		.cfi_offset 25, -11
  70 001a AF93      		push r26
  71               	.LCFI10:
  72               		.cfi_def_cfa_offset 13
  73               		.cfi_offset 26, -12
  74 001c BF93      		push r27
  75               	.LCFI11:
  76               		.cfi_def_cfa_offset 14
  77               		.cfi_offset 27, -13
  78 001e EF93      		push r30
  79               	.LCFI12:
  80               		.cfi_def_cfa_offset 15
  81               		.cfi_offset 30, -14
  82 0020 FF93      		push r31
  83               	.LCFI13:
  84               		.cfi_def_cfa_offset 16
  85               		.cfi_offset 31, -15
  86               	/* prologue: Signal */
  87               	/* frame size = 0 */
  88               	/* stack size = 15 */
  89               	.L__stack_usage = 15
  20:main.c        **** 	tab[i] = UDR;
  90               		.loc 1 20 0
  91 0022 8091 0000 		lds r24,i
  92 0026 9CB1      		in r25,0xc
  93 0028 E82F      		mov r30,r24
  94 002a F0E0      		ldi r31,0
  95 002c E050      		subi r30,lo8(-(tab))
  96 002e F040      		sbci r31,hi8(-(tab))
  97 0030 9083      		st Z,r25
  21:main.c        **** 	if(tab[i]=='\n'){
  98               		.loc 1 21 0
  99 0032 9A30      		cpi r25,lo8(10)
 100 0034 01F0      		breq .+2
 101 0036 00C0      		rjmp .L2
  22:main.c        **** 		if(etap==0){
 102               		.loc 1 22 0
 103 0038 8091 0000 		lds r24,etap
 104 003c 8111      		cpse r24,__zero_reg__
 105 003e 00C0      		rjmp .L3
  23:main.c        **** 			T1 = atof((const char*)tab);
 106               		.loc 1 23 0
 107 0040 80E0      		ldi r24,lo8(tab)
 108 0042 90E0      		ldi r25,hi8(tab)
 109 0044 0E94 0000 		call atof
 110 0048 9B01      		movw r18,r22
 111 004a AC01      		movw r20,r24
 112 004c CB01      		movw r24,r22
 113 004e DA01      		movw r26,r20
 114 0050 8093 0000 		sts T1,r24
 115 0054 9093 0000 		sts T1+1,r25
 116 0058 A093 0000 		sts T1+2,r26
 117 005c B093 0000 		sts T1+3,r27
  24:main.c        **** 			fprintf(&u_stream, "Tmin = %.1f\n", T1);
 118               		.loc 1 24 0
 119 0060 5F93      		push r21
 120               	.LCFI14:
 121               		.cfi_def_cfa_offset 17
 122 0062 4F93      		push r20
 123               	.LCFI15:
 124               		.cfi_def_cfa_offset 18
 125 0064 3F93      		push r19
 126               	.LCFI16:
 127               		.cfi_def_cfa_offset 19
 128 0066 2F93      		push r18
 129               	.LCFI17:
 130               		.cfi_def_cfa_offset 20
 131 0068 80E0      		ldi r24,lo8(.LC0)
 132 006a 90E0      		ldi r25,hi8(.LC0)
 133 006c 9F93      		push r25
 134               	.LCFI18:
 135               		.cfi_def_cfa_offset 21
 136 006e 8F93      		push r24
 137               	.LCFI19:
 138               		.cfi_def_cfa_offset 22
 139 0070 80E0      		ldi r24,lo8(u_stream)
 140 0072 90E0      		ldi r25,hi8(u_stream)
 141 0074 9F93      		push r25
 142               	.LCFI20:
 143               		.cfi_def_cfa_offset 23
 144 0076 8F93      		push r24
 145               	.LCFI21:
 146               		.cfi_def_cfa_offset 24
 147 0078 0E94 0000 		call fprintf
  25:main.c        **** 			fprintf(&u_stream, "Podaj Tmax: ");
 148               		.loc 1 25 0
 149 007c 60E0      		ldi r22,lo8(u_stream)
 150 007e 70E0      		ldi r23,hi8(u_stream)
 151 0080 80E0      		ldi r24,lo8(.LC1)
 152 0082 90E0      		ldi r25,hi8(.LC1)
 153 0084 0E94 0000 		call fputs
 154 0088 8DB7      		in r24,__SP_L__
 155 008a 9EB7      		in r25,__SP_H__
 156 008c 0896      		adiw r24,8
 157 008e 0FB6      		in __tmp_reg__,__SREG__
 158 0090 F894      		cli
 159 0092 9EBF      		out __SP_H__,r25
 160 0094 0FBE      		out __SREG__,__tmp_reg__
 161 0096 8DBF      		out __SP_L__,r24
 162               	.LCFI22:
 163               		.cfi_def_cfa_offset 16
 164               	.L3:
  26:main.c        **** 		}
  27:main.c        **** 		if(etap==1){
 165               		.loc 1 27 0
 166 0098 8091 0000 		lds r24,etap
 167 009c 8130      		cpi r24,lo8(1)
 168 009e 01F4      		brne .L4
  28:main.c        **** 			T2 = atof((const char*)tab);
 169               		.loc 1 28 0
 170 00a0 80E0      		ldi r24,lo8(tab)
 171 00a2 90E0      		ldi r25,hi8(tab)
 172 00a4 0E94 0000 		call atof
 173 00a8 9B01      		movw r18,r22
 174 00aa AC01      		movw r20,r24
 175 00ac CB01      		movw r24,r22
 176 00ae DA01      		movw r26,r20
 177 00b0 8093 0000 		sts T2,r24
 178 00b4 9093 0000 		sts T2+1,r25
 179 00b8 A093 0000 		sts T2+2,r26
 180 00bc B093 0000 		sts T2+3,r27
  29:main.c        **** 			fprintf(&u_stream, "Tmax = %.1f\n", T2);
 181               		.loc 1 29 0
 182 00c0 5F93      		push r21
 183               	.LCFI23:
 184               		.cfi_def_cfa_offset 17
 185 00c2 4F93      		push r20
 186               	.LCFI24:
 187               		.cfi_def_cfa_offset 18
 188 00c4 3F93      		push r19
 189               	.LCFI25:
 190               		.cfi_def_cfa_offset 19
 191 00c6 2F93      		push r18
 192               	.LCFI26:
 193               		.cfi_def_cfa_offset 20
 194 00c8 80E0      		ldi r24,lo8(.LC2)
 195 00ca 90E0      		ldi r25,hi8(.LC2)
 196 00cc 9F93      		push r25
 197               	.LCFI27:
 198               		.cfi_def_cfa_offset 21
 199 00ce 8F93      		push r24
 200               	.LCFI28:
 201               		.cfi_def_cfa_offset 22
 202 00d0 80E0      		ldi r24,lo8(u_stream)
 203 00d2 90E0      		ldi r25,hi8(u_stream)
 204 00d4 9F93      		push r25
 205               	.LCFI29:
 206               		.cfi_def_cfa_offset 23
 207 00d6 8F93      		push r24
 208               	.LCFI30:
 209               		.cfi_def_cfa_offset 24
 210 00d8 0E94 0000 		call fprintf
  30:main.c        **** 			fprintf(&u_stream, "Podaj Tmin: ");
 211               		.loc 1 30 0
 212 00dc 60E0      		ldi r22,lo8(u_stream)
 213 00de 70E0      		ldi r23,hi8(u_stream)
 214 00e0 80E0      		ldi r24,lo8(.LC3)
 215 00e2 90E0      		ldi r25,hi8(.LC3)
 216 00e4 0E94 0000 		call fputs
 217 00e8 8DB7      		in r24,__SP_L__
 218 00ea 9EB7      		in r25,__SP_H__
 219 00ec 0896      		adiw r24,8
 220 00ee 0FB6      		in __tmp_reg__,__SREG__
 221 00f0 F894      		cli
 222 00f2 9EBF      		out __SP_H__,r25
 223 00f4 0FBE      		out __SREG__,__tmp_reg__
 224 00f6 8DBF      		out __SP_L__,r24
 225               	.LCFI31:
 226               		.cfi_def_cfa_offset 16
 227               	.L4:
  31:main.c        **** 		}
  32:main.c        **** 		if(etap==1) {
 228               		.loc 1 32 0
 229 00f8 8091 0000 		lds r24,etap
 230 00fc 8130      		cpi r24,lo8(1)
 231 00fe 01F4      		brne .L5
  33:main.c        **** 			etap=0;
 232               		.loc 1 33 0
 233 0100 1092 0000 		sts etap,__zero_reg__
 234 0104 00C0      		rjmp .L6
 235               	.L5:
  34:main.c        **** 		}
  35:main.c        **** 		else etap++;
 236               		.loc 1 35 0
 237 0106 8F5F      		subi r24,lo8(-(1))
 238 0108 8093 0000 		sts etap,r24
 239               	.L6:
  36:main.c        **** 		i=0;
 240               		.loc 1 36 0
 241 010c 1092 0000 		sts i,__zero_reg__
 242 0110 00C0      		rjmp .L1
 243               	.L2:
  37:main.c        **** 	} else {
  38:main.c        **** 		i++;
 244               		.loc 1 38 0
 245 0112 8F5F      		subi r24,lo8(-(1))
 246 0114 8093 0000 		sts i,r24
 247               	.L1:
 248               	/* epilogue start */
  39:main.c        **** 	}
  40:main.c        **** }
 249               		.loc 1 40 0
 250 0118 FF91      		pop r31
 251 011a EF91      		pop r30
 252 011c BF91      		pop r27
 253 011e AF91      		pop r26
 254 0120 9F91      		pop r25
 255 0122 8F91      		pop r24
 256 0124 7F91      		pop r23
 257 0126 6F91      		pop r22
 258 0128 5F91      		pop r21
 259 012a 4F91      		pop r20
 260 012c 3F91      		pop r19
 261 012e 2F91      		pop r18
 262 0130 0F90      		pop r0
 263 0132 0FBE      		out __SREG__,r0
 264 0134 0F90      		pop r0
 265 0136 1F90      		pop r1
 266 0138 1895      		reti
 267               		.cfi_endproc
 268               	.LFE11:
 270               		.section	.rodata.str1.1
 271               	.LC4:
 272 0034 0950 6F64 		.string	"\tPodaj Tmin: "
 272      616A 2054 
 272      6D69 6E3A 
 272      2000 
 273               	.global	__floatunsisf
 274               	.global	__mulsf3
 275               	.LC5:
 276 0042 5420 3D20 		.string	"T = %.4f"
 276      252E 3466 
 276      00
 277               	.LC6:
 278 004b 4300      		.string	"C"
 279               	.LC7:
 280 004d 5431 3D25 		.string	"T1=%.1f,T2=%.1f"
 280      2E31 662C 
 280      5432 3D25 
 280      2E31 6600 
 281               	.global	__gtsf2
 282               	.global	__ltsf2
 283               		.section	.text.startup,"ax",@progbits
 284               	.global	main
 286               	main:
 287               	.LFB12:
  41:main.c        **** 
  42:main.c        **** int main(void){
 288               		.loc 1 42 0
 289               		.cfi_startproc
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 0 */
 293               	.L__stack_usage = 0
  43:main.c        **** 	
  44:main.c        **** 	DDRD = 0xFF;
 294               		.loc 1 44 0
 295 0000 8FEF      		ldi r24,lo8(-1)
 296 0002 81BB      		out 0x11,r24
  45:main.c        **** 	PORTD = 0xFF; 
 297               		.loc 1 45 0
 298 0004 82BB      		out 0x12,r24
  46:main.c        **** 	
  47:main.c        **** 	lcdinit();
 299               		.loc 1 47 0
 300 0006 0E94 0000 		call lcdinit
  48:main.c        **** 	blink(0);	
 301               		.loc 1 48 0
 302 000a 80E0      		ldi r24,0
 303 000c 90E0      		ldi r25,0
 304 000e 0E94 0000 		call blink
  49:main.c        **** 	
  50:main.c        **** 	USART_Init(1);
 305               		.loc 1 50 0
 306 0012 81E0      		ldi r24,lo8(1)
 307 0014 90E0      		ldi r25,0
 308 0016 0E94 0000 		call USART_Init
  51:main.c        **** 	
  52:main.c        **** 	OW_reset();
 309               		.loc 1 52 0
 310 001a 0E94 0000 		call OW_reset
  53:main.c        **** 	uint16_t temp;
  54:main.c        **** 	float T;
  55:main.c        **** 	
  56:main.c        **** 	//Poczatkowe wartosci Tmin i Tmax
  57:main.c        **** 	T1=26.0;
 311               		.loc 1 57 0
 312 001e 80E0      		ldi r24,0
 313 0020 90E0      		ldi r25,0
 314 0022 A0ED      		ldi r26,lo8(-48)
 315 0024 B1E4      		ldi r27,lo8(65)
 316 0026 8093 0000 		sts T1,r24
 317 002a 9093 0000 		sts T1+1,r25
 318 002e A093 0000 		sts T1+2,r26
 319 0032 B093 0000 		sts T1+3,r27
  58:main.c        **** 	T2=28.0;
 320               		.loc 1 58 0
 321 0036 80E0      		ldi r24,0
 322 0038 90E0      		ldi r25,0
 323 003a A0EE      		ldi r26,lo8(-32)
 324 003c B1E4      		ldi r27,lo8(65)
 325 003e 8093 0000 		sts T2,r24
 326 0042 9093 0000 		sts T2+1,r25
 327 0046 A093 0000 		sts T2+2,r26
 328 004a B093 0000 		sts T2+3,r27
  59:main.c        **** 	
  60:main.c        **** 	sei();
 329               		.loc 1 60 0
 330               	/* #APP */
 331               	 ;  60 "main.c" 1
 332 004e 7894      		sei
 333               	 ;  0 "" 2
  61:main.c        **** 	
  62:main.c        **** 	fprintf(&u_stream, "\tPodaj Tmin: ");
 334               		.loc 1 62 0
 335               	/* #NOAPP */
 336 0050 60E0      		ldi r22,lo8(u_stream)
 337 0052 70E0      		ldi r23,hi8(u_stream)
 338 0054 80E0      		ldi r24,lo8(.LC4)
 339 0056 90E0      		ldi r25,hi8(.LC4)
 340 0058 0E94 0000 		call fputs
  63:main.c        **** 	while(1){
  64:main.c        **** 		DS18B20_start();
  65:main.c        **** 		_delay_ms(750);
  66:main.c        **** 		temp = DS18B20_read();
  67:main.c        **** 		lcd_clear();
  68:main.c        **** 		T = (float) temp * 0.0625;
  69:main.c        **** 		fprintf(&lcd_stream, "T = %.4f", T);
 341               		.loc 1 69 0
 342 005c 00E0      		ldi r16,lo8(.LC5)
 343 005e 10E0      		ldi r17,hi8(.LC5)
 344 0060 C0E0      		ldi r28,lo8(lcd_stream)
 345 0062 D0E0      		ldi r29,hi8(lcd_stream)
  70:main.c        **** 		
  71:main.c        **** 		lcd_set_xy(11,0);
  72:main.c        **** 		lcd_write_data(0b11011111);
  73:main.c        **** 		lcd_write_text_xy(12,0,"C");
  74:main.c        **** 		lcd_set_xy(0,1);
  75:main.c        **** 		fprintf(&lcd_stream, "T1=%.1f,T2=%.1f", T1, T2);
 346               		.loc 1 75 0
 347 0064 80E0      		ldi r24,lo8(.LC7)
 348 0066 E82E      		mov r14,r24
 349 0068 80E0      		ldi r24,hi8(.LC7)
 350 006a F82E      		mov r15,r24
  76:main.c        **** 		
  77:main.c        **** 		if(T>T2) PORTD = 0xFF;
 351               		.loc 1 77 0
 352 006c AA24      		clr r10
 353 006e AA94      		dec r10
 354               	.L12:
  64:main.c        **** 		_delay_ms(750);
 355               		.loc 1 64 0
 356 0070 0E94 0000 		call DS18B20_start
 357               	.LBB4:
 358               	.LBB5:
 359               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 360               		.loc 2 187 0
 361 0074 2FEF      		ldi r18,lo8(2399999)
 362 0076 8EE9      		ldi r24,hi8(2399999)
 363 0078 94E2      		ldi r25,hlo8(2399999)
 364 007a 2150      	1:	subi r18,1
 365 007c 8040      		sbci r24,0
 366 007e 9040      		sbci r25,0
 367 0080 01F4      		brne 1b
 368 0082 00C0      		rjmp .
 369 0084 0000      		nop
 370               	.LBE5:
 371               	.LBE4:
  66:main.c        **** 		lcd_clear();
 372               		.loc 1 66 0
 373 0086 0E94 0000 		call DS18B20_read
 374 008a 6C01      		movw r12,r24
  67:main.c        **** 		T = (float) temp * 0.0625;
 375               		.loc 1 67 0
 376 008c 0E94 0000 		call lcd_clear
  68:main.c        **** 		fprintf(&lcd_stream, "T = %.4f", T);
 377               		.loc 1 68 0
 378 0090 B601      		movw r22,r12
 379 0092 80E0      		ldi r24,0
 380 0094 90E0      		ldi r25,0
 381 0096 0E94 0000 		call __floatunsisf
 382 009a 20E0      		ldi r18,0
 383 009c 30E0      		ldi r19,0
 384 009e 40E8      		ldi r20,lo8(-128)
 385 00a0 5DE3      		ldi r21,lo8(61)
 386 00a2 0E94 0000 		call __mulsf3
 387 00a6 962E      		mov r9,r22
 388 00a8 B72E      		mov r11,r23
 389 00aa 6C01      		movw r12,r24
  69:main.c        **** 		
 390               		.loc 1 69 0
 391 00ac DF92      		push r13
 392               	.LCFI32:
 393               		.cfi_def_cfa_offset 3
 394 00ae 8F93      		push r24
 395               	.LCFI33:
 396               		.cfi_def_cfa_offset 4
 397 00b0 7F93      		push r23
 398               	.LCFI34:
 399               		.cfi_def_cfa_offset 5
 400 00b2 6F93      		push r22
 401               	.LCFI35:
 402               		.cfi_def_cfa_offset 6
 403 00b4 1F93      		push r17
 404               	.LCFI36:
 405               		.cfi_def_cfa_offset 7
 406 00b6 0F93      		push r16
 407               	.LCFI37:
 408               		.cfi_def_cfa_offset 8
 409 00b8 DF93      		push r29
 410               	.LCFI38:
 411               		.cfi_def_cfa_offset 9
 412 00ba CF93      		push r28
 413               	.LCFI39:
 414               		.cfi_def_cfa_offset 10
 415 00bc 0E94 0000 		call fprintf
  71:main.c        **** 		lcd_write_data(0b11011111);
 416               		.loc 1 71 0
 417 00c0 60E0      		ldi r22,0
 418 00c2 8BE0      		ldi r24,lo8(11)
 419 00c4 0E94 0000 		call lcd_set_xy
  72:main.c        **** 		lcd_write_text_xy(12,0,"C");
 420               		.loc 1 72 0
 421 00c8 8FED      		ldi r24,lo8(-33)
 422 00ca 0E94 0000 		call lcd_write_data
  73:main.c        **** 		lcd_set_xy(0,1);
 423               		.loc 1 73 0
 424 00ce 40E0      		ldi r20,lo8(.LC6)
 425 00d0 50E0      		ldi r21,hi8(.LC6)
 426 00d2 60E0      		ldi r22,0
 427 00d4 8CE0      		ldi r24,lo8(12)
 428 00d6 0E94 0000 		call lcd_write_text_xy
  74:main.c        **** 		fprintf(&lcd_stream, "T1=%.1f,T2=%.1f", T1, T2);
 429               		.loc 1 74 0
 430 00da 61E0      		ldi r22,lo8(1)
 431 00dc 80E0      		ldi r24,0
 432 00de 0E94 0000 		call lcd_set_xy
  75:main.c        **** 		
 433               		.loc 1 75 0
 434 00e2 8091 0000 		lds r24,T2+3
 435 00e6 8F93      		push r24
 436               	.LCFI40:
 437               		.cfi_def_cfa_offset 11
 438 00e8 8091 0000 		lds r24,T2+2
 439 00ec 8F93      		push r24
 440               	.LCFI41:
 441               		.cfi_def_cfa_offset 12
 442 00ee 8091 0000 		lds r24,T2+1
 443 00f2 8F93      		push r24
 444               	.LCFI42:
 445               		.cfi_def_cfa_offset 13
 446 00f4 8091 0000 		lds r24,T2
 447 00f8 8F93      		push r24
 448               	.LCFI43:
 449               		.cfi_def_cfa_offset 14
 450 00fa 8091 0000 		lds r24,T1+3
 451 00fe 8F93      		push r24
 452               	.LCFI44:
 453               		.cfi_def_cfa_offset 15
 454 0100 8091 0000 		lds r24,T1+2
 455 0104 8F93      		push r24
 456               	.LCFI45:
 457               		.cfi_def_cfa_offset 16
 458 0106 8091 0000 		lds r24,T1+1
 459 010a 8F93      		push r24
 460               	.LCFI46:
 461               		.cfi_def_cfa_offset 17
 462 010c 8091 0000 		lds r24,T1
 463 0110 8F93      		push r24
 464               	.LCFI47:
 465               		.cfi_def_cfa_offset 18
 466 0112 FF92      		push r15
 467               	.LCFI48:
 468               		.cfi_def_cfa_offset 19
 469 0114 EF92      		push r14
 470               	.LCFI49:
 471               		.cfi_def_cfa_offset 20
 472 0116 DF93      		push r29
 473               	.LCFI50:
 474               		.cfi_def_cfa_offset 21
 475 0118 CF93      		push r28
 476               	.LCFI51:
 477               		.cfi_def_cfa_offset 22
 478 011a 0E94 0000 		call fprintf
 479               		.loc 1 77 0
 480 011e 8DB7      		in r24,__SP_L__
 481 0120 9EB7      		in r25,__SP_H__
 482 0122 4496      		adiw r24,20
 483 0124 0FB6      		in __tmp_reg__,__SREG__
 484 0126 F894      		cli
 485 0128 9EBF      		out __SP_H__,r25
 486 012a 0FBE      		out __SREG__,__tmp_reg__
 487 012c 8DBF      		out __SP_L__,r24
 488               	.LCFI52:
 489               		.cfi_def_cfa_offset 2
 490 012e 2091 0000 		lds r18,T2
 491 0132 3091 0000 		lds r19,T2+1
 492 0136 4091 0000 		lds r20,T2+2
 493 013a 5091 0000 		lds r21,T2+3
 494 013e 692D      		mov r22,r9
 495 0140 7B2D      		mov r23,r11
 496 0142 8C2D      		mov r24,r12
 497 0144 9D2D      		mov r25,r13
 498 0146 0E94 0000 		call __gtsf2
 499 014a 1816      		cp __zero_reg__,r24
 500 014c 04F4      		brge .L10
 501               		.loc 1 77 0 is_stmt 0 discriminator 1
 502 014e A2BA      		out 0x12,r10
 503               	.L10:
  78:main.c        **** 		if(T<T1) PORTD = 0x00;
 504               		.loc 1 78 0 is_stmt 1
 505 0150 2091 0000 		lds r18,T1
 506 0154 3091 0000 		lds r19,T1+1
 507 0158 4091 0000 		lds r20,T1+2
 508 015c 5091 0000 		lds r21,T1+3
 509 0160 692D      		mov r22,r9
 510 0162 7B2D      		mov r23,r11
 511 0164 8C2D      		mov r24,r12
 512 0166 9D2D      		mov r25,r13
 513 0168 0E94 0000 		call __ltsf2
 514 016c 87FF      		sbrs r24,7
 515 016e 00C0      		rjmp .L12
 516               		.loc 1 78 0 is_stmt 0 discriminator 1
 517 0170 12BA      		out 0x12,__zero_reg__
 518 0172 00C0      		rjmp .L12
 519               		.cfi_endproc
 520               	.LFE12:
 522               		.comm	T2,4,1
 523               		.comm	T1,4,1
 524               		.comm	y,2,1
 525               		.comm	x,2,1
 526               	.global	etap
 527               		.section .bss
 530               	etap:
 531 0000 00        		.zero	1
 532               		.comm	i,1,1
 533               		.comm	tab,10,1
 534               	.global	lcd_stream
 535               		.data
 538               	lcd_stream:
 539 0000 0000 00   		.zero	3
 540 0003 02        		.byte	2
 541 0004 0000 0000 		.zero	4
 542 0008 0000      		.word	gs(lcd_putc)
 543 000a 0000      		.word	0
 544 000c 0000      		.word	0
 545               	.global	u_stream
 548               	u_stream:
 549 000e 0000 00   		.zero	3
 550 0011 02        		.byte	2
 551 0012 0000 0000 		.zero	4
 552 0016 0000      		.word	gs(u_putc)
 553 0018 0000      		.word	0
 554 001a 0000      		.word	0
 555               		.text
 556               	.Letext0:
 557               		.file 3 "/usr/lib/avr/include/stdint.h"
 558               		.file 4 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccwwc7S4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccwwc7S4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccwwc7S4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccwwc7S4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwwc7S4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwwc7S4.s:22     .text:0000000000000000 __vector_13
                            *COM*:0000000000000001 i
                            *COM*:000000000000000a tab
     /tmp/ccwwc7S4.s:530    .bss:0000000000000000 etap
                            *COM*:0000000000000004 T1
     /tmp/ccwwc7S4.s:548    .data:000000000000000e u_stream
                            *COM*:0000000000000004 T2
     /tmp/ccwwc7S4.s:286    .text.startup:0000000000000000 main
     /tmp/ccwwc7S4.s:538    .data:0000000000000000 lcd_stream
                            *COM*:0000000000000002 y
                            *COM*:0000000000000002 x

UNDEFINED SYMBOLS
atof
fprintf
fputs
__floatunsisf
__mulsf3
__gtsf2
__ltsf2
lcdinit
blink
USART_Init
OW_reset
DS18B20_start
DS18B20_read
lcd_clear
lcd_set_xy
lcd_write_data
lcd_write_text_xy
lcd_putc
u_putc
__do_copy_data
__do_clear_bss
